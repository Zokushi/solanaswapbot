This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-30T15:30:53.310Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
__tests__/bot.test.ts
__tests__/cli/components/ConfigList.test.tsx
__tests__/core/bot.test.ts
__tests__/core/multibot.test.ts
__tests__/MainMenu.test.tsx
__tests__/services/tradeService.test.ts
cli.ts
cli/App.tsx
cli/components/ConfigList.tsx
cli/components/Dashboard.tsx
cli/components/EnvVarInput.tsx
cli/components/MainMenu.tsx
cli/components/TokenSelector.tsx
cli/components/TransactionList.tsx
cli/context/AppContext.tsx
cli/forms/MultiBotForm.tsx
cli/forms/RegularBotForm.tsx
cli/hooks/useBotManagement.ts
cli/services/CLISocket.ts
config/index.ts
core/bot.ts
core/botManager.ts
core/multibot.ts
core/types.ts
scripts/run-cli.,mjs
scripts/seedTokens.ts
server.ts
services/botService.ts
services/configRepository.ts
services/configService.ts
services/eventBus.ts
services/getPrice.ts
services/multiBotService.ts
services/notificationService.ts
services/regularBotService.ts
services/repository.ts
services/rpcFactory.ts
services/socketService.ts
services/tokenDataService.ts
services/tradeService.ts
services/transactionRepository.ts
services/transactionService.ts
utils/errorHandler.ts
utils/errors.ts
utils/helper.ts
utils/logger.ts
utils/prismaClient.ts
utils/replacer.ts
utils/seralize.ts
utils/tokenCache.ts

================================================================
Repository Files
================================================================

================
File: __tests__/bot.test.ts
================
import { TradeBot } from '../core/bot.js';
import { QuoteResponse, NextTrade } from '../core/types.js';
import { NotificationService } from '../services/notificationService.js';
import { ConfigService } from '../services/configService.js';
import { Socket } from 'socket.io-client';
import { jest } from '@jest/globals';

// Mock dependencies
jest.mock('../services/notificationService.js');
jest.mock('../services/configService.js');
jest.mock('socket.io-client');

describe('TradeBot', () => {
  let bot: TradeBot;
  let mockSocket: jest.Mocked<Socket>;
  let mockNotificationService: jest.Mocked<NotificationService>;
  let mockConfigService: jest.Mocked<ConfigService>;

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();

    // Create mock socket
    mockSocket = {
      emit: jest.fn(),
      on: jest.fn(),
      off: jest.fn(),
    } as unknown as jest.Mocked<Socket>;

    // Create mock notification service
    mockNotificationService = {
      log: jest.fn(),
      emit: jest.fn(),
      logSwap: jest.fn(),
    } as unknown as jest.Mocked<NotificationService>;

    // Create mock config service
    mockConfigService = {
      updateBotConfig: jest.fn(),
    } as unknown as jest.Mocked<ConfigService>;

    // Create mock wallet
    const mockWallet = {
      publicKey: {
        algorithm: { name: 'ECDSA', namedCurve: 'P-256' },
        extractable: true,
        type: 'public',
        usages: ['verify'],
      },
      privateKey: {
        algorithm: { name: 'ECDSA', namedCurve: 'P-256' },
        extractable: true,
        type: 'private',
        usages: ['sign'],
      },
    } as CryptoKeyPair;

    // Create bot instance with mock dependencies
    bot = new TradeBot({
      botId: 'test-bot',
      wallet: mockWallet,
      rpc: {} as any,
      subscriptions: {} as any,
      firstTradePrice: 1000,
      targetGainPercentage: 1,
      initialInputToken: 'input-token',
      initialInputAmount: 1000,
      initialOutputToken: 'output-token',
    }, mockSocket);

    // Initialize nextTrade property
    Object.defineProperty(bot, 'nextTrade', {
      value: {
        inputMint: 'input-token',
        outputMint: 'output-token',
        amount: 1000,
        swapMode: 'ExactIn',
      },
      writable: true,
    });

    // Replace services with mocks using Object.defineProperty
    Object.defineProperty(bot, 'notificationService', {
      value: mockNotificationService,
      writable: true,
    });
    Object.defineProperty(bot, 'configService', {
      value: mockConfigService,
      writable: true,
    });
  });

  describe('updateNextTrade', () => {
    it('should update next trade with correct amounts and target price', async () => {
      // Setup target gain percentage
      bot['targetGainPercentage'] = 1; // 1% target gain

      // Create mock quote response
      const mockQuote: QuoteResponse = {
        inputMint: 'input-token',
        inAmount: '1000000', // 1000 with 3 decimals
        outputMint: 'output-token',
        outAmount: '1010000', // 1010 with 3 decimals
        otherAmountThreshold: '0',
        swapMode: 'ExactIn',
        slippageBps: 50,
        priceImpactPct: '0.1',
        routePlan: [],
      };

      // Call updateNextTrade
      await bot['updateNextTrade'](mockQuote);

      // Verify next trade was updated correctly
      const expectedNextTrade = {
        inputMint: 'output-token',  // Should be swapped
        outputMint: 'input-token',  // Should be swapped
        amount: 1010000,           // Should be the output amount from the quote
        swapMode: 'ExactIn',
      };

      expect(bot['nextTrade']).toEqual(expectedNextTrade);

      // Verify firstTradePrice was updated
      // Expected: 1000000 (input) + 10000 (1% of input) = 1010000
      expect(bot['firstTradePrice']).toBe(1010000);

      // Additional verification of the trade reversal
      expect(bot['nextTrade'].inputMint).toBe(mockQuote.outputMint);
      expect(bot['nextTrade'].outputMint).toBe(mockQuote.inputMint);
      expect(bot['nextTrade'].amount).toBe(Number(mockQuote.outAmount));
    });

    it('should reverse trade direction when target gain is reached', async () => {
      // Setup initial state
      bot['targetGainPercentage'] = 1; // 1% target gain

      // Create mock quote response with gain exceeding target
      const mockQuote: QuoteResponse = {
        inputMint: 'input-token',
        inAmount: '1000000', // 1000 with 3 decimals
        outputMint: 'output-token',
        outAmount: '1020000', // 1020 with 3 decimals (2% gain)
        otherAmountThreshold: '0',
        swapMode: 'ExactIn',
        slippageBps: 50,
        priceImpactPct: '0.1',
        routePlan: [],
      };

      // Spy on terminateSession to ensure it's NOT called
      const terminateSpy = jest.spyOn(bot, 'terminateSession');

      // Call updateNextTrade
      await bot['updateNextTrade'](mockQuote);

      // Verify bot did NOT terminate
      expect(terminateSpy).not.toHaveBeenCalled();

      // Verify trade direction was reversed
      expect(bot['nextTrade']).toEqual({
        inputMint: 'output-token',
        outputMint: 'input-token',
        amount: 1020000,
        swapMode: 'ExactIn',
      });

      // Verify target price was updated
      expect(bot['firstTradePrice']).toBe(1010000); // 1000000 + 1% = 1010000
    });

    it('should throw error for invalid target gain percentage', async () => {
      // Setup initial state with invalid target gain
      bot['targetGainPercentage'] = 0;

      const mockQuote: QuoteResponse = {
        inputMint: 'input-token',
        inAmount: '1000000',
        outputMint: 'output-token',
        outAmount: '1010000',
        otherAmountThreshold: '0',
        swapMode: 'ExactIn',
        slippageBps: 50,
        priceImpactPct: '0.1',
        routePlan: [],
      };

      // Verify error is thrown
      await expect(bot['updateNextTrade'](mockQuote)).rejects.toThrow(
        'Invalid target gain percentage'
      );
    });
  });
});

================
File: __tests__/cli/components/ConfigList.test.tsx
================
// __tests__/cli/components/ConfigList.test.tsx
import React from 'react';
import { render } from 'ink-testing-library';
import { ConfigList } from '../../cli/components/ConfigList';
import { jest } from '@jest/globals';
import { useAppContext } from '../../cli/context/AppContext';
import { ConfigData, BotWithType } from '../../core/types';
import { getSingleTokenData } from '../../services/tokenDataService';
import logger from '../../utils/logger';

// Mock dependencies
jest.mock('../../cli/context/AppContext');
jest.mock('../../services/tokenDataService');
jest.mock('../../utils/logger');

describe('ConfigList', () => {
  const mockBot: BotWithType = {
    botId: 'test-bot-123',
    type: 'regular',
    initialInputToken: 'SOL',
    initialOutputToken: 'USDC',
    initialInputAmount: 1000,
    targetGainPercentage: BigInt(5),
    stopLossPercentage: BigInt(2),
    firstTradePrice: BigInt(1000),
    status: 'running',
    amount: 1000,
  };

  const mockConfigs: ConfigData = {
    regularBots: [mockBot],
    multiBots: [],
  };

  let mockEventBus: any;

  beforeEach(() => {
    jest.clearAllMocks();
    mockEventBus = {
      on: jest.fn(),
      off: jest.fn(),
      emit: jest.fn(),
    };
    (useAppContext as jest.Mock).mockReturnValue({
      cliSocket: {
        getEventBus: jest.fn().mockReturnValue(mockEventBus),
        stopBot: jest.fn().mockResolvedValue(undefined),
        deleteConfig: jest.fn().mockResolvedValue(undefined),
      },
    });
    (getSingleTokenData as jest.Mock).mockImplementation(async (mint) => ({
      address: mint,
      name: mint === 'SOL' ? 'Wrapped SOL' : 'USD Coin',
      symbol: mint,
    }));
  });

  it('renders loading state', () => {
    const { lastFrame } = render(<ConfigList onBack={jest.fn()} />);
    expect(lastFrame()).toContain('Loading configurations...');
  });

  it('renders bot configurations', () => {
    mockEventBus.on.mockImplementation((event, callback) => {
      if (event === 'configUpdate') callback(mockConfigs);
    });

    const { lastFrame } = render(<ConfigList onBack={jest.fn()} />);
    expect(lastFrame()).toContain('regular - SOL 1000');
  });

  it('renders selected bot details', () => {
    mockEventBus.on.mockImplementation((event, callback) => {
      if (event === 'configUpdate') callback(mockConfigs);
    });

    const { lastFrame, stdin } = render(<ConfigList onBack={jest.fn()} />);
    stdin.write('\r'); // Select bot
    expect(lastFrame()).toContain('ID: test-bot');
    expect(lastFrame()).toContain('Type: Regular Bot');
    expect(lastFrame()).toContain('Input Token: Wrapped SOL');
    expect(lastFrame()).toContain('Output Token: USD Coin');
    expect(lastFrame()).toContain('Target Gain (%): 5');
  });

  it('handles delete action', async () => {
    mockEventBus.on.mockImplementation((event, callback) => {
      if (event === 'configUpdate') callback(mockConfigs);
    });

    const mockOnBack = jest.fn();
    const { stdin } = render(<ConfigList onBack={mockOnBack} />);
    stdin.write('\r'); // Select bot
    stdin.write('\u001b[A'); // Up arrow to select 'delete'
    stdin.write('\r'); // Confirm delete
    await new Promise(resolve => setTimeout(resolve, 0)); // Wait for async operations
    expect(useAppContext().cliSocket.stopBot).toHaveBeenCalledWith('test-bot-123');
    expect(useAppContext().cliSocket.deleteConfig).toHaveBeenCalledWith('test-bot-123', 'regular');
  });
});

================
File: __tests__/core/bot.test.ts
================
import { TradeBot } from '../../core/bot.js';
import { QuoteResponse, NextTrade } from '../../core/types.js';
import { NotificationService } from '../../services/notificationService.js';
import { ConfigService } from '../../services/configService.js';
import { Socket } from 'socket.io-client';
import { jest } from '@jest/globals';

// Shared mock factory
const createMockDependencies = () => ({
  socket: {
    emit: jest.fn(),
    on: jest.fn(),
    off: jest.fn(),
  } as unknown as jest.Mocked<Socket>,
  notificationService: {
    log: jest.fn(),
    emit: jest.fn(),
    logSwap: jest.fn(),
  } as unknown as jest.Mocked<NotificationService>,
  configService: {
    updateBotConfig: jest.fn(),
  } as unknown as jest.Mocked<ConfigService>,
  wallet: {
    publicKey: { algorithm: { name: 'ECDSA', namedCurve: 'P-256' }, extractable: true, type: 'public', usages: ['verify'] },
    privateKey: { algorithm: { name: 'ECDSA', namedCurve: 'P-256' }, extractable: true, type: 'private', usages: ['sign'] },
  } as CryptoKeyPair,
});

// Base bot configuration
const baseBotConfig = {
  botId: 'test-bot',
  rpc: {} as any,
  subscriptions: {} as any,
  firstTradePrice: 1000,
  targetGainPercentage: 1,
  initialInputToken: 'input-token',
  initialInputAmount: 1000,
  initialOutputToken: 'output-token',
};

// Base quote response
const baseQuote: QuoteResponse = {
  inputMint: 'input-token',
  inAmount: '1000000',
  outputMint: 'output-token',
  outAmount: '1010000',
  otherAmountThreshold: '0',
  swapMode: 'ExactIn',
  slippageBps: 50,
  priceImpactPct: '0.1',
  routePlan: [],
};

jest.mock('../../services/notificationService');
jest.mock('../../services/configService');
jest.mock('socket.io-client');

describe('TradeBot', () => {
  let bot: TradeBot;
  let mocks: ReturnType<typeof createMockDependencies>;

  beforeEach(() => {
    jest.clearAllMocks();
    mocks = createMockDependencies();
    bot = new TradeBot({ ...baseBotConfig, wallet: mocks.wallet }, mocks.socket);
    Object.defineProperties(bot, {
      notificationService: { value: mocks.notificationService, writable: true },
      configService: { value: mocks.configService, writable: true },
      nextTrade: {
        value: { inputMint: 'input-token', outputMint: 'output-token', amount: 1000, swapMode: 'ExactIn' },
        writable: true,
      },
    });
  });

  describe('updateNextTrade', () => {
    it('updates next trade with correct amounts and target price', async () => {
      await bot['updateNextTrade']({ ...baseQuote });
      expect(bot['nextTrade']).toEqual({
        inputMint: 'output-token',
        outputMint: 'input-token',
        amount: 1010000,
        swapMode: 'ExactIn',
      });
      expect(bot['firstTradePrice']).toBe(1010000);
    });

    it('reverses trade direction when target gain is reached', async () => {
      const highGainQuote = { ...baseQuote, outAmount: '1020000' };
      const terminateSpy = jest.spyOn(bot, 'terminateSession');
      await bot['updateNextTrade'](highGainQuote);
      expect(terminateSpy).not.toHaveBeenCalled();
      expect(bot['nextTrade']).toEqual({
        inputMint: 'output-token',
        outputMint: 'input-token',
        amount: 1020000,
        swapMode: 'ExactIn',
      });
      expect(bot['firstTradePrice']).toBe(1010000);
    });

    it('throws error for invalid target gain percentage', async () => {
      bot['targetGainPercentage'] = 0;
      await expect(bot['updateNextTrade']({ ...baseQuote })).rejects.toThrow('Invalid target gain percentage');
    });
  });
});

================
File: __tests__/core/multibot.test.ts
================
import { MultiBot } from '../../core/multibot.js';
import { ConfigService } from '../../services/configService.js';
import { TradeService } from '../../services/tradeService.js';
import { NotificationService } from '../../services/notificationService.js';
import { Socket } from 'socket.io-client';
import { Address, createKeyPairFromBytes, getAddressFromPublicKey } from '@solana/kit';
import { jest } from '@jest/globals';
import { QuoteResponse } from '../../core/types.js';
import fs from 'fs';

const SOL = "So11111111111111111111111111111111111111112";
const USDC = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
const POPCAT = "7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr";
const GIGACHAD = "63LfDmNb3MQ8mw9MtZ2To9bEA2M71kZUUGq5tiJxcqj9";
const DOGWIFHAT = "8GmjQWW6agtTrpL3Bkb6q9o3UA1LqjEzhPKTCsjbpTtK";

// Mock dependencies
jest.mock('../../services/configService.js');
jest.mock('../../services/tradeService.js');
jest.mock('../../services/notificationService.js');
jest.mock('socket.io-client');
jest.mock('@solana/kit', () => {
  const actual = jest.requireActual('@solana/kit') as Record<string, unknown>;
  return {
    ...actual,
    getAddressFromPublicKey: jest.fn().mockImplementation(async () => 'mockWalletAddress' as Address)
  };
});
jest.mock('../../utils/helper.js', () => ({
  getTokenDecimalsByAddressRaw: jest.fn().mockImplementation(async (...args: unknown[]) => {
    const address = args[0] as string;
    if (address === SOL) return 9;
    if (address === USDC) return 6;
    if (address === POPCAT) return 6;
    if (address === GIGACHAD) return 6;
    if (address === DOGWIFHAT) return 6;
    throw new Error(`Token with address "${address}" not found.`);
  }),
  getTokenName: jest.fn().mockImplementation(async (...args: unknown[]) => {
    const address = args[0] as string;
    if (address === SOL) return "Wrapped SOL";
    if (address === USDC) return "USD Coin";
    if (address === POPCAT) return "POPCAT";
    if (address === GIGACHAD) return "GIGACHAD";
    if (address === DOGWIFHAT) return "dogwifhat";
    throw new Error(`Token with address "${address}" not found.`);
  }),
  getTokenDecimalsByAddress: jest.fn().mockImplementation(async (...args: unknown[]) => {
    const [address, value] = args as [string, number];
    if (address === SOL) return value / Math.pow(10, 9);
    if (address === USDC) return value / Math.pow(10, 6);
    if (address === POPCAT) return value / Math.pow(10, 6);
    if (address === GIGACHAD) return value / Math.pow(10, 6);
    if (address === DOGWIFHAT) return value / Math.pow(10, 6);
    throw new Error(`Token with address "${address}" not found.`);
  })
}));

// Mock MultiBot constructor
jest.mock('../../core/multibot.js', () => {
  const actual = jest.requireActual('../../core/multibot.js') as { MultiBot: typeof MultiBot };
  return {
    MultiBot: jest.fn().mockImplementation(function(this: any, config: any, socket: any) {
      const instance = new actual.MultiBot(config, socket);
      // These will be set in beforeEach
      (instance as any).configService = undefined;
      (instance as any).tradeService = undefined;
      (instance as any).notificationService = undefined;
      return instance;
    })
  };
});

describe('MultiBot', () => {
  let mockSocket: jest.Mocked<Socket>;
  let mockConfigService: jest.Mocked<ConfigService>;
  let mockTradeService: jest.Mocked<TradeService>;
  let mockNotificationService: jest.Mocked<NotificationService>;
  let bot: MultiBot;
  let mockConfig: any;

  beforeAll(async () => {
    // Read test wallet keypair
    const keypairBytes = JSON.parse(fs.readFileSync('test-wallet.json', 'utf-8'));
    const keypair = await createKeyPairFromBytes(new Uint8Array(keypairBytes));
    
    mockConfig = {
      botId: 'test-bot',
      rpc: {} as any,
      subscriptions: {} as any,
      wallet: keypair,
      initialInputToken: SOL,
      targetAmounts: {
        [USDC]: 100
      },
      initialBalance: 1000,
      targetGainPercentage: 5,
      checkInterval: 20000
    };
  });

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();

    // Setup mock implementations
    mockSocket = { on: jest.fn(), emit: jest.fn() } as unknown as jest.Mocked<Socket>;
    mockConfigService = new ConfigService() as jest.Mocked<ConfigService>;
    mockTradeService = new TradeService(
      'test-bot',
      mockConfig.wallet,
      mockConfig.rpc,
      mockConfig.subscriptions,
      async () => {},
      () => {}
    ) as jest.Mocked<TradeService>;
    mockNotificationService = new NotificationService() as jest.Mocked<NotificationService>;

    // Mock ConfigService methods
    mockConfigService.updateBotConfig = jest.fn<(botId: string, data: any) => Promise<any>>().mockResolvedValue(undefined);

    // Mock TradeService methods
    mockTradeService.getFilteredTokenAccounts = jest.fn<(wallet: Address, mint: Address) => Promise<string>>().mockResolvedValue('mockTokenAccount');
    mockTradeService.getQuote2 = jest.fn<(quoteRequest: any) => Promise<QuoteResponse | undefined>>().mockResolvedValue({
      inputMint: SOL,
      outputMint: USDC,
      inAmount: '1000',
      outAmount: '1100',
      otherAmountThreshold: '0',
      swapMode: 'ExactIn',
      slippageBps: 50,
      priceImpactPct: '0.1',
      routePlan: []
    });

    // Mock NotificationService methods
    mockNotificationService.logSwap = jest.fn<(args: any) => Promise<void>>().mockResolvedValue(undefined);
    mockNotificationService.emit = jest.fn<(socket: Socket, event: string, data: any) => void>();

    // Create bot instance with mocked services
    bot = new MultiBot({
      ...mockConfig,
      configService: mockConfigService,
      tradeService: mockTradeService,
      notificationService: mockNotificationService
    } as any, mockSocket);

    // Set the mock services on the bot instance
    (bot as any).configService = mockConfigService;
    (bot as any).tradeService = mockTradeService;
    (bot as any).notificationService = mockNotificationService;
  });

  describe('postTransactionProcessing', () => {
    afterEach(() => {
      if (bot) {
        bot.terminateSession();
      }
    });

    it('should update config file after successful trade', async () => {
      // Mock quote response
      const mockQuote: QuoteResponse = {
        inputMint: SOL,
        outputMint: USDC,
        inAmount: '1000',
        outAmount: '1100',
        otherAmountThreshold: '0',
        swapMode: 'ExactIn',
        slippageBps: 50,
        priceImpactPct: '0.1',
        routePlan: []
      };

      // Call postTransactionProcessing
      await bot.postTransactionProcessing(mockQuote, 'mockTxId');

      // Verify config was updated
      expect(mockConfigService.updateBotConfig).toHaveBeenCalledWith(
        'test-bot',
        expect.objectContaining({
          botId: 'test-bot',
          initialInputToken: expect.any(String),
          initialBalance: expect.any(Number),
          targetAmounts: expect.any(Object),
          targetGainPercentage: 5,
          checkInterval: 20000
        })
      );
    });

    it('should handle config update errors gracefully', async () => {
      // Mock quote response
      const mockQuote: QuoteResponse = {
        inputMint: SOL,
        outputMint: USDC,
        inAmount: '1000',
        outAmount: '1100',
        otherAmountThreshold: '0',
        swapMode: 'ExactIn',
        slippageBps: 50,
        priceImpactPct: '0.1',
        routePlan: []
      };

      // Call postTransactionProcessing - should not throw
      await expect(bot.postTransactionProcessing(mockQuote, 'mockTxId')).resolves.not.toThrow();

      // Verify config update was attempted
      expect(mockConfigService.updateBotConfig).toHaveBeenCalled();
    });
  });
});

================
File: __tests__/MainMenu.test.tsx
================
import React from 'react';
import { render } from 'ink-testing-library';
import { MainMenu } from '../cli/components/MainMenu.js';
import { jest, describe, it, expect } from '@jest/globals';

describe('MainMenu', () => {
  const mockOptions = [
    'Option 1',
    'Option 2',
    'Option 3'
  ];

  it('renders all options', () => {
    const { lastFrame } = render(<MainMenu options={mockOptions} selectedOption={0} />);
    expect(lastFrame()).toContain('Option 1');
    expect(lastFrame()).toContain('Option 2');
    expect(lastFrame()).toContain('Option 3');
  });

  it('shows selected option with > prefix', () => {
    const { lastFrame } = render(<MainMenu options={mockOptions} selectedOption={1} />);
    expect(lastFrame()).toContain('> Option 2');
  });

  it('shows unselected options with two spaces', () => {
    const { lastFrame } = render(<MainMenu options={mockOptions} selectedOption={1} />);
    expect(lastFrame()).toContain('  Option 1');
    expect(lastFrame()).toContain('  Option 3');
  });

  it('shows instruction text', () => {
    const { lastFrame } = render(<MainMenu options={mockOptions} selectedOption={0} />);
    expect(lastFrame()).toContain('Use ↑↓ arrows to select an option and Enter to confirm');
  });

  it('handles empty options array', () => {
    const { lastFrame } = render(<MainMenu options={[]} selectedOption={0} />);
    expect(lastFrame()).toContain('Use ↑↓ arrows to select an option and Enter to confirm');
  });

  it('handles out of bounds selected option', () => {
    const { lastFrame } = render(<MainMenu options={mockOptions} selectedOption={5} />);
    expect(lastFrame()).toContain('Option 1');
    expect(lastFrame()).toContain('Option 2');
    expect(lastFrame()).toContain('Option 3');
  });
});

================
File: __tests__/services/tradeService.test.ts
================
// __tests__/services/tradeService.test.ts
import { TradeService } from '../../services/tradeService.js';
import { QuoteResponse, QuoteGetRequest } from '../../core/types.js';
import { Rpc, Address, SolanaRpcApiMainnet } from '@solana/kit';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { jest } from '@jest/globals';
import { TradeBotError, ErrorCodes } from '../../utils/errors.js';
import logger from '../../utils/logger.js';

// Mock dependencies
jest.mock('@solana/kit');
jest.mock('../../utils/logger');
jest.mock('../../utils/error', () => ({
  TradeBotError: jest.fn().mockImplementation((message, code, data) => ({
    message,
    code,
    data,
  })),
  ErrorCodes: {
    TOKEN_ACCOUNT_ERROR: 'TOKEN_ACCOUNT_ERROR',
    QUOTE_FETCH_ERROR: 'QUOTE_FETCH_ERROR',
  },
}));
describe('TradeService', () => {
  let tradeService: TradeService;
  let mockRpc: jest.Mocked<Rpc<SolanaRpcApiMainnet>>;
  let mockSubscriptions: any;
  let mockWallet: CryptoKeyPair;
  let mockPostTransactionProcessing: jest.Mock<Promise<void>, [QuoteResponse, string]>;
  let mockSetWaitingForConfirmation: jest.Mock<void, [boolean]>;

  beforeEach(() => {
    jest.clearAllMocks();
    mockRpc = {
      getTokenAccountsByOwner: jest.fn().mockReturnValue({
        send: jest.fn().mockResolvedValue({
          context: { slot: BigInt(123) },
          value: [{
            pubkey: 'mockTokenAccount' as Address,
            account: {
              data: {
                parsed: {
                  info: {
                    tokenAmount: { uiAmountString: '100', amount: '1000000000', decimals: 9, uiAmount: 100 },
                    mint: 'mintAddress' as Address,
                    owner: 'walletAddress' as Address,
                    state: 'initialized',
                  },
                },
                program: 'spl-token',
                space: 165,
              },
              executable: false,
              lamports: BigInt(2039280),
              owner: TOKEN_PROGRAM_ID,
              rentEpoch: BigInt(123),
            },
          }],
        } as GetTokenAccountsByOwnerResponse<Readonly<{ data: any }>>),
      }),
      getTokenAccountBalance: jest.fn().mockReturnValue({
        send: jest.fn().mockResolvedValue({
          context: { slot: BigInt(123) },
          value: { amount: '1000000000', decimals: 9, uiAmount: 100, uiAmountString: '100' },
        } as GetTokenAccountBalanceResponse),
      }),
      getLatestBlockhash: jest.fn().mockReturnValue({
        send: jest.fn().mockResolvedValue({
          context: { slot: BigInt(123) },
          value: { blockhash: 'mockBlockhash', lastValidBlockHeight: BigInt(1000) },
        } as GetLatestBlockhashResponse),
      }),
    } as any;

    mockSubscriptions = {
      signatureNotifications: jest.fn(),
    };

    mockWallet = {
      publicKey: {
        algorithm: { name: 'ECDSA' } as EcKeyAlgorithm,
        extractable: true,
        type: 'public',
        usages: ['verify'],
      } as CryptoKey,
      privateKey: {
        algorithm: { name: 'ECDSA' } as EcKeyAlgorithm,
        extractable: true,
        type: 'private',
        usages: ['sign'],
      } as CryptoKey,
    } as CryptoKeyPair;

    mockPostTransactionProcessing = jest.fn<Promise<void>, [QuoteResponse, string]>().mockResolvedValue(undefined);
    mockSetWaitingForConfirmation = jest.fn();

    tradeService = new TradeService(
      'test-bot',
      mockWallet,
      mockRpc,
      mockSubscriptions,
      mockPostTransactionProcessing,
      mockSetWaitingForConfirmation
    );
  });

  describe('getFilteredTokenAccounts', () => {
    it('should return cached token account if available', async () => {
      const mockCache = {
        get: jest.fn().mockReturnValue('cachedTokenAccount'),
        set: jest.fn(),
      };
      jest.spyOn(require('node-cache'), 'NodeCache').mockImplementation(() => mockCache);

      const result = await tradeService.getFilteredTokenAccounts('walletAddress' as Address, 'mintAddress' as Address);
      expect(result).toBe('cachedTokenAccount');
      expect(mockCache.get).toHaveBeenCalledWith('walletAddress:mintAddress');
    });

    it('should fetch and cache token account if not cached', async () => {
      const mockCache = {
        get: jest.fn().mockReturnValue(undefined),
        set: jest.fn(),
      };
      jest.spyOn(require('node-cache'), 'NodeCache').mockImplementation(() => mockCache);

      const result = await tradeService.getFilteredTokenAccounts('walletAddress' as Address, 'mintAddress' as Address);
      expect(result).toBe('mockTokenAccount');
      expect(mockRpc.getTokenAccountsByOwner).toHaveBeenCalled();
      expect(mockCache.set).toHaveBeenCalledWith('walletAddress:mintAddress', 'mockTokenAccount');
    });

    it('should throw TradeBotError if no token account is found', async () => {
      mockRpc.getTokenAccountsByOwner.mockReturnValue({
        send: jest.fn().mockResolvedValue({ context: { slot: BigInt(123) }, value: [] }),
      });

      await expect(tradeService.getFilteredTokenAccounts('walletAddress' as Address, 'mintAddress' as Address)).rejects.toThrow(
        new TradeBotError('No token account found for mint mintAddress', ErrorCodes.TOKEN_ACCOUNT_ERROR, { mint: 'mintAddress' })
      );
    });
  });

  describe('getQuote2', () => {
    it('should fetch and return a valid quote', async () => {
      const mockQuote: QuoteResponse = {
        inputMint: 'inputMint',
        outputMint: 'outputMint',
        inAmount: '1000',
        outAmount: '1100',
        otherAmountThreshold: '0',
        swapMode: 'ExactIn',
        slippageBps: 50,
        priceImpactPct: '0.1',
        routePlan: [],
      };

      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue(mockQuote),
        status: 200,
        statusText: 'OK',
      });

      const quoteRequest: QuoteGetRequest = {
        inputMint: 'inputMint',
        outputMint: 'outputMint',
        amount: 1000,
        autoSlippage: true,
        maxAutoSlippageBps: 50,
        platformFeeBps: 10,
      };

      const result = await tradeService.getQuote2(quoteRequest);
      expect(result).toEqual(mockQuote);
      expect(fetch).toHaveBeenCalledWith(
        expect.stringContaining('https://lite-api.jup.ag/swap/v1/quote?inputMint=inputMint&outputMint=outputMint&amount=1000'),
        expect.any(Object)
      );
    });

    it('should throw TradeBotError for invalid quote response', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({}),
        status: 200,
        statusText: 'OK',
      });

      const quoteRequest: QuoteGetRequest = {
        inputMint: 'inputMint',
        outputMint: 'outputMint',
        amount: 1000,
      };

      await expect(tradeService.getQuote2(quoteRequest)).rejects.toThrow(
        new TradeBotError('Invalid quote response: Missing outAmount', ErrorCodes.QUOTE_FETCH_ERROR, expect.any(Object))
      );
    });
  });
});

================
File: cli.ts
================
import cli from './cli/App.js';

// Run the CLI
cli();

================
File: cli/App.tsx
================
import React from 'react';
import { render, Box, Text, useInput, useApp } from 'ink';
import { DefaultBotManager } from '../core/botManager.js';
import { CLISocket } from './services/CLISocket.js';
import { useBotManagement } from './hooks/useBotManagement.js';
import RegularBotForm from './forms/RegularBotForm.js';
import { MultiBotForm } from './forms/MultiBotForm.js';
import ConfigList from './components/ConfigList.js';
import { AppProvider } from './context/AppContext.js';
import { EnvVarInput } from './components/EnvVarInput.js';
import TransactionList from './components/TransactionList.js';
import { MainMenu } from './components/MainMenu.js';
import Dashboard from './components/Dashboard.js';
import { createLogger } from '../utils/logger.js';
import { handleError } from '../utils/errorHandler.js';
import { ErrorCodes } from '../utils/errors.js';

const logger = createLogger('CLIApp');
const CHECK_BOTS_INTERVAL = 30000; // 30 seconds

const TRADE_BOT_ASCII = `
████████╗██████╗  █████╗ ██████╗ ███████╗    ██████╗  ██████╗ ████████╗
╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗██╔════╝    ██╔══██╗██╔═══██╗╚══██╔══╝
   ██║   ██████╔╝███████║██║  ██║█████╗      ██████╔╝██║   ██║   ██║   
   ██║   ██╔══██╗██╔══██║██║  ██║██╔══╝      ██╔══██╗██║   ██║   ██║   
   ██║   ██║  ██║██║  ██║██████╔╝███████╗    ██████╔╝╚██████╔╝   ██║   
   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝    ╚═════╝  ╚═════╝    ╚═╝   
`;

const App = () => {
  const { exit } = useApp();
  const [selectedOption, setSelectedOption] = React.useState(0);
  const [showForm, setShowForm] = React.useState(false);
  const [formType, setFormType] = React.useState<'regular' | 'multi' | null>(null);
  const [editingConfig, setEditingConfig] = React.useState<any>(null);
  const [showConfigList, setShowConfigList] = React.useState(false);
  const [showConfirmStartAll, setShowConfirmStartAll] = React.useState(false);
  const [envVarsComplete, setEnvVarsComplete] = React.useState(false);
  const [showTransactionList, setShowTransactionList] = React.useState(false);
  const [isConnected, setIsConnected] = React.useState(false);

  const botManager = React.useMemo(() => new DefaultBotManager(), []);
  const socket = React.useMemo(() => new CLISocket(botManager), [botManager]);
  const eventBus = socket.getEventBus();



  // Monitor socket connection
  React.useEffect(() => {
    const handleConnect = () => {
      logger.info('Socket connected to server', { method: 'socketConnect', socketId: socket.getSocket().id });
      setIsConnected(true);
    };

    const handleDisconnect = () => {
      logger.info('Socket disconnected from server', { method: 'socketDisconnect', socketId: socket.getSocket().id });
      setIsConnected(false);
    };

    const handleConnectError = (error: Error) => {
      logger.error('Socket connection error', { method: 'socketConnectError', error: error.message });
      setIsConnected(false);
    };

    socket.getSocket().on('connect', handleConnect);
    socket.getSocket().on('disconnect', handleDisconnect);
    socket.getSocket().on('connect_error', handleConnectError);

    if (!socket.getSocket().connected) {
      socket.getSocket().connect();
    }

    return () => {
      socket.getSocket().off('connect', handleConnect);
      socket.getSocket().off('disconnect', handleDisconnect);
      socket.getSocket().off('connect_error', handleConnectError);
    };
  }, [socket]);

  const {
    stoppingProgress,
    startingProgress,
    checkActiveBots,
    handleStopAllBots,
    handleStartAllBots,
    setStartingProgress,
  } = useBotManagement(botManager, socket);

  React.useEffect(() => {
    if (envVarsComplete && isConnected) {
      checkActiveBots();
      const interval = setInterval(checkActiveBots, CHECK_BOTS_INTERVAL);
      return () => clearInterval(interval);
    }
  }, [envVarsComplete, isConnected, checkActiveBots]);

  React.useEffect(() => {
    const handleConfigEdit = (data: unknown) => {
      if (
        typeof data === 'object' &&
        data !== null &&
        'type' in data &&
        (data as any).type &&
        (['regular', 'multi'] as const).includes((data as any).type) &&
        'config' in data
      ) {
        const typedData = data as { type: 'regular' | 'multi'; config: any };
        setFormType(typedData.type);
        setEditingConfig(typedData.config);
        setShowForm(true);
        setShowConfigList(false);
      } else {
        logger.error('Received invalid configUpdate event data', { data });
      }
    };

    eventBus.on('configUpdate', handleConfigEdit);

    return () => {
      eventBus.off('configUpdate', handleConfigEdit);
    };
  }, [eventBus]);

  const cleanup = React.useCallback(async () => {
    try {
      const botIds = [...botManager.activeBots.keys()];
      for (const botId of botIds) {
        await botManager.stopBot(botId);
      }
      if (socket) {
        socket.disconnect();
      }
      exit();
    } catch (error) {
      handleError(error, 'Error during CLI cleanup', ErrorCodes.API_ERROR.code, { method: 'cleanup' });
    }
  }, [botManager, socket, exit]);

  React.useEffect(() => {
    const handleSignal = async () => {
      await cleanup();
    };

    process.removeAllListeners('SIGINT');
    process.removeAllListeners('SIGTERM');
    process.setMaxListeners(20);

    process.on('SIGINT', handleSignal);
    process.on('SIGTERM', handleSignal);

    return () => {
      process.removeAllListeners('SIGINT');
      process.removeAllListeners('SIGTERM');
    };
  }, [cleanup]);

  useInput((input, key) => {
    if (!envVarsComplete || showForm || showConfigList || showTransactionList) return;

    if (showConfirmStartAll) {
      if (key.return && startingProgress.status === 'idle') {
        handleStartAllBots();
      } else if (key.escape && startingProgress.status === 'idle') {
        setShowConfirmStartAll(false);
        setStartingProgress({ current: 0, total: 0, status: 'idle', message: '' });
      } else if (startingProgress.status === 'success' && input) {
        setShowConfirmStartAll(false);
        setStartingProgress({ current: 0, total: 0, status: 'idle', message: '' });
      }
      return;
    }

    if (key.upArrow) {
      setSelectedOption((prev) => (prev > 0 ? prev - 1 : options.length - 1));
    }
    if (key.downArrow) {
      setSelectedOption((prev) => (prev < options.length - 1 ? prev + 1 : 0));
    }
    if (key.return) {
      if (selectedOption === options.length - 1) {
        cleanup();
      } else if (selectedOption === 0) {
        setShowConfigList(true);
      } else if (selectedOption === 1) {
        setFormType('regular');
        setShowForm(true);
      } else if (selectedOption === 2) {
        setFormType('multi');
        setShowForm(true);
      } else if (selectedOption === 3) {
        setShowConfirmStartAll(true);
      } else if (selectedOption === 4) {
        handleStopAllBots();
      } else if (selectedOption === 5) {
        setShowTransactionList(true);
      }
    }
  });

  const options = [
    'View All Configs',
    'Add New Config',
    'Add Multi Config',
    'Start All Bots',
    'Stop All Bots',
    'View Transactions',
    'Exit',
  ];

  if (!envVarsComplete) {
    return <EnvVarInput onComplete={() => setEnvVarsComplete(true)} />;
  }

  if (showForm) {
    if (formType === 'regular') {
      return (
        <AppProvider>
          <RegularBotForm
            onComplete={() => {
              setShowForm(false);
              setEditingConfig(null);
            }}
            editingConfig={editingConfig}
          />
        </AppProvider>
      );
    } else if (formType === 'multi') {
      return (
        <AppProvider>
          <MultiBotForm
            onComplete={() => {
              setShowForm(false);
              setEditingConfig(null);
            }}
            editingConfig={editingConfig}
          />
        </AppProvider>
      );
    }
  }

  if (showTransactionList) {
    return (
      <AppProvider>
        <TransactionList
          onBack={() => {
            setShowTransactionList(false);
            setSelectedOption(0);
          }}
          height={20}
          socket={socket.getSocket()}
        />
      </AppProvider>
    );
  }

  if (showConfigList) {
    return (
      <AppProvider>
        <ConfigList
          onBack={() => {
            setShowConfigList(false);
            setSelectedOption(0);
          }}
          botManager={botManager}
          socket={socket.getSocket()}
        />
      </AppProvider>
    );
  }

  return (
    <AppProvider>
      <Box flexDirection="column">
        <Text backgroundColor="black" color="cyan">
          {TRADE_BOT_ASCII}
        </Text>
        <Text bold color="white">
          Welcome to Trading Bot CLI
        </Text>

        <Box marginTop={1}>
          <Dashboard socket={socket.getSocket()} height={12} onRefresh={() => checkActiveBots()} />
        </Box>

        <MainMenu selectedOption={selectedOption} options={options} />

        {showConfirmStartAll && (
          <Box marginTop={2} flexDirection="column">
            <Text bold color="green">
              Confirm Start All Bots
            </Text>
            <Box marginTop={1}>
              <Text color="yellow">Are you sure you want to start all bots?</Text>
            </Box>
            <Box marginTop={1}>
              <Text color="cyan">Active bots: {startingProgress.total}</Text>
            </Box>
            {startingProgress.status !== 'idle' && (
              <Box marginTop={1} flexDirection="column">
                {startingProgress.status === 'starting' && (
                  <Box>
                    <Text color="yellow">
                      Progress: {startingProgress.current}/{startingProgress.total}
                    </Text>
                  </Box>
                )}
                <Text
                  color={
                    startingProgress.status === 'success'
                      ? 'green'
                      : startingProgress.status === 'error'
                      ? 'red'
                      : 'white'
                  }
                >
                  {startingProgress.message}
                </Text>
              </Box>
            )}
            <Box marginTop={1}>
              <Text color="blue">
                {startingProgress.status === 'idle'
                  ? 'Press Enter to confirm, Escape to cancel'
                  : startingProgress.status === 'success'
                  ? 'Press any key to continue'
                  : 'Press Escape to cancel'}
              </Text>
            </Box>
          </Box>
        )}

        {stoppingProgress.status !== 'idle' && (
          <Box marginTop={2} flexDirection="column">
            <Text bold color="red">
              Stop All Bots Progress
            </Text>
            {stoppingProgress.status === 'stopping' && (
              <Box marginTop={1}>
                <Text color="yellow">
                  Progress: {stoppingProgress.current}/{stoppingProgress.total}
                </Text>
              </Box>
            )}
            <Text
              color={
                stoppingProgress.status === 'success'
                  ? 'green'
                  : stoppingProgress.status === 'error'
                  ? 'red'
                  : 'white'
              }
            >
              {stoppingProgress.message}
            </Text>
          </Box>
        )}
      </Box>
    </AppProvider>
  );
};

const cli = () => {
  render(<App />);
};

export default cli;

================
File: cli/components/ConfigList.tsx
================
import React, {  useCallback } from 'react';
import { Box, Text, useInput } from 'ink';
import { shortenUUID } from '../../utils/helper.js';
import { ConfigListProps, SortField, SortDirection, FilterType, BotWithType, ConfigListState, BotStatus } from '../../core/types.js';
import { getSingleTokenData } from '../../services/tokenDataService.js';
import { useAppContext } from '../context/AppContext.js';
import { useApp } from 'ink';
import { createLogger } from '../../utils/logger.js';

const logger = createLogger('ConfigList');


export type BotData = {
  botId: string;
  status: string;
  inputMint: string;
  outputMint: string;
  currentPrice: number;
  targetTrade: number;
  difference: number;
  ratio: number;
  trades: number;
  tokenInPrice?: number;
  tokenOutPrice?: number;
  targetMint?: string;
  targetAmounts?: any[];
};

export type ConfigData = {
  regularBots: Array<{
    botId: string;
    initialInputToken: string;
    initialOutputToken: string;
    initialInputAmount: number;
    firstTradePrice: number | bigint;
    targetGainPercentage: number;
    stopLossPercentage?: number;
    status: string;
  }>;
  multiBots: Array<{
    botId: string;
    initialInputToken: string;
    initialInputAmount: number;
    targetGainPercentage: number;
    stopLossPercentage?: number;
    checkInterval?: number;
    status: string;
    targetAmounts: Array<{
      id: string;
      configId: string;
      tokenAddress: string;
      amount: number;
    }>;
  }>;
};

export const ConfigList: React.FC<ConfigListProps> = ({ onBack }) => {
  const { cliSocket } = useAppContext();
  const eventBus = cliSocket.getEventBus();
  const { exit } = useApp();
  const [configs, setConfigs] = React.useState<ConfigData>({ regularBots: [], multiBots: [] });
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const [sortField, setSortField] = React.useState<SortField>('type');
  const [sortDirection, setSortDirection] = React.useState<SortDirection>('asc');
  const [filter, setFilter] = React.useState<FilterType>('all');
  const [error, setError] = React.useState<string | null>(null);
  const [selectedConfig, setSelectedConfig] = React.useState<BotWithType | null>(null);
  const [selectedAction, setSelectedAction] = React.useState<'view' | 'delete' | 'edit'>('view');
  const [tokenNames, setTokenNames] = React.useState<Map<string, string>>(new Map());
  const [loading, setLoading] = React.useState(true);

  const fetchConfigs = useCallback(() => {
    try {
      logger.info('Fetching configs...');
      eventBus.emit('config:get', {});
    } catch (error) {
      logger.error('Error fetching configs:', error);
      setError('Failed to fetch configurations');
      setLoading(false);
    }
  }, [eventBus]);

  React.useEffect(() => {
    const handleConfigUpdate = (data: unknown) => {
      try {
        // Type guard to check if data is ConfigData
        if (
          typeof data === 'object' &&
          data !== null &&
          'regularBots' in data &&
          'multiBots' in data
        ) {
          logger.info('Received config update:', data);
          setConfigs(data as ConfigData);
          setError(null);
          setLoading(false);
        } else {
          throw new Error('Invalid config data received');
        }
      } catch (error) {
        logger.error('Failed to process configs:', error);
        setError('Failed to process configurations');
        setLoading(false);
      }
    };

    const handleError = (error: any) => {
      logger.error('Socket error:', error);
      setError(error.message || 'An error occurred');
      setLoading(false);
    };

    // Set up event bus listeners
    eventBus.on('configUpdate', handleConfigUpdate);
    eventBus.on('error', handleError);

    // Initial fetch
    fetchConfigs();

    // Cleanup function
    return () => {
      eventBus.off('configUpdate', handleConfigUpdate);
      eventBus.off('error', handleError);
    };
  }, [eventBus, fetchConfigs]);

  const fetchTokenNames = React.useCallback(async (mints: (string | undefined)[]) => {
    try {
      const names = new Map<string, string>();
      const validMints = mints.filter((mint): mint is string => typeof mint === 'string' && mint !== '');
      
      for (const mint of validMints) {
        try {
          const tokenData = await getSingleTokenData(mint);
          if (tokenData) {
            names.set(mint, tokenData.name || tokenData.symbol || mint);
          } else {
            names.set(mint, mint); // Fallback to mint address if not found in DB
          }
        } catch (error) {
          console.error(`Failed to fetch token data for ${mint}:`, error);
          names.set(mint, mint); // Fallback to mint address if fetch fails
        }
      }
      setTokenNames(prev => new Map([...prev, ...names]));
    } catch (error) {
      console.error('Failed to fetch token names:', error);
    }
  }, []);

  React.useEffect(() => {
    if (configs.regularBots.length > 0 || configs.multiBots.length > 0) {
      const allMints = new Set<string>();
      configs.regularBots.forEach(bot => {
        if (bot.initialInputToken) allMints.add(bot.initialInputToken);
        if (bot.initialOutputToken) allMints.add(bot.initialOutputToken);
      });
      configs.multiBots.forEach(bot => {
        if (bot.initialInputToken) allMints.add(bot.initialInputToken);
        if (bot.targetAmounts) {
          bot.targetAmounts.forEach((target: { tokenAddress: string }) => {
            if (target.tokenAddress) allMints.add(target.tokenAddress);
          });
        }
      });
      fetchTokenNames(Array.from(allMints));
    }
  }, [configs, fetchTokenNames]);

  React.useEffect(() => {
    if (selectedConfig) {
      const mints = new Set<string>();
      if (selectedConfig.initialInputToken) mints.add(selectedConfig.initialInputToken);
      if (selectedConfig.type === 'regular' && 'initialOutputToken' in selectedConfig) {
        mints.add(selectedConfig.initialOutputToken || '');
      }
      if (selectedConfig.type === 'multi' && 'targetAmounts' in selectedConfig) {
        selectedConfig.targetAmounts?.forEach(target => {
          if (target.tokenAddress) mints.add(target.tokenAddress);
        });
      }
      fetchTokenNames(Array.from(mints));
    }
  }, [selectedConfig, fetchTokenNames]);

  const allBots = React.useMemo(() => {
    const regular = configs.regularBots.map(bot => ({
      ...bot,
      type: 'regular' as const,
      amount: bot.initialInputAmount,
      targetGainPercentage: bot.targetGainPercentage,
      stopLossPercentage: bot.stopLossPercentage,
      firstTradePrice: typeof bot.firstTradePrice === 'number'
        ? BigInt(bot.firstTradePrice)
        : bot.firstTradePrice,
        status: bot.status as BotStatus,
    }));
    const multi = configs.multiBots.map(bot => ({
      ...bot,
      type: 'multi' as const,
      amount: bot.initialInputAmount,
      targetGainPercentage: bot.targetGainPercentage,
      stopLossPercentage: bot.stopLossPercentage,
      targetAmounts: bot.targetAmounts.map(target => ({
        ...target,
        tokenName: tokenNames.get(target.tokenAddress) || target.tokenAddress
      })),
      status: bot.status as BotStatus
    }));
    return [...regular, ...multi];
  }, [configs, tokenNames]);

  const filteredBots = React.useMemo(() => {
    let filtered = allBots;
    
    // Apply filter
    if (filter === 'active') {
      filtered = filtered.filter(bot => bot.status === 'running');
    } else if (filter === 'inactive') {
      filtered = filtered.filter(bot => bot.status === 'stopped');
    }

    // Apply sort
    return filtered.sort((a, b) => {
      let comparison = 0;
      if (sortField === 'type') {
        comparison = a.type.localeCompare(b.type);
      } else if (sortField === 'amount') {
        comparison = a.amount - b.amount;
      } else if (sortField === 'status') {
        comparison = a.status.localeCompare(b.status);
      }
      return sortDirection === 'asc' ? comparison : -comparison;
    });
  }, [allBots, sortField, sortDirection, filter]);

  useInput((input, key) => {
    if (key.escape) {
      if (selectedConfig) {
        setSelectedConfig(null);
        setSelectedAction('view');
      } else {
        onBack();
      }
      return;
    }

    if (selectedConfig) {
      if (key.upArrow) {
        const actions: Array<'view' | 'delete' | 'edit'> = ['view', 'delete', 'edit'];
        const currentIndex = actions.indexOf(selectedAction);
        const nextIndex = (currentIndex - 1 + actions.length) % actions.length;
        setSelectedAction(actions[nextIndex]);
      }
      if (key.downArrow) {
        const actions: Array<'view' | 'delete' | 'edit'> = ['view', 'delete', 'edit'];
        const currentIndex = actions.indexOf(selectedAction);
        const nextIndex = (currentIndex + 1) % actions.length;
        setSelectedAction(actions[nextIndex]);
      }
      if (key.return) {
        if (selectedAction === 'delete') {
          handleDelete();
        } else if (selectedAction === 'edit') {
          handleEdit();
        } else {
          setSelectedConfig(null);
          setSelectedAction('view');
        }
      }
      return;
    }

    if (key.upArrow) {
      setSelectedIndex(prev => (prev > 0 ? prev - 1 : filteredBots.length - 1));
    }
    if (key.downArrow) {
      setSelectedIndex(prev => (prev < filteredBots.length - 1 ? prev + 1 : 0));
    }
    if (key.return) {
      const selectedBot = filteredBots[selectedIndex];
      if (selectedBot) {
        setSelectedConfig(selectedBot);
      }
      return;
    }
    if (key.leftArrow) {
      const fields: SortField[] = ['type', 'amount', 'status'];
      const currentIndex = fields.indexOf(sortField);
      const nextIndex = (currentIndex - 1 + fields.length) % fields.length;
      setSortField(fields[nextIndex]);
    }
    if (key.rightArrow) {
      const fields: SortField[] = ['type', 'amount', 'status'];
      const currentIndex = fields.indexOf(sortField);
      const nextIndex = (currentIndex + 1) % fields.length;
      setSortField(fields[nextIndex]);
    }
    if (input.toLowerCase() === 'f') {
      const filters: FilterType[] = ['all', 'active', 'inactive'];
      const currentIndex = filters.indexOf(filter);
      const nextIndex = (currentIndex + 1) % filters.length;
      setFilter(filters[nextIndex]);
    }
  });

  const handleDelete = async () => {
    if (!selectedConfig) return;
    
    try {
      // First stop the bot if it's running
      await cliSocket.stopBot(selectedConfig.botId);
      
      // Then delete the configuration
      await cliSocket.deleteConfig(
        selectedConfig.botId,
        selectedConfig.type
      );
      
      // Clear selection and refresh the list
      setSelectedConfig(null);
      setSelectedAction('view');
      fetchConfigs();
    } catch (error) {
      console.error('Failed to delete bot:', error);
      setError('Failed to delete configuration');
    }
  };

  const handleEdit = () => {
    if (!selectedConfig) return;
    // Convert BigInt values to strings before sending
    const configToSend = {
      ...selectedConfig,
      targetGainPercentage: selectedConfig.targetGainPercentage?.toString(),
      stopLossPercentage: selectedConfig.stopLossPercentage?.toString(),
      firstTradePrice: selectedConfig.firstTradePrice?.toString()
    };
    
    // Emit the edit event first
    eventBus.emit('config:edit', {
      type: selectedConfig.type,
      config: configToSend
    });

    // Then go back to main menu
    exit();
  };

  const renderBotInfo = (bot: BotWithType) => {
    const inputTokenName = tokenNames.get(bot.initialInputToken) || bot.initialInputToken;
    const outputTokenName = bot.initialOutputToken ? (tokenNames.get(bot.initialOutputToken) || bot.initialOutputToken) : '';
    const initialInputAmount = bot.initialInputAmount || 0;
    const firstTradePrice = bot.firstTradePrice || 0;
    const shortId = shortenUUID(bot.botId);

    return (
      <Box flexDirection="column">
        <Text>ID: {shortId}</Text>
        <Text>Type: {bot.type === 'regular' ? 'Regular Bot' : 'Multi Bot'}</Text>
        <Text>Status: {bot.status}</Text>
        <Text>Input Token: {inputTokenName}</Text>
        {bot.type === 'regular' && <Text>Output Token: {outputTokenName}</Text>}
        {bot.type === 'regular' &&   <Text>Initial Input Amount: {initialInputAmount}</Text>}
        {bot.type === 'regular' && <Text>First Trade Price: {firstTradePrice}</Text>}
        <Text>
         Target Gain (%): {bot.targetGainPercentage !== undefined
            ? BigInt(bot.targetGainPercentage).toString()
            : 'N/A'}
        </Text>
        {bot.type === 'multi' && bot.targetAmounts && (
<Box flexDirection="column">
            <Text>Target Amounts:</Text>
            {bot.targetAmounts.map((target, index) => (
              <Text key={index}>
                - {tokenNames.get(target.tokenAddress) || target.tokenAddress}: {target.amount}
              </Text>
            ))}
          </Box>
        )}
      </Box>
    );
  };

  if (loading) {
    return (
      <Box>
        <Text>Loading configurations...</Text>
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Text color="red">{error}</Text>
      </Box>
    );
  }

  if (selectedConfig) {
    return (
      <Box flexDirection="column">
        <Text bold color="cyan">Configuration Details</Text>
        <Box marginTop={1} flexDirection="column">
          {renderBotInfo(selectedConfig)}
        </Box>
        <Box marginTop={1} flexDirection="column">
          <Text color="yellow">Actions:</Text>
          <Box marginLeft={1} flexDirection="column">
            <Text color={selectedAction === 'delete' ? 'cyan' : 'white'}>
              {selectedAction === 'delete' ? '> ' : '  '}Delete Configuration
            </Text>
            <Text color={selectedAction === 'edit' ? 'cyan' : 'white'}>
              {selectedAction === 'edit' ? '> ' : '  '}Edit Configuration
            </Text>
            <Text color={selectedAction === 'view' ? 'cyan' : 'white'}>
              {selectedAction === 'view' ? '> ' : '  '}Back to List
            </Text>
          </Box>
        </Box>
        <Box marginTop={1}>
          <Text color="blue">
            ↑↓ to select action, Enter to confirm, Escape to go back
          </Text>
        </Box>
      </Box>
    );
  }

  
  return (
    <Box flexDirection="column">
      <Text bold>All Configurations</Text>
      <Text>Sort by: {sortField} ({sortDirection}) - Filter: {filter}</Text>
      <Box marginTop={1} flexDirection="column">
          <Box flexDirection="column">
            {allBots.map((bot, index) => (
              <Box key={`active-${bot.botId}`} marginLeft={2}>
                <Text
                  color={selectedIndex === index ? 'cyan' : 'white'}
                >
                  {bot.type} - {(bot.initialInputToken)} {bot.amount}
                </Text>
              </Box>
            ))}
          </Box>        
        {allBots.length === 0 && (
          <Text>No configurations found</Text>
        )}
      </Box>
      <Box marginTop={1}>
        <Text color="blue">
          ↑↓ to select, Enter to view details
          {'\n'}
          ←→ to change sort, 'f' to change filter, Escape to go back
        </Text>
      </Box>
    </Box>
  );
};

export default ConfigList;

================
File: cli/components/Dashboard.tsx
================
// cli/components/Dashboard.tsx
import React from 'react';
import { Box, Text } from 'ink';
import { ConfigService } from '../../services/configService.js';
import { shortenUUID } from '../../utils/helper.js';
import { DashboardProps } from '../../core/types.js';

interface BotMetrics {
  botId: string;
  targetMint?: string;
  difference: number;
  currentPrice: number;
  ratio: number;
  inputToken: string;
  outputToken: string;
  trades: number;
  type: 'regular' | 'multi';
}

const Dashboard: React.FC<DashboardProps> = ({ socket, height = 20, onRefresh }) => {
  const [activeBotIds, setActiveBotIds] = React.useState<Set<string>>(new Set());
  const [metrics, setMetrics] = React.useState<Map<string, Map<string, BotMetrics>>>(new Map());
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  // Fetch active bot IDs and trade logs
  const fetchData = React.useCallback(async () => {
    try {
      setLoading(true);
      const configService = new ConfigService();
      const allConfigs = await configService.getAllConfigs();
      
      // Get active bot IDs
      const activeIds = new Set<string>();
      allConfigs.regularBots.forEach(bot => {
        if (bot.status === 'running') {
          activeIds.add(bot.botId.toString());
        }
      });
      allConfigs.multiBots.forEach(bot => {
        if (bot.status === 'running') {
          activeIds.add(bot.botId.toString());
        }
      });
      setActiveBotIds(activeIds);

      setError(null);
    } catch (err) {
      setError('Failed to fetch dashboard data');
      console.error('Error fetching dashboard data:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  // Initial data fetch
  React.useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Set up refresh interval
  React.useEffect(() => {
    const interval = setInterval(() => {
      onRefresh();
    }, 10000); // Refresh every 10 seconds instead of 5

    return () => clearInterval(interval);
  }, [onRefresh]);

  // Handle bot:difference events
  React.useEffect(() => {
    const handleDifference = (data: any) => {
      setMetrics(prev => {
        const newMetrics = new Map(prev);
        const botMetrics = newMetrics.get(data.botId) || new Map();
        
        // Check if this is a multi-bot by looking for targetAmounts in the data
        const isMultiBot = 'targetAmounts' in data;
        const key = isMultiBot ? data.targetMint : data.outputMint;
        
        // For multi-bots, ensure we have the correct type and target mint
        if (isMultiBot && !data.targetMint) {
          console.warn('Multi-bot data missing targetMint:', data);
          return prev;
        }

        // Get token names for display
        const inputToken = data.inputMint || 'N/A';
        const outputToken = data.outputMint || 'N/A';

        botMetrics.set(key, {
          botId: data.botId,
          targetMint: isMultiBot ? data.targetMint : undefined,
          difference: Number(data.difference) || 0,
          currentPrice: Number(data.currentPrice) || 0,
          ratio: Number(data.ratio) || 0,
          inputToken,
          outputToken,
          trades: Number(data.trades) || 0,
          type: isMultiBot ? 'multi' : 'regular'
        });
        
        newMetrics.set(data.botId, botMetrics);
        return newMetrics;
      });
    };

    socket.on('bot:difference', handleDifference);
    return () => {
      socket.off('bot:difference', handleDifference);
    };
  }, [socket]);

  if (loading) {
    return (
      <Box>
        <Text>Loading dashboard data...</Text>
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Text color="red">{error}</Text>
      </Box>
    );
  }

  // Add message when no metrics are available but bots are active
  if (activeBotIds.size > 0 && (!metrics.size || Array.from(metrics.values()).every(m => m.size === 0))) {
    return (
      <Box flexDirection="column">
        <Text bold>Active Bots Dashboard</Text>
        <Box marginTop={1}>
          <Text color="yellow">Please wait 20-30 seconds for the table to populate with bot data...</Text>
        </Box>
      </Box>
    );
  }

  return (
    <Box flexDirection="column" height={height}>
      <Text bold>Active Bots Dashboard</Text>
      <Box marginTop={1}>
        <Text>
          {'Bot ID'.padEnd(12)} {'Diff %'.padEnd(10)} {'Current'.padEnd(10)} {'Input'.padEnd(12)} {'Output'.padEnd(18)} {'Trades'.padEnd(8)}
        </Text>
      </Box>
      <Box marginTop={1} flexDirection="column">
        {Array.from(metrics.entries()).map(([botId, targetMetrics]) => (
          <Box key={botId} flexDirection="column">
            {Array.from(targetMetrics.values()).map((metric, index) => (
              <Text color="cyan" key={`${botId}-${metric.targetMint || metric.outputToken || index}`}>
                {shortenUUID(botId).padEnd(12)} 
                {metric.difference.toFixed(2).padEnd(10)} 
                {metric.currentPrice.toFixed(2).padEnd(12)} 
                {(metric.inputToken || 'N/A').padEnd(15)} 
                {(metric.outputToken || 'N/A').padEnd(21)} 
                {metric.trades.toString().padEnd(8)}
              </Text>
            ))}
          </Box>
        ))}
      </Box>
    </Box>
  );
};

export default Dashboard;

================
File: cli/components/EnvVarInput.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import { checkVariables } from '../../config/index.js';
import { writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { createLogger } from '../../utils/logger.js';

const logger = createLogger('EnvVarInput');

interface EnvVarInputProps {
  onComplete: () => void;
}

export const EnvVarInput: React.FC<EnvVarInputProps> = ({ onComplete }) => {
  const [missingVars, setMissingVars] = React.useState<string[]>([]);
  const [currentVarIndex, setCurrentVarIndex] = React.useState(0);
  const [inputValue, setInputValue] = React.useState('');

  React.useEffect(() => {
    const variableCheck = checkVariables();
    if (!variableCheck.success) {
      setMissingVars(variableCheck.missingVars);
    } else {
      onComplete();
    }
  }, [onComplete]);

  const saveEnvVariable = (key: string, value: string) => {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const envPath = join(__dirname, '../../../.env');
    
    try {
      let envContent = '';
      try {
        envContent = readFileSync(envPath, 'utf8');
      } catch (error) {
        // File doesn't exist, that's okay
        logger.info('Creating new .env file');
      }

      // Check if variable already exists
      const lines = envContent.split('\n');
      const existingIndex = lines.findIndex(line => line.startsWith(`${key}=`));
      
      if (existingIndex !== -1) {
        lines[existingIndex] = `${key}=${value}`;
      } else {
        lines.push(`${key}=${value}`);
      }

      writeFileSync(envPath, lines.join('\n'));
      logger.info(`Saved environment variable: ${key}`);
      return true;
    } catch (error) {
      logger.error('Failed to save environment variable:', error);
      return false;
    }
  };

  useInput((input, key) => {
    if (currentVarIndex >= missingVars.length) {
      onComplete();
      return;
    }

    if (key.return) {
      const currentVar = missingVars[currentVarIndex];
      if (saveEnvVariable(currentVar, inputValue)) {
        setInputValue('');
        setCurrentVarIndex(prev => prev + 1);
      }
    } else if (key.backspace || key.delete) {
      setInputValue(prev => prev.slice(0, -1));
    } else {
      setInputValue(prev => prev + input);
    }
  });

  if (currentVarIndex >= missingVars.length) {
    return null;
  }

  return (
    <Box flexDirection="column">
      <Text>Please enter the value for {missingVars[currentVarIndex]}:</Text>
      <Text>Current input: {inputValue}</Text>
    </Box>
  );
};

================
File: cli/components/MainMenu.tsx
================
import React from 'react';
import { Box, Text } from 'ink';

interface MainMenuProps {
  selectedOption: number;
  options: string[];
}

export const MainMenu: React.FC<MainMenuProps> = ({ selectedOption, options }) => {
  const getOptionColor = (option: string, isSelected: boolean) => {
    if (isSelected) return 'magentaBright'; // Selected option is bright magenta
    
    if (option === 'Exit') return 'magentaBright';
    if (option === 'Stop All Bots') return 'magentaBright';
    if (option === 'Start All Bots') return 'magentaBright';
    if (option === 'View All Configs') return 'magentaBright';
    if (option === 'Add New Config' || option === 'Add Multi Config') return 'magentaBright';
    if (option === 'View Transactions') return 'magentaBright';
    
    return 'whiteBright'; // Default color for better readability
  };

  return (
    <Box flexDirection="column">
      <Box marginTop={2}>
        <Text color="whiteBright">Use ↑↓ arrows to select an option and Enter to confirm</Text>
      </Box>
      <Box marginTop={1} flexDirection="column">
        {options.map((option, index) => {
          const isSelected = index === selectedOption;
          const color = getOptionColor(option, isSelected);
          
          return (
            <Text key={option} color={color}>
              {isSelected ? '> ' : '  '}{option}
            </Text>
          );
        })}
      </Box>
    </Box>
  );
};

================
File: cli/components/TokenSelector.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import { getCachedTokens, type Token } from '../../utils/tokenCache.js';
import { TokenSelectorProps } from '../../core/types.js';
const DISPLAY_LIMIT = 10;

const TokenSelector: React.FC<TokenSelectorProps> = ({ onSelect, onCancel }) => {
  const [searchTerm, setSearchTerm] = React.useState('');
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const [tokens, setTokens] = React.useState<Token[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [displayOffset, setDisplayOffset] = React.useState(0);

  React.useEffect(() => {
    const fetchTokens = async () => {
      try {
        setLoading(true);
        const cachedTokens = await getCachedTokens();
        // Sort tokens by symbol for better usability
        const sortedTokens = cachedTokens.sort((a, b) => a.symbol.localeCompare(b.symbol));
        setTokens(sortedTokens);
        setError(null);
      } catch (err) {
        setError('Failed to load tokens. Please try again.');
        console.error('Error loading tokens:', err);
      } finally {
        setLoading(false);
      }
    };
    fetchTokens();
  }, []);

  const filteredTokens = React.useMemo(() => {
    if (!searchTerm) {
      return tokens;
    }
    const searchLower = searchTerm.toLowerCase();
    return tokens.filter(token => 
      token.symbol.toLowerCase().includes(searchLower) ||
      token.name.toLowerCase().includes(searchLower) ||
      token.address.toLowerCase().includes(searchLower)
    );
  }, [tokens, searchTerm]);

  const displayedTokens = React.useMemo(() => {
    return filteredTokens.slice(displayOffset, displayOffset + DISPLAY_LIMIT);
  }, [filteredTokens, displayOffset]);

  const hasMore = displayOffset + DISPLAY_LIMIT < filteredTokens.length;
  const hasPrevious = displayOffset > 0;

  useInput((input, key) => {
    if (key.escape) {
      onCancel();
      return;
    }

    if (key.return) {
      if (displayedTokens.length > 0) {
        onSelect(displayedTokens[selectedIndex]);
      }
      return;
    }

    if (key.upArrow) {
      if (selectedIndex > 0) {
        setSelectedIndex(prev => prev - 1);
      } else if (hasPrevious) {
        setDisplayOffset(prev => prev - DISPLAY_LIMIT);
        setSelectedIndex(DISPLAY_LIMIT - 1);
      }
    }

    if (key.downArrow) {
      if (selectedIndex < displayedTokens.length - 1) {
        setSelectedIndex(prev => prev + 1);
      } else if (hasMore) {
        setDisplayOffset(prev => prev + DISPLAY_LIMIT);
        setSelectedIndex(0);
      }
    }

    if (key.backspace) {
      setSearchTerm(prev => prev.slice(0, -1));
      setSelectedIndex(0);
      setDisplayOffset(0);
    } else if (input) {
      setSearchTerm(prev => prev + input);
      setSelectedIndex(0);
      setDisplayOffset(0);
    }
  });

  if (loading) {
    return (
      <Box>
        <Text>Loading tokens...</Text>
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Text color="red">{error}</Text>
      </Box>
    );
  }

  return (
    <Box flexDirection="column">
      <Text>Search Token (type to search): {searchTerm}</Text>
      <Box marginTop={1} flexDirection="column">
        {displayedTokens.map((token, index) => (
          <Box key={token.address}>
            <Text color={index === selectedIndex ? 'green' : 'white'}>
              {index === selectedIndex ? '> ' : '  '}
              <Text bold>{token.symbol.padEnd(8)}</Text>
              <Text>{token.name.padEnd(30)}</Text>
              <Text color={index === selectedIndex ? 'green' : 'gray'} dimColor>
                {token.address}
              </Text>
            </Text>
          </Box>
        ))}
        {hasMore && (
          <Box marginTop={1}>
            <Text color="gray">... {filteredTokens.length - (displayOffset + DISPLAY_LIMIT)} more tokens</Text>
          </Box>
        )}
      </Box>
      <Box marginTop={1}>
        <Text>
          {filteredTokens.length > 0 ? 
            `Showing ${displayOffset + 1}-${Math.min(displayOffset + DISPLAY_LIMIT, filteredTokens.length)} of ${filteredTokens.length} tokens` :
            'No tokens found'
          }
        </Text>
      </Box>
      <Box marginTop={1}>
        <Text>↑↓ to select, Enter to confirm, Escape to cancel</Text>
      </Box>
    </Box>
  );
};

export default TokenSelector;

================
File: cli/components/TransactionList.tsx
================
import React from 'react';
import { Box, Text, useApp, useInput } from 'ink';
import { Transaction } from '@prisma/client';
import { shortenUUID } from '../../utils/helper.js';
import { useAppContext } from '../context/AppContext.js';
import { Socket } from 'socket.io-client';
import { createLogger } from '../../utils/logger.js';

const logger = createLogger('TransactionList');

interface TransactionListProps {
  height?: number;
  onBack: () => void;
  socket?: Socket
}

const TransactionList: React.FC<TransactionListProps> = ({ height = 20, onBack }) => {
  const { cliSocket } = useAppContext();
  const eventBus = cliSocket.getEventBus();
  const socket = cliSocket.getSocket();
  const [transactions, setTransactions] = React.useState<Transaction[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    setLoading(true);

    // Handler for transaction:get event
    const handleTransactionGet = (data: { transactions: Transaction[] }) => {
      if (data.transactions) {
        setTransactions(data.transactions);
        setError(null);
      } else {
        setError('No transactions data received');
      }
      setLoading(false);
    };

    // Handler for live transaction updates
    const handleTransactionUpdate = (data: { transactions: Transaction[] }) => {
      if (data.transactions) {
        setTransactions(data.transactions);
        setLoading(false);
      }
    };

    // Listen for events
    socket.on('transaction:get', handleTransactionGet);
    socket.on('transactionUpdate', handleTransactionUpdate);

    // Request transactions
    socket.emit('transaction:get', {});

    // Cleanup listeners on unmount
    return () => {
      socket.off('transaction:get', handleTransactionGet);
      socket.off('transactionUpdate', handleTransactionUpdate);
    };
  }, [socket]);

  useInput((input, key) => {
    if (key.escape) {
      onBack();
    }
  });

  if (error) {
    return (
      <Box>
        <Text color="red">{error}</Text>
      </Box>
    );
  }

  return (
    <Box flexDirection="column" height={height}>
      <Text bold>Transaction History</Text>
      {/* Table Header */}
      <Box marginTop={1}>
        <Box width={8}><Text bold>Bot ID</Text></Box>
        <Box width={16}><Text bold>Date</Text></Box>
        <Box width={25}><Text bold>Input</Text></Box>
        <Box width={25}><Text bold>Output</Text></Box>
        <Box width={10}><Text bold>Value</Text></Box>
        <Box width={8}><Text bold>TX ID</Text></Box>
      </Box>
      {/* Table Content */}
      <Box marginTop={1} flexDirection="column">
        {loading ? (
          <Box><Text>Loading transactions...</Text></Box>
        ) : transactions.length === 0 ? (
          <Box><Text>No transactions found</Text></Box>
        ) : (
          transactions.map((tx) => (
            <Box key={tx.id}>
              <Box width={8}><Text>{shortenUUID(tx.botId)}</Text></Box>
              <Box width={16}>
                <Text>{new Date(tx.date).toLocaleString('en-US', { 
                  month: 'numeric',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  hour12: true
                })}</Text>
              </Box>
              <Box width={25}>
                <Text>{`${tx.tokenInAmount.toFixed(2)} ${shortenUUID(tx.tokenIn)}`}</Text>
              </Box>
              <Box width={25}>
                <Text>{`${tx.tokenOutAmount.toFixed(2)} ${shortenUUID(tx.tokenOut)}`}</Text>
              </Box>
              <Box width={10}>
                <Text>{`$${tx.totalValueUSD.toFixed(2)}`}</Text>
              </Box>
              <Box width={8}>
                <Text>{shortenUUID(tx.txid)}</Text>
              </Box>
            </Box>
          ))
        )}
      </Box>
      <Box marginTop={1}>
        <Text color="blue">Press Escape to go back</Text>
      </Box>
    </Box>
  );
};

export default TransactionList;

================
File: cli/context/AppContext.tsx
================
import React, { createContext, useContext } from 'react';
import { CLISocket } from '../services/CLISocket.js';
import { BotManager } from '../../core/types.js';
import { DefaultBotManager } from '../../core/botManager.js';

export interface AppContextType {
  cliSocket: CLISocket;
  botManager: BotManager;
}

const AppContext = createContext<AppContextType | null>(null);

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
};

interface AppProviderProps {
  children: React.ReactNode;
}

export const AppProvider: React.FC<AppProviderProps> = ({ children }) => {
  const botManager = new DefaultBotManager();
  const cliSocket = new CLISocket(botManager);

  return (
    <AppContext.Provider value={{ cliSocket, botManager }}>
      {children}
    </AppContext.Provider>
  );
};

================
File: cli/forms/MultiBotForm.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import TokenSelector from '../components/TokenSelector.js';
import { v4 as uuidv4 } from 'uuid';
import { MultiBotFormProps } from '../../core/types.js';
import { useAppContext } from '../context/AppContext.js';
import { MultiBotService } from '../../services/multiBotService.js';

interface TargetAmount {
  token: { name: string; symbol: string };
  amount: string;
}

export const MultiBotForm = ({ onComplete, editingConfig }: MultiBotFormProps) => {
  const { botManager } = useAppContext();
  const [currentField, setCurrentField] = React.useState(0);
  const [inputValue, setInputValue] = React.useState('');
  const [error, setError] = React.useState('');
  const [showTokenSelector, setShowTokenSelector] = React.useState(false);
  const [currentTargetAmount, setCurrentTargetAmount] = React.useState<TargetAmount>({
    token: { name: '', symbol: '' },
    amount: ''
  });

  const [formData, setFormData] = React.useState({
    initialInputToken: { address: '', name: '', symbol: '' },
    botId: '',
    initialInputAmount: '',
    targetGainPercentage: '',
    stopLossPercentage: '',
    checkInterval: '',
    targetAmounts: {} as Record<string, number>
  });

  const [targetAmounts, setTargetAmounts] = React.useState<TargetAmount[]>([]);

  const fields = [
    { name: 'initialInputToken', label: 'Initial Input Token', type: 'token' },
    { name: 'initialInputAmount', label: 'Initial Input Amount', type: 'number' },
    { name: 'targetGainPercentage', label: 'Target Gain Percentage', type: 'number' },
    { name: 'stopLossPercentage', label: 'Stop Loss Percentage (optional)', type: 'number' },
    { name: 'checkInterval', label: 'Check Interval (seconds, optional)', type: 'number' }
  ];

  const handleTokenSelect = (token: { address: string; symbol: string; name: string }) => {
    if (currentField === fields.length) {
      setCurrentTargetAmount(prev => ({
        ...prev,
        token: { name: token.name, symbol: token.symbol }
      }));
    } else {
      setFormData(prev => ({ 
        ...prev, 
        initialInputToken: { 
          address: token.address,
          name: token.name,
          symbol: token.symbol
        } 
      }));
    }
    setShowTokenSelector(false);
    setInputValue('');
  };

  const handleTokenCancel = () => {
    setShowTokenSelector(false);
    setInputValue('');
  };

  const handleSubmit = async () => {
    try {
      const targetAmountsRecord: Record<string, number> = {};
      targetAmounts.forEach(target => {
        targetAmountsRecord[target.token.name] = Number(target.amount);
      });

      const botId = uuidv4();
      const config = {
        botId,
        initialInputToken: formData.initialInputToken.name,
        initialInputAmount: Number(formData.initialInputAmount),
        targetGainPercentage: Number(formData.targetGainPercentage),
        stopLossPercentage: formData.stopLossPercentage ? Number(formData.stopLossPercentage) : undefined,
        checkInterval: formData.checkInterval ? Number(formData.checkInterval) : undefined,
        targetAmounts: targetAmountsRecord
      };

      if (editingConfig) {
        // Update existing config
        await botManager.updateBotConfig(config.botId, config);
      } else {
        // Create new config without starting the bot
        const multiBotService = new MultiBotService();
        await multiBotService.addConfig(config);
      }

      onComplete();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save configuration');
    }
  };

  useInput((input, key) => {
    if (showTokenSelector) return;

    if (key.escape) {
      onComplete();
      return;
    }

    if (input.toLowerCase() === 's') {
      if (targetAmounts.length === 0) {
        setError('At least one target amount is required');
        return;
      }
      handleSubmit();
      return;
    }

    if (key.upArrow) {
      setCurrentField(prev => (prev > 0 ? prev - 1 : prev));
      if (currentField === fields.length) {
        setInputValue(currentTargetAmount.amount);
      } else {
        const field = fields[currentField - 1];
        if (field && field.type === 'token') {
          setInputValue(formData.initialInputToken.symbol || '');
        } else if (field) {
          setInputValue(formData[field.name as keyof typeof formData] as string || '');
        }
      }
    } else if (key.downArrow) {
      setCurrentField(prev => (prev < fields.length ? prev + 1 : prev));
      if (currentField === fields.length) {
        setInputValue(currentTargetAmount.amount);
      } else {
        const field = fields[currentField + 1];
        if (field && field.type === 'token') {
          setInputValue(formData.initialInputToken.symbol || '');
        } else if (field) {
          setInputValue(formData[field.name as keyof typeof formData] as string || '');
        }
      }
    } else if (key.return) {
      if (currentField === fields.length) {
        if (!currentTargetAmount.token.name) {
          setShowTokenSelector(true);
          return;
        }

        if (!currentTargetAmount.amount) {
          setError('Please enter a target amount');
          return;
        }

        setTargetAmounts(prev => [...prev, currentTargetAmount]);
        setCurrentTargetAmount({
          token: { name: '', symbol: '' },
          amount: ''
        });
        setInputValue('');
      } else {
        const field = fields[currentField];
        if (field && field.type === 'token') {
          setShowTokenSelector(true);
        } else if (field) {
          setFormData(prev => ({ ...prev, [field.name]: inputValue }));
          setInputValue('');
        }
      }
    } else {
      if (currentField === fields.length) {
        if (key.backspace) {
          setCurrentTargetAmount(prev => ({
            ...prev,
            amount: prev.amount.slice(0, -1)
          }));
          setInputValue(prev => prev.slice(0, -1));
        } else {
          setCurrentTargetAmount(prev => ({
            ...prev,
            amount: prev.amount + input
          }));
          setInputValue(prev => prev + input);
        }
      } else {
        if (key.backspace) {
          setInputValue(prev => prev.slice(0, -1));
        } else {
          setInputValue(prev => prev + input);
        }
      }
    }
  });

  // Initialize form with editing config if provided
  React.useEffect(() => {
    if (editingConfig) {
      setFormData({
        initialInputToken: editingConfig.initialInputToken || { address: '', name: '', symbol: '' },
        botId: editingConfig.botId || '',
        initialInputAmount: editingConfig.amount?.toString() || '',
        targetGainPercentage: editingConfig.targetGainPercentage?.toString() || '',
        stopLossPercentage: editingConfig.stopLossPercentage?.toString() || '',
        checkInterval: editingConfig.checkInterval?.toString() || '',
        targetAmounts: {} // Initialize with empty object, will be populated from targetAmounts state
      });

      // Convert target amounts to the correct format
      if (editingConfig.targetAmounts) {
        const targetAmountsArray = Object.entries(editingConfig.targetAmounts).map(([tokenName, amount]) => ({
          token: { name: tokenName, symbol: tokenName },
          amount: (amount as number).toString()
        }));
        setTargetAmounts(targetAmountsArray);
      }
    }
  }, [editingConfig]);

  if (showTokenSelector) {
    return <TokenSelector onSelect={handleTokenSelect} onCancel={handleTokenCancel} />;
  }

  return (
    <Box flexDirection="column">
      <Text bold color="cyan">Multi Bot Configuration</Text>
      
      {/* Initial Configuration */}
      {fields.map((field, index) => (
        <Box key={field.name} marginTop={1}>
          <Text color={currentField === index ? 'yellow' : 'white'}>
            {field.label}: {
              field.type === 'token' 
                ? formData.initialInputToken.symbol || 'Select token'
                : currentField === index 
                  ? inputValue 
                  : (formData[field.name as keyof typeof formData] as string) || ''
            }
          </Text>
        </Box>
      ))}

      {/* Target Amounts */}
      <Box marginTop={1} flexDirection="column">
        <Text color="cyan">Target Amounts:</Text>
        {targetAmounts.map((target, index) => (
          <Text key={index} color="green">
            {target.token.symbol}: {target.amount}
          </Text>
        ))}
        <Box marginTop={1}>
          <Text color={currentField === fields.length ? 'yellow' : 'white'}>
            Add Target: {currentTargetAmount.token.symbol || 'Select token'} {currentTargetAmount.amount ? `Amount: ${currentTargetAmount.amount}` : ''}
          </Text>
        </Box>
      </Box>

      {/* Instructions */}
      <Box marginTop={2}>
        <Text color="yellow">Instructions:</Text>
        <Box marginLeft={2} flexDirection="column">
          <Text>• Use ↑↓ arrow keys to navigate between fields</Text>
          <Text>• Press Enter to:</Text>
          <Box marginLeft={2}>
            <Text>  - Select a token when on token fields</Text>
            <Text>  - Add a target amount when on target field</Text>
          </Box>
          <Text>• Press 'S' to save configuration</Text>
          <Text>• Press Escape to exit</Text>
        </Box>
      </Box>

      {error && (
        <Box marginTop={1}>
          <Text color="red">{error}</Text>
        </Box>
      )}
    </Box>
  );
};

export default MultiBotForm;

================
File: cli/forms/RegularBotForm.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import TokenSelector from '../components/TokenSelector.js';
import { RegularBotFormProps } from '../../core/types.js';
import { useAppContext } from '../context/AppContext.js';
import { RegularBotService } from '../../services/regularBotService.js';

export const RegularBotForm: React.FC<RegularBotFormProps> = ({ onComplete, editingConfig }) => {
  const { botManager, cliSocket } = useAppContext();
  const [currentField, setCurrentField] = React.useState(0);
  const [inputValue, setInputValue] = React.useState('');
  const [formData, setFormData] = React.useState({
    initialInputToken: '',
    initialOutputToken: '',
    initialInputAmount: '',
    firstTradePrice: '',
    targetGainPercentage: '',
    stopLossPercentage: ''
  });
  const [showTokenSelector, setShowTokenSelector] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);

  // Initialize form with editing config if provided
  React.useEffect(() => {
    if (editingConfig) {
      setFormData({
        initialInputToken: editingConfig.initialInputToken,
        initialOutputToken: editingConfig.initialOutputToken || '',
        initialInputAmount: editingConfig.amount.toString(),
        firstTradePrice: editingConfig.firstTradePrice?.toString() || '',
        targetGainPercentage: editingConfig.targetGainPercentage?.toString() || '',
        stopLossPercentage: editingConfig.stopLossPercentage?.toString() || ''
      });
    }
  }, [editingConfig]);

  const fields = [
    { name: 'initialInputToken', label: 'Input Token', type: 'token' },
    { name: 'initialOutputToken', label: 'Output Token', type: 'token' },
    { name: 'initialInputAmount', label: 'Input Amount', type: 'number' },
    { name: 'firstTradePrice', label: 'First Trade Price', type: 'number' },
    { name: 'targetGainPercentage', label: 'Target Gain %', type: 'number' },
    { name: 'stopLossPercentage', label: 'Stop Loss % (Optional)', type: 'number' }
  ];

  const handleTokenSelect = (token: { address: string; symbol: string; name: string }) => {
    setFormData(prev => ({
      ...prev,
      [fields[currentField].name]: token.name
    }));
    setShowTokenSelector(false);
    setCurrentField(prev => prev + 1);
  };

  const handleTokenCancel = () => {
    setShowTokenSelector(false);
  };

  useInput((input, key) => {
    if (showTokenSelector) return;

    if (key.escape) {
      onComplete();
      return;
    }

    if (key.upArrow) {
      setCurrentField(prev => (prev > 0 ? prev - 1 : prev));
      const prevField = fields[currentField - 1];
      if (prevField) {
        setInputValue(formData[prevField.name as keyof typeof formData] || '');
      }
      return;
    }

    if (key.downArrow) {
      setCurrentField(prev => (prev < fields.length - 1 ? prev + 1 : prev));
      const nextField = fields[currentField + 1];
      if (nextField) {
        setInputValue(formData[nextField.name as keyof typeof formData] || '');
      }
      return;
    }

    if (key.return) {
      const field = fields[currentField];
      
      if (field.type === 'token') {
        setShowTokenSelector(true);
        return;
      }

      if (currentField < fields.length - 1) {
        if (field.type === 'number' && isNaN(Number(inputValue))) {
          setError('Please enter a valid number');
          return;
        }
        if (!inputValue && field.name !== 'stopLossPercentage') {
          setError('This field is required');
          return;
        }

        setFormData(prev => ({
          ...prev,
          [field.name]: inputValue
        }));

        setCurrentField(prev => prev + 1);
        const nextField = fields[currentField + 1];
        setInputValue(formData[nextField.name as keyof typeof formData] || '');
        setError('');
      } else {
        // On last field, just save the value but don't submit
        if (field.type === 'number' && isNaN(Number(inputValue))) {
          setError('Please enter a valid number');
          return;
        }
        if (!inputValue && field.name !== 'stopLossPercentage') {
          setError('This field is required');
          return;
        }

        setFormData(prev => ({
          ...prev,
          [field.name]: inputValue
        }));
        setInputValue('');
        setError('');
      }
    } else if (input.toLowerCase() === 's' && currentField === fields.length - 1) {
      // Only allow saving if we're on the last field and all fields are filled
      const allFieldsFilled = fields.every(field => 
        field.name === 'stopLossPercentage' || formData[field.name as keyof typeof formData]
      );
      
      if (allFieldsFilled) {
        handleSubmit();
      } else {
        setError('Please fill in all required fields');
      }
    } else if (key.backspace) {
      setInputValue(prev => prev.slice(0, -1));
    } else if (input) {
      setInputValue(prev => prev + input);
    }
  });

  const handleSubmit = async () => {
    try {
      const config = {
        botId: editingConfig?.botId || crypto.randomUUID(),
        initialInputToken: formData.initialInputToken,
        initialOutputToken: formData.initialOutputToken,
        initialInputAmount: parseFloat(formData.initialInputAmount),
        firstTradePrice: parseFloat(formData.firstTradePrice),
        targetGainPercentage: parseFloat(formData.targetGainPercentage),
        stopLossPercentage: formData.stopLossPercentage ? 
          (Math.floor(parseFloat(formData.stopLossPercentage) * 100)) : 
          undefined
      };

      if (editingConfig) {
        // Update existing config
        await botManager.updateBotConfig(config.botId, config);
      } else {
        // Create new config without starting the bot
        const regularBotService = new RegularBotService();
        await regularBotService.addConfig(config);
      }

      onComplete();
    } catch (error) {
      console.error('Failed to save configuration:', error);
      setError('Failed to save configuration');
    }
  };

  if (showTokenSelector) {
    return <TokenSelector onSelect={handleTokenSelect} onCancel={handleTokenCancel} />;
  }

  return (
    <Box flexDirection="column">
      <Text bold>Add New Bot Configuration</Text>
      <Box marginTop={1} flexDirection="column">
        {fields.map((field, index) => (
          <Box key={field.name}>
            <Text color={index === currentField ? 'green' : 'white'}>
              {field.label}: {
                index === currentField 
                  ? inputValue 
                  : formData[field.name as keyof typeof formData] || ''
              }
            </Text>
          </Box>
        ))}
      </Box>
      {error && (
        <Box marginTop={1}>
          <Text color="red">{error}</Text>
        </Box>
      )}
      <Box marginTop={1}>
        <Text>Press Enter to continue, 'S' to save when done, Escape to exit</Text>
      </Box>
    </Box>
  );
};

export default RegularBotForm;

================
File: cli/hooks/useBotManagement.ts
================
import React from 'react';
import { DefaultBotManager } from '../../core/botManager.js';
import { CLISocket } from '../services/CLISocket.js';
import { getTokenName } from '../../utils/helper.js';
import { createLogger } from '../../utils/logger.js';
import { handleError } from '../../utils/errorHandler.js';
import { ErrorCodes, ErrorCode, TradeBotError } from '../../utils/errors.js';

const logger = createLogger('useBotManagement');

export const useBotManagement = (botManager: DefaultBotManager, socket: CLISocket) => {
  const [activeBots, setActiveBots] = React.useState<{
    regularBots: Array<{ botId: string; status: string }>;
    multiBots: Array<{ botId: string; status: string }>;
  }>({ regularBots: [], multiBots: [] });

  const [stoppingProgress, setStoppingProgress] = React.useState<{
    current: number;
    total: number;
    status: 'idle' | 'stopping' | 'success' | 'error';
    message: string;
  }>({ current: 0, total: 0, status: 'idle', message: '' });

  const [startingProgress, setStartingProgress] = React.useState<{
    current: number;
    total: number;
    status: 'idle' | 'starting' | 'success' | 'error';
    message: string;
  }>({ current: 0, total: 0, status: 'idle', message: '' });

  const checkActiveBots = React.useCallback(async () => {
    logger.debug('Checking active bots', { method: 'checkActiveBots' });
    try {
      const allBots = await botManager.getAllBots();
      const active = {
        regularBots: allBots.regularBots
          .filter((bot) => bot.status === 'running')
          .map((bot) => ({
            ...bot,
            type: 'regular' as const,
          })),
        multiBots: allBots.multiBots
          .filter((bot) => bot.status === 'running')
          .map((bot) => ({
            ...bot,
            type: 'multi' as const,
          })),
      };
      setActiveBots(active);
      logger.debug('Active bots updated', {
        method: 'checkActiveBots',
        regularCount: active.regularBots.length,
        multiCount: active.multiBots.length,
      });
      return [...allBots.regularBots, ...allBots.multiBots].filter((bot) => bot.status === 'running');
    } catch (error) {
      handleError(error, 'Failed to check active bots', ErrorCodes.API_ERROR.code, { method: 'checkActiveBots' });
    }
  }, [botManager]);

  const handleStopAllBots = React.useCallback(async () => {
    logger.info('Stopping all bots', { method: 'handleStopAllBots' });
    try {
      const activeBots = await checkActiveBots();
      if (activeBots.length === 0) {
        setStoppingProgress({
          current: 0,
          total: 0,
          status: 'success',
          message: 'No active bots to stop',
        });
        logger.info('No active bots to stop', { method: 'handleStopAllBots' });
        return;
      }

      setStoppingProgress({
        current: 0,
        total: activeBots.length,
        status: 'stopping',
        message: `Stopping ${activeBots.length} active bots...`,
      });

      for (let i = 0; i < activeBots.length; i++) {
        const bot = activeBots[i];
        logger.debug('Stopping bot', { method: 'handleStopAllBots', botId: bot.botId });
        await botManager.stopBot(bot.botId);
        setStoppingProgress((prev) => ({
          ...prev,
          current: i + 1,
          message: `Stopping bot ${i + 1} of ${activeBots.length}...`,
        }));
      }

      setStoppingProgress((prev) => ({
        ...prev,
        status: 'success',
        message: `Successfully stopped ${activeBots.length} bots`,
      }));
      logger.info('All bots stopped successfully', { method: 'handleStopAllBots', count: activeBots.length });
    } catch (error) {
      handleError(error, 'Failed to stop all bots', ErrorCodes.API_ERROR.code, { method: 'handleStopAllBots' });
    }
  }, [botManager, checkActiveBots]);

  const showTransactionList = React.useCallback((botId: string) => {
    logger.info('Showing transaction list', { method: 'showTransactionList', botId });
  }, []);

  const handleStartAllBots = React.useCallback(async () => {
    logger.info('Starting all bots', { method: 'handleStartAllBots' });
    try {
      const { regularBots, multiBots } = await botManager.getAllBots();
      const inactiveBots = [...regularBots, ...multiBots].filter((bot) => bot.status === 'stopped');

      if (inactiveBots.length === 0) {
        setStartingProgress({
          current: regularBots.length + multiBots.length,
          total: regularBots.length + multiBots.length,
          status: 'success',
          message: 'No inactive bots to start',
        });
        logger.info('No inactive bots to start', { method: 'handleStartAllBots' });
        return;
      }

      setStartingProgress({
        current: 0,
        total: inactiveBots.length,
        status: 'starting',
        message: `Starting ${inactiveBots.length} inactive bots...`,
      });

      for (let i = 0; i < inactiveBots.length; i++) {
        const bot = inactiveBots[i];
        logger.debug('Starting bot', { method: 'handleStartAllBots', botId: bot.botId });
        try {
          if ('targetAmounts' in bot) {
            const targetAmounts: Record<string, number> = {};
            if (Array.isArray(bot.targetAmounts)) {
              for (const target of bot.targetAmounts) {
                const tokenName = await getTokenName(target.tokenAddress);
                targetAmounts[tokenName] = Number(target.amount);
              }
            } else if (typeof bot.targetAmounts === 'object') {
              Object.assign(targetAmounts, bot.targetAmounts);
            }

            await botManager.startMultiBot(
              {
                botId: bot.botId,
                initialInputToken: bot.initialInputToken,
                initialInputAmount: Number(bot.initialInputAmount),
                targetGainPercentage: Number(bot.targetGainPercentage),
                stopLossPercentage: bot.stopLossPercentage ? Number(bot.stopLossPercentage) : undefined,
                checkInterval: bot.checkInterval ? Number(bot.checkInterval) : undefined,
                targetAmounts,
              },
              socket.getSocket(),
            );
          } else {
            await botManager.startBot(
              {
                botId: bot.botId,
                initialInputToken: bot.initialInputToken,
                initialInputAmount: Number(bot.initialInputAmount),
                firstTradePrice: bot.firstTradePrice ? Number(bot.firstTradePrice) : undefined,
                targetGainPercentage: Number(bot.targetGainPercentage),
                stopLossPercentage: bot.stopLossPercentage ? Number(bot.stopLossPercentage) : undefined,
                initialOutputToken: bot.initialOutputToken,
              },
              socket.getSocket(),
            );
          }

          setStartingProgress((prev) => ({
            ...prev,
            current: i + 1,
            message: `Starting bot ${i + 1} of ${inactiveBots.length}...`,
          }));
        } catch (error) {
          handleError(error, `Failed to start bot ${bot.botId}`, ErrorCodes.API_ERROR.code, {
            method: 'handleStartAllBots',
            botId: bot.botId,
          });
        }
      }

      setStartingProgress((prev) => ({
        ...prev,
        status: 'success',
        message: `Successfully started ${inactiveBots.length} bots`,
      }));
      logger.info('All bots started successfully', { method: 'handleStartAllBots', count: inactiveBots.length });
    } catch (error) {
      handleError(error, 'Failed to start all bots', ErrorCodes.API_ERROR.code, { method: 'handleStartAllBots' });
    }
  }, [botManager, socket]);

  return {
    activeBots,
    stoppingProgress,
    startingProgress,
    checkActiveBots,
    handleStopAllBots,
    handleStartAllBots,
    setStoppingProgress,
    setStartingProgress,
  };
};

================
File: cli/services/CLISocket.ts
================
import { io, Socket } from 'socket.io-client';
import { ENV } from '../../config/index.js';
import { EventBus } from '../../services/eventBus.js';
import { BotManager } from '../../core/types.js';
import { createLogger } from '../../utils/logger.js';
import { ErrorCodes } from '../../utils/errors.js';
import { handleError } from '../../utils/errorHandler.js';

const logger = createLogger('CLISocket');

export class CLISocket {
  private socket: Socket;
  private eventBus: EventBus;
  private isShuttingDown: boolean = false;
  private botManager: BotManager;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;

  constructor(botManager: BotManager) {
    this.botManager = botManager;
    this.socket = io(ENV.SOCKET_URL || 'http://localhost:4000', {
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: 10000,
      reconnectionDelayMax: 30000,  
    });
    this.eventBus = new EventBus(this.socket);
    this.setupReconnectHandlers();
  }

  private setupReconnectHandlers() {
    this.socket.on('reconnect_attempt', (attempt) => {
      this.reconnectAttempts = attempt;
      logger.debug('Reconnect attempt', { method: 'reconnectAttempt', attempt });
    });

    this.socket.on('reconnect_failed', () => {
      logger.error('Reconnect failed after max attempts', {
        method: 'reconnectFailed',
        attempts: this.reconnectAttempts,
      });
      this.disconnect();
    });
  }

  async cleanup() {
    if (this.isShuttingDown) return;
    this.isShuttingDown = true;

    logger.info('Starting cleanup', { method: 'cleanup' });
    try {
      this.eventBus.disconnect();
      logger.info('Cleanup complete', { method: 'cleanup' });
    } catch (error) {
      handleError(error, 'Error during cleanup', ErrorCodes.API_ERROR.code, { method: 'cleanup' });
    }
  }

  emit(event: string, data: unknown) {
    if (this.isShuttingDown) {
      logger.warn('Attempted to emit event during shutdown', { method: 'emit', event });
      return;
    }
    this.eventBus.emit(event, data);
  }

  on(event: string, callback: (data: unknown) => void) {
    this.eventBus.on(event, callback);
  }

  off(event: string, callback: (data: unknown) => void) {
    this.eventBus.off(event, callback);
  }

  disconnect() {
    this.cleanup();
  }

  getSocket(): Socket {
    return this.socket;
  }

  getEventBus(): EventBus {
    return this.eventBus;
  }

  async stopBot(botId: string): Promise<void> {
    logger.info('Stopping bot', { method: 'stopBot', botId });
    await this.botManager.stopBot(botId);
  }

  async deleteConfig(botId: string, type: 'regular' | 'multi'): Promise<void> {
    logger.info('Deleting config', { method: 'deleteConfig', botId, type });
    await this.botManager.deleteConfig(botId, type);
  }
}

================
File: config/index.ts
================
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createLogger } from '../utils/logger.js';
import cron from 'node-cron';
import { fetchTokenList } from '../services/tokenDataService.js';
import { handleError } from '../utils/errorHandler.js';
import { ErrorCodes } from '../utils/errors.js';

const logger = createLogger('Config');

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const envPath = path.resolve(__dirname, '../../.env');

// Load environment variables
dotenv.config({ path: envPath });
cron.schedule('0 0 * * *', async () => {
  logger.info('Running scheduled token list update', { method: 'scheduledTokenUpdate' });
  try {
    await fetchTokenList(false);
  } catch (error) {
    handleError(error, 'Failed to run scheduled token update', ErrorCodes.API_ERROR.code, {
      method: 'scheduledTokenUpdate',
    });
  }
});
function reloadEnv() {
  try {
    const envConfig = dotenv.parse(fs.readFileSync(envPath));
    for (const k in envConfig) {
      process.env[k] = envConfig[k];
    }
    logger.info('Environment variables loaded successfully');
  } catch (error) {
    logger.error('Failed to load environment variables:', error);
    throw error;
  }
}

reloadEnv();

export const ENV = {
  PORT: process.env.PORT || 4000,
  wallet: process.env.KEY,
  solanaEndpoint: process.env.RPC_URL,
  wss: process.env.WSS_URL,
  SOCKET_URL: process.env.SOCKET_URL || 'http://localhost:4000'
} as const;

export function checkVariables() {
  const requiredVars = ['KEY', 'RPC_URL', 'WSS_URL'];
  const missingVars = requiredVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    logger.error('Required environment variables are not set:', missingVars);
  }
  
  return {
    success: missingVars.length === 0,
    missingVars
  };
}

================
File: core/bot.ts
================
import { QuoteResponse, TradeBotConfig, NextTrade, BotData, BotStatus } from "./types.js";
import { address, Address, createSolanaRpcSubscriptions, getAddressFromPublicKey, Rpc, SolanaRpcApiMainnet } from "@solana/kit";
import { getTokenDecimalsByAddress, getTokenName } from "../utils/helper.js";
import { Socket } from "socket.io-client";
import { TradeService } from "../services/tradeService.js";
import { NotificationService } from "../services/notificationService.js";
import { ConfigService } from "../services/configService.js";
import { createLogger } from "../utils/logger.js";
import { handleError } from "../utils/errorHandler.js";
const logger = createLogger('TradeBot');

export class TradeBot {
  // Public properties
  public readonly botId: string;
  public status: BotStatus = 'stopped';
  public difference: number;
  public ratio: number;
  public currentTrade: number;
  public inputTokenAccount: Address;
  public outputTokenAccount: Address;
  public firstTradePrice: number;
  public targetGainPercentage: number | undefined;
  public stopLossPercentage: number | undefined;
  public nextTrade: NextTrade;
  public tradeCounter: number;

  // Private properties
  private readonly wallet: CryptoKeyPair;
  private readonly rpc: Rpc<SolanaRpcApiMainnet>;
  private readonly subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
  private readonly tradeService: TradeService;
  private readonly notificationService: NotificationService;
  private readonly socket: Socket;
  private priceWatchIntervalId?: NodeJS.Timeout;
  private readonly checkInterval: number;
  private lastCheck: number;
  private stopped: boolean;
  private waitingForConfirmation: boolean = false;
  public configService: ConfigService;

  constructor(config: TradeBotConfig, socket: Socket) {
    if (!config.rpc) {
      throw new Error('RPC client is required');
    }
    if (!config.subscriptions) {
      throw new Error('Subscriptions client is required');
    }

    this.botId = config.botId.toString();
    this.wallet = config.wallet;
    this.rpc = config.rpc;
    this.subscriptions = config.subscriptions;
    this.socket = socket;
    this.difference = 0;
    this.ratio = 0;
    this.currentTrade = 0;
    this.targetGainPercentage = config.targetGainPercentage || undefined;
    this.inputTokenAccount = config.initialInputToken as Address;
    this.outputTokenAccount = config.initialOutputToken as Address;
    this.firstTradePrice = config.firstTradePrice;
    this.tradeCounter = 0;
    this.stopLossPercentage = config.stopLossPercentage;
    this.stopped = false;
    this.checkInterval = config.checkInterval || 20000;
    this.lastCheck = 0;

    this.nextTrade = {
      inputMint: config.initialInputToken as Address,
      outputMint: config.initialOutputToken as Address,
      amount: config.initialInputAmount,
      swapMode: "ExactIn",
    };

    this.tradeService = new TradeService(
      this.botId,
      this.wallet,
      this.rpc,
      this.subscriptions,
      this.postTransactionProcessing.bind(this),
      this.setWaitingForConfirmation.bind(this),
    );
    this.notificationService = new NotificationService();
    this.configService = new ConfigService();
    this.initialize().catch((error) => {
    });
  }

  /**
   * Initializes the bot by fetching token accounts and starting the price watch.
   * @returns {Promise<void>}
   * @throws {Error} If public key fetching or balance refresh fails after retries.
   */
  private async initialize(): Promise<void> {
    this.notificationService.log(`Bot ID: ${this.botId} 🤖 Initiating trade bot`, this.botId);

    const pubWallet = await getAddressFromPublicKey(this.wallet.publicKey);
    if (!pubWallet) {
      logger.error(`Bot ID: ${this.botId} - Error fetching public key.`);
      throw new Error("Error fetching public key. Make sure keypair provided is set and valid.");
    }
    this.startPriceWatch();
    logger.info(`${this.botId} started successfully`);
  }

  /**
   * Starts a periodic interval to monitor price changes and execute trades.
   * @private
   */
  private startPriceWatch(): void {
    this.priceWatchIntervalId = setInterval(async () => {
      if (this.stopped || !this.priceWatchIntervalId) {
        clearInterval(this.priceWatchIntervalId);
        this.priceWatchIntervalId = undefined;
        logger.info(`Bot ID: ${this.botId} - Price watch stopped.`);
        return;
      }

      const currentTime = Date.now();
      if (currentTime - this.lastCheck < this.checkInterval) return;

      this.lastCheck = currentTime;

      if (this.waitingForConfirmation) {
        logger.info(`Bot ID: ${this.botId} - Waiting for transaction confirmation...`);
        return;
      }

      try {
        const timeout = setTimeout(() => {
          throw new Error("Quote fetch timed out");
        }, 15000);
        logger.debug(`Bot ID: ${this.botId} - calling getQuote()`);
        const quote = await this.tradeService.getQuote2(this.nextTrade);
        clearTimeout(timeout);
        if (quote) {
          await this.updateUI(quote);
          logger.debug(`Bot ID: ${this.botId} - Evaluating quote`);
          await this.tradeService.evaluateQuoteAndSwap(quote, this.firstTradePrice);
        }
      } catch (error) {
        const errorMsg = `Bot ID: ${this.botId} - Error in price watch: ${error instanceof Error ? error.message : String(error)}`;
        logger.error(errorMsg);
      }
    }, this.checkInterval);
  }

  /**
   * Sets the waiting for confirmation flag.
   * @param {boolean} flag - Whether the bot is waiting for transaction confirmation.
   * @public
   */
  public setWaitingForConfirmation(flag: boolean): void {
    logger.debug(`Bot ID: ${this.botId} - setWaitingForConfirmation(${flag})`);
    this.waitingForConfirmation = flag;
  }

  /**
   * Updates the UI with current price data and checks stop loss.
   * @param {QuoteResponse} quote - The latest quote response from the trade service.
   * @returns {Promise<void>}
   * @throws {Error} If token name or decimal conversion fails.
   * @private
   */
  private async updateUI(quote: QuoteResponse): Promise<void> {
    const currentPrice = parseInt(quote.outAmount);
    const thresholdPrice = this.firstTradePrice;

    const currentPriceWithDecimals = await getTokenDecimalsByAddress(
      this.nextTrade.outputMint as Address,
      currentPrice
    );
    const currentThresholdPrice = await getTokenDecimalsByAddress(this.nextTrade.outputMint as Address, thresholdPrice);
    logger.info(`Bot ID: ${this.botId} - updateUI() => Current Price=${currentPriceWithDecimals}, Threshold Price=${currentThresholdPrice}`);

    const diff = ((currentPriceWithDecimals - currentThresholdPrice) / currentThresholdPrice) * 100;
    this.difference = diff;
    this.currentTrade = currentPriceWithDecimals;

    if (this.stopLossPercentage && diff < -this.stopLossPercentage) {
      this.notificationService.log(`Bot ID: ${this.botId} - Stop loss triggered at ${currentPriceWithDecimals}. Terminating.`, this.botId);
      this.terminateSession();
      return;
    }

    const inputName = await getTokenName(this.nextTrade.inputMint);
    const outputName = await getTokenName(this.nextTrade.outputMint);
    const botData: BotData = {
      botId: this.botId,
      status: this.stopped ? "stopped" : "running",
      inputMint: inputName,
      outputMint: outputName,
      currentPrice: this.currentTrade,
      targetTrade: currentThresholdPrice,
      difference: this.difference,
      trades: this.tradeCounter,
      tokenInPrice: 0,
      tokenOutPrice: 0
    };

    // Emit the bot data to update the dashboard
    this.notificationService.emit(this.socket, 'bot:difference', botData);
  }

  /**
   * Updates the next trade configuration based on the last trade result.
   * @param {QuoteResponse} lastTrade - The result of the last executed trade.
   * @returns {Promise<void>}
   * @throws {Error} If target gain percentage is invalid or calculation overflows.
   * @private
   */
  private async updateNextTrade(lastTrade: QuoteResponse): Promise<void> {
    // Convert string amounts to BigInt for precise calculations
    const inLamports = BigInt(lastTrade.inAmount);
    const outLamports = BigInt(lastTrade.outAmount);
    
    if (!this.targetGainPercentage || this.targetGainPercentage <= 0) {
      throw new Error(`Bot ID: ${this.botId} - Invalid target gain percentage: ${this.targetGainPercentage}`);
    }

    // Convert target gain percentage to a decimal (e.g., 1% -> 0.01)
    const targetGainDecimal = this.targetGainPercentage / 100;
    
    // Calculate target gain in lamports with more precision
    // Multiply by 10000 to maintain 4 decimal places of precision
    const targetGainLamports = (inLamports * BigInt(Math.floor(targetGainDecimal * 10000))) / BigInt(10000);
    
    // Calculate current gain in lamports
    const currentGainLamports = outLamports - inLamports;

    logger.info(`Bot ID: ${this.botId} - Trade Analysis:
      Input Amount: ${inLamports.toString()}
      Output Amount: ${outLamports.toString()}
      Current Gain: ${currentGainLamports.toString()}
      Target Gain: ${targetGainLamports.toString()}
      Target Percentage: ${this.targetGainPercentage}%`);

    // Update next trade with the output amount from last trade
    // Reverse the trade direction and use the output amount as the new input amount
    this.nextTrade = {
      inputMint: lastTrade.outputMint,  // Use the output token as the new input
      outputMint: lastTrade.inputMint,  // Use the input token as the new output
      amount: Number(outLamports),      // Use the output amount as the new input amount
      swapMode: "ExactIn",
    };

    // Calculate new target price for next trade
    // Target price should be the input amount plus the target gain
    const newTargetPrice = inLamports + targetGainLamports;
    this.firstTradePrice = Number(newTargetPrice);

    logger.info(`Bot ID: ${this.botId} - Next Trade Setup:
      Input Mint: ${this.nextTrade.inputMint}
      Output Mint: ${this.nextTrade.outputMint}
      Amount: ${this.nextTrade.amount}
      New Target Price: ${this.firstTradePrice}`);
  }

  /**
   * Processes a completed transaction and updates bot state.
   * @param {QuoteResponse} quote - The quote response for the completed trade.
   * @param {string} txid - Transaction ID of the completed trade.
   * @returns {Promise<void>}
   * @throws {Error} If token decimal conversion or config update fails.
   * @public
   */
  public async postTransactionProcessing(quote: QuoteResponse, txid: string): Promise<void> {
    const { inputMint, inAmount, outputMint, outAmount } = quote;
    if (this.targetGainPercentage) {
      const priceChange = this.targetGainPercentage / 100;
      await this.updateNextTrade(quote);

      const getTokenA = await getTokenDecimalsByAddress(this.nextTrade.inputMint as Address, parseInt(quote.outAmount));
      const getTokenB = await getTokenDecimalsByAddress(this.nextTrade.outputMint as Address, parseInt(quote.inAmount) * (1 + priceChange));
      await this.configService.updateBotConfig(this.botId, {
        botId: this.botId,
        initialInputToken: await getTokenName(this.nextTrade.inputMint)!,
        initialOutputToken: await getTokenName(this.nextTrade.outputMint)!,
        initialInputAmount: Number(getTokenA)!,
        firstTradePrice: Number(getTokenB)!,
        targetGainPercentage: this.targetGainPercentage,
        stopLossPercentage: this.stopLossPercentage ? Number(this.stopLossPercentage) : null,
      });
    }

    const logAmount = await getTokenDecimalsByAddress(inputMint as Address, parseFloat(inAmount));
    const logOutAmount = await getTokenDecimalsByAddress(outputMint as Address, parseFloat(outAmount));
    await this.notificationService.logSwap({
      botId: this.botId,
      tokenIn: address(inputMint),
      tokenInAmount: logAmount ?? 0,
      tokenInUSD: 0,
      tokenOut: address(outputMint),
      tokenOutAmount: logOutAmount ?? 0,
      tokenOutUSD: 0,
      totalValueUSD: 0,
      txid,
      date: new Date(),
    });

    this.tradeCounter += 1;
    logger.info(`Bot ID: ${this.botId} - Trade completed: Swapped ${await getTokenName(inputMint)} for ${await getTokenName(outputMint)}`);

    if (!this.targetGainPercentage || this.targetGainPercentage === 0) {
      logger.info(`${this.botId} - No target gain percentage set. Stopping bot.`);
      this.terminateSession();
    }
  }

  /**
   * Terminates the bot session and stops all operations.
   * @public
   */
  public terminateSession(): void {
    this.notificationService.log(`Bot ID: ${this.botId} ❌ Terminating bot...`, this.botId);
    this.stopped = true;

    if (this.priceWatchIntervalId) {
      clearInterval(this.priceWatchIntervalId);
      this.priceWatchIntervalId = undefined;
    }
    this.notificationService.log(`Bot ID: ${this.botId} - Bot terminated successfully`, this.botId);
  }
}

================
File: core/botManager.ts
================
import { Socket } from "socket.io-client";
import { TradeBot } from "./bot.js";
import { MultiBot } from "./multibot.js";
import { TradeBotConfig, MultiBotConfig, BotResponse, BotManager, LogSwapArgs } from "./types.js";
import { createRpcClients } from "../services/rpcFactory.js";
import { getTokenDecimalsByName, getTokenAddressByName } from "../utils/helper.js";
import { ENV } from "../config/index.js";
import bs58 from "bs58";
import { createKeyPairFromBytes, Address } from "@solana/kit";
import { Config, MultiConfig, TargetAmount } from "@prisma/client";
import { ConfigService } from "../services/configService.js";
import { TransactionService } from "../services/transactionService.js";
import { createLogger } from "../utils/logger.js";

const logger = createLogger("DefaultBotManager");

export class DefaultBotManager implements BotManager {
  public activeBots: Map<string, TradeBot> = new Map();
  public activeMultiBots: Map<string, MultiBot> = new Map();
  private configService: ConfigService;
  private transactionService: TransactionService;

  constructor() {
    this.configService = new ConfigService();
    this.transactionService = new TransactionService();
  }

  private async initializeBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<TradeBot> {
    const solanaEndpoint: string = ENV.solanaEndpoint!;
    const wallet: string = ENV.wallet!;
    const wssEndpoint: string = ENV.wss!;
    if (!solanaEndpoint || !wallet || !wssEndpoint) {
      throw new Error('Required environment variables are not set');
    }

    const { rpc, subscriptions } = await createRpcClients({ solanaEndpoint, wssEndpoint });
    const decodedKey = new Uint8Array(bs58.decode(wallet));
    const keypair = await createKeyPairFromBytes(decodedKey);

    if (
      typeof config.initialInputToken !== 'string' ||
      typeof config.initialOutputToken !== 'string' ||
      typeof config.initialInputAmount !== 'number' ||
      typeof config.firstTradePrice !== 'number' ||
      !config.botId
    ) {
      throw new Error('Missing or invalid required config fields');
    }

    const inputToken = await getTokenDecimalsByName(config.initialInputToken);
    const outputToken = await getTokenDecimalsByName(config.initialOutputToken);
    const tokenIn = await getTokenAddressByName(config.initialInputToken);
    const tokenOut = await getTokenAddressByName(config.initialOutputToken);
    const initialInputAmount = Number(config.initialInputAmount) * 10 ** inputToken.decimals;
    const firstTradePrice = Number(config.firstTradePrice) * 10 ** outputToken.decimals;

    const botConfig: TradeBotConfig = {
      botId: config.botId,
      wallet: keypair,
      firstTradePrice,
      rpc,
      subscriptions,
      targetGainPercentage: config.targetGainPercentage!,
      initialInputToken: tokenIn as Address,
      initialInputAmount,
      initialOutputToken: tokenOut as Address,
      stopLossPercentage: config.stopLossPercentage,
    };

    const bot = new TradeBot(botConfig, socket);
    this.activeBots.set(botConfig.botId, bot);
    return bot;
  }

  private async initializeMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<MultiBot> {
    const solanaEndpoint: string = ENV.solanaEndpoint!;
    const wallet: string = ENV.wallet!;
    const wssEndpoint: string = ENV.wss!;
    if (!solanaEndpoint || !wallet || !wssEndpoint) {
      logger.error('Required environment variables are not set');
      throw new Error('Required environment variables are not set');
    }

    const { rpc, subscriptions } = await createRpcClients({ solanaEndpoint, wssEndpoint });
    const decodedKey = new Uint8Array(bs58.decode(wallet));
    const keypair = await createKeyPairFromBytes(decodedKey);

    if (
      typeof config.initialInputToken !== 'string' ||
      typeof config.initialInputAmount !== 'number' ||
      !config.botId ||
      typeof config.targetGainPercentage !== 'number'
    ) {
      logger.error('Missing or invalid required config fields');
      throw new Error('Missing or invalid required config fields');
    }

    const tokenIn = await getTokenAddressByName(config.initialInputToken);
    // Store the raw amount without decimal multiplication
    const initialInputAmount = Number(config.initialInputAmount);

    const targetAmounts: Record<string, number> = {};
    if (config.targetAmounts) {
      for (const [tokenName, amount] of Object.entries(config.targetAmounts)) {
        try {
          const tokenAddress = await getTokenAddressByName(tokenName);
          // Store target amounts in raw form without decimal multiplication
          targetAmounts[tokenAddress] = Number(amount);
        } catch (error) {
          logger.error(`Failed to process target amount for token ${tokenName}: ${error}`);
          throw new Error(`Invalid token name: ${tokenName}`);
        }
      }
    }

    if (Object.keys(targetAmounts).length === 0) {
      throw new Error('At least one target token and amount must be specified for MultiBot');
    }

    const botConfig: MultiBotConfig & {
      targetAmounts: Record<string, number>;
      initialBalance: number;
      targetGainPercentage: number;
    } = {
      botId: config.botId,
      wallet: keypair,
      rpc,
      subscriptions,
      initialInputToken: tokenIn as Address,
      initialInputAmount,
      initialBalance: config.initialBalance ?? initialInputAmount,
      targetAmounts,
      targetGainPercentage: config.targetGainPercentage,
      stopLossPercentage: config.stopLossPercentage,
      checkInterval: config.checkInterval,
    };

    const bot = new MultiBot(botConfig, socket);
    this.activeMultiBots.set(botConfig.botId, bot);
    return bot;
  }

  public async startBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<void> {
    try {
      if (!config.botId) {
        throw new Error('botId is required');
      }
      await this.initializeBot({ ...config, botId: config.botId }, socket);
    } catch (error) {
      console.error('Failed to start bot:', error);
      throw error;
    }
  }

  public async startMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<void> {
    try {
      if (!config.botId) {
        throw new Error('botId is required');
      }
      await this.initializeMultiBot({ ...config, botId: config.botId }, socket);
    } catch (error) {
      console.error('Failed to start multi bot:', error);
      throw error;
    }
  }

  public async stopBot(botId: string): Promise<void> {
    const bot = this.activeBots.get(botId);
    if (bot) {
      bot.terminateSession();
      this.activeBots.delete(botId);
    }

    const multiBot = this.activeMultiBots.get(botId);
    if (multiBot) {
      multiBot.terminateSession();
      this.activeMultiBots.delete(botId);
    }
  }

  public async getAllBots(): Promise<{
    regularBots: (Partial<Config> & { botId: string; status: string })[];
    multiBots: (MultiConfig & { botId: string; status: string; targetAmounts: TargetAmount[] })[];
  }> {
    const { regularBots, multiBots } = await this.configService.getAllConfigs();
    
    // Get all bot IDs from the active maps
    const activeRegularBotIds = new Set(this.activeBots.keys());
    const activeMultiBotIds = new Set(this.activeMultiBots.keys());

    return this.serializeForSocket({
      regularBots: regularBots.map(bot => ({
        ...bot,
        status: activeRegularBotIds.has(bot.botId) ? 'running' : 'stopped'
      })),
      multiBots: multiBots.map(bot => ({
        ...bot,
        status: activeMultiBotIds.has(bot.botId) ? 'running' : 'stopped'
      }))
    });
  }

  public async getTransactionList(): Promise<Array<LogSwapArgs>> {
    try {
      const transactions = await this.transactionService.handleGetTransactions();
      return transactions.map((tx: LogSwapArgs) => ({
        ...tx,
        tokenIn: tx.tokenIn,
        tokenOut: tx.tokenOut,
        amountIn: Number(tx.tokenInAmount),
        amountOut: Number(tx.tokenOutAmount),
        tokenInUSD: Number(tx.tokenInUSD),
        tokenOutUSD: Number(tx.tokenOutUSD),
        totalValueUSD: Number(tx.totalValueUSD),
        timestamp: new Date(tx.date).toISOString(),
      }));
    } catch (error) {
      logger.error(`Error fetching transaction list: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to fetch transaction list');
    }
  }
  
  public async deleteConfig(botId: string, type: 'regular' | 'multi'): Promise<void> {
    try {
      if (type === 'regular') {
        await this.configService.deleteConfig(botId);
      } else {
        await this.configService.deleteMultiConfig(botId);
      }
    } catch (error) {
      logger.error(`Error deleting configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to delete configuration');
    }
  }

  public async updateBotConfig(botId: string, config: Partial<TradeBotConfig>): Promise<void> {
    try {
      // First stop the bot if it's running
      await this.stopBot(botId);
      // Update the configuration
      await this.configService.updateBotConfig(botId, config);
    } catch (error) {
      logger.error(`Error updating bot configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to update configuration');
    }
  }

  public async updateMultiBotConfig(botId: string, config: Partial<MultiBotConfig>): Promise<void> {
    try {
      // First stop the bot if it's running
      await this.stopBot(botId);
      // Update the configuration
      await this.configService.updateMultiBotConfig(botId, config);
    } catch (error) {
      logger.error(`Error updating multi-bot configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to update multi-bot configuration');
    }
  }

  private serializeForSocket(data: any): any {
    if (data === null || data === undefined) {
      return data;
    }
    
    if (typeof data === 'bigint') {
      return data.toString();
    }
    
    if (Array.isArray(data)) {
      return data.map(this.serializeForSocket.bind(this));
    }
    
    if (typeof data === 'object') {
      const result: any = {};
      for (const [key, value] of Object.entries(data)) {
        result[key] = this.serializeForSocket(value);
      }
      return result;
    }
    
    return data;
  }

  public async getBotStatus(botId: string): Promise<BotResponse> {
    const bot = this.activeBots.get(botId);
    if (bot) {
      return this.serializeForSocket({
        botId,
        status: bot.status,
        difference: bot.difference,
        currentTrade: bot.currentTrade,
        ratio: bot.ratio,
        tradeCounter: bot.tradeCounter
      });
    }

    const multiBot = this.activeMultiBots.get(botId);
    if (multiBot) {
      return this.serializeForSocket({
        botId,
        status: multiBot.status,
        difference: multiBot.difference,
        currentTrade: multiBot.currentTrade,
        tradeCounter: multiBot.tradeCounter
      });
    }

    return this.serializeForSocket({
      botId,
      status: 'stopped'
    });
  }
}

================
File: core/multibot.ts
================
import { QuoteResponse, BotData, MultiBotConfig, BotStatus } from "./types.js";
import { address, Address, createSolanaRpcSubscriptions, getAddressFromPublicKey, Rpc, SolanaRpcApiMainnet } from "@solana/kit";
import { getTokenDecimalsByAddress, getTokenDecimalsByAddressRaw, getTokenName } from "../utils/helper.js";
import { TradeService } from "../services/tradeService.js";
import { NotificationService } from "../services/notificationService.js";
import { ConfigService } from "../services/configService.js";
import { Socket } from "socket.io-client";
import { createLogger } from "../utils/logger.js";

const logger = createLogger('MultiBot');

/**
 * Manages automated trading operations for a specific bot instance on the Solana blockchain.
 * This class starts with a single token balance, monitors trade ratios for multiple token pairs,
 * executes trades when targets are met, and updates target ratios based on a gain percentage.
 */
export class MultiBot {
  // Public properties
  public readonly botId: string;
  public status: BotStatus = 'stopped';
  public difference: number;
  public ratio: number;
  public currentTrade: number;
  public currentMint: Address;
  public currentTokenAccount!: Address;
  public initialInputAmount: number;
  public targetAmounts: Record<string, number>;
  public targetGainPercentage: number;
  public checkInterval: number;
  public tradeCounter: number;
  public waitingForConfirmation: boolean = false;

  // Private properties
  private readonly wallet: CryptoKeyPair;
  private readonly rpc: Rpc<SolanaRpcApiMainnet>;
  private readonly subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
  private readonly socket: Socket;
  private readonly tradeService: TradeService;
  private readonly notificationService: NotificationService;
  private readonly configService: ConfigService;
  private priceWatchIntervalId?: NodeJS.Timeout;
  private lastCheck: number;
  private stopped: boolean;

  constructor(
    config: MultiBotConfig & { targetAmounts: Record<string, number>; targetGainPercentage: number },
    socket: Socket,
  ) {
    if (!config.rpc) {
      throw new Error('RPC client is required');
    }
    if (!config.subscriptions) {
      throw new Error('Subscriptions client is required');
    }

    logger.info(`[Bot ${config.botId}] Constructing new MultiBot instance`);
    this.botId = config.botId;
    this.wallet = config.wallet;
    this.rpc = config.rpc;
    this.subscriptions = config.subscriptions;
    this.socket = socket;
    this.difference = 0;
    this.currentTrade = 0;
    this.ratio = 0;
    this.status = "running";
    this.initialInputAmount = config.initialInputAmount || 0;
    this.targetAmounts = config.targetAmounts;
    this.targetGainPercentage = config.targetGainPercentage;
    this.tradeCounter = 0;
    this.stopped = false;
    this.checkInterval = config.checkInterval || 20000;
    this.lastCheck = 0;
    this.currentMint = config.initialInputToken as Address;

    this.tradeService = new TradeService(
      this.botId,
      this.wallet,
      this.rpc,
      this.subscriptions,
      this.postTransactionProcessing.bind(this),
      this.setWaitingForConfirmation.bind(this)
    );
    this.notificationService = new NotificationService();
    this.configService = new ConfigService();

    logger.info(`[Bot ${this.botId}] Starting initialization`);
    this.init().catch((error) => {
      const errorMsg = `[Bot ${this.botId}] Initialization failed: ${error instanceof Error ? error.message : String(error)}`;
      logger.error(errorMsg);
    });
  }

  async init(): Promise<void> {
    const tokenName = await getTokenName(this.currentMint); // Use mint for token name
    const logMsg = `[Bot ${this.botId}] Initiating trade bot with ${this.initialInputAmount} ${tokenName}`;
    logger.info(logMsg);

    logger.info(`[Bot ${this.botId}] Fetching public key from wallet`);
    const pubWallet = await getAddressFromPublicKey(this.wallet.publicKey);
    if (!pubWallet) {
      const errorMsg = `[Bot ${this.botId}] Error fetching public key`;
      logger.error(errorMsg);
      throw new Error("Error fetching public key. Make sure keypair provided is set and valid.");
    }
    logger.info(`[Bot ${this.botId}] Public key fetched: ${pubWallet}`);

    logger.info(`[Bot ${this.botId}] Fetching token account for ${tokenName} (${this.currentMint})`);
    this.currentTokenAccount = await this.tradeService.getFilteredTokenAccounts(pubWallet as Address, this.currentMint) as Address;
    logger.info(`[Bot ${this.botId}] Token account updated: ${this.currentTokenAccount}`);

    const MAX_RETRIES = 3;
    let retries = 0;

    logger.info(`[Bot ${this.botId}] Starting balance refresh for ${tokenName}`);
    while (retries < MAX_RETRIES) {
      try {
        logger.info(`[Bot ${this.botId}] Refreshing balance, attempt ${retries + 1}/${MAX_RETRIES}`);
        logger.info(`[Bot ${this.botId}] Balance: ${this.initialInputAmount}`);
        if (this.initialInputAmount <= 0) {
          const errorMsg = `[Bot ${this.botId}] Insufficient initial balance: ${this.initialInputAmount}`;
          logger.error(errorMsg);
          throw new Error(errorMsg);
        }
        break;
      } catch (error) {
        retries++;
        const errorMsg = `[Bot ${this.botId}] Error refreshing balance, attempt ${retries}/${MAX_RETRIES}: ${error instanceof Error ? error.message : String(error)}`;
        logger.error(errorMsg);
        if (retries >= MAX_RETRIES) {
          const retryErrorMsg = `[Bot ${this.botId}] Failed to refresh balance after ${MAX_RETRIES} retries`;
          logger.error(retryErrorMsg);
          throw new Error(retryErrorMsg);
        }
        logger.info(`[Bot ${this.botId}] Retrying after delay of ${1000 * retries}ms`);
        await new Promise((resolve) => setTimeout(resolve, 1000 * retries));
      }
    }

    logger.info(`[Bot ${this.botId}] Initiating price watch`);
    this.initiatePriceWatch();
  }

  private initiatePriceWatch(): void {
    logger.info(`[Bot ${this.botId}] Starting price watch with interval ${this.checkInterval}ms`);
    this.priceWatchIntervalId = setInterval(async () => {
      if (this.stopped || !this.priceWatchIntervalId) {
        logger.info(`[Bot ${this.botId}] Price watch stopped`);
        clearInterval(this.priceWatchIntervalId);
        this.priceWatchIntervalId = undefined;
        return;
      }

      const currentTime = Date.now();
      if (currentTime - this.lastCheck < this.checkInterval) return;

      this.lastCheck = currentTime;

      if (this.waitingForConfirmation) {
        logger.info(`[Bot ${this.botId}] Waiting for transaction confirmation...`);
        return;
      }

      try {
        const timeout = setTimeout(() => {
          throw new Error("Quote fetch timed out");
        }, 40000);
        logger.info(`[Bot ${this.botId}] Checking trade opportunities...`);
        await this.checkTradeOpportunities();
        clearTimeout(timeout);
      } catch (error) {
        const errorMsg = `[Bot ${this.botId}] Error in price watch: ${error instanceof Error ? error.message : String(error)}`;
        logger.error(errorMsg);
      }
    }, this.checkInterval);
  }

  public setWaitingForConfirmation(flag: boolean): void {
    logger.info(`[Bot ${this.botId}] Setting waitingForConfirmation to ${flag}`);
    this.waitingForConfirmation = flag;
  }

  private async checkTradeOpportunities(): Promise<void> {
    const currentTokenName = await getTokenName(this.currentMint); // Use mint for token name

    const inputDecimals = await getTokenDecimalsByAddressRaw(this.currentMint);
    const amountInLamports = this.initialInputAmount * Math.pow(10, inputDecimals);

    for (const [targetMint, targetAmount] of Object.entries(this.targetAmounts)) {
      const targetTokenName = await getTokenName(targetMint as Address);
      logger.info(`[Bot ${this.botId}] Fetching quote for ${currentTokenName} -> ${targetTokenName} (${targetMint})`);

      const quote = await this.tradeService.getQuote2({
        inputMint: this.currentMint, // Use mint, not token account
        outputMint: targetMint as Address,
        amount: amountInLamports,
        swapMode: "ExactIn",
      });

      if (!quote || !quote.outAmount) {
        const logMsg = `[Bot ${this.botId}] No quote available for ${targetMint}`;
        logger.error(logMsg);
        continue;
      }

      const outputDecimals = await getTokenDecimalsByAddressRaw(targetMint as Address);
      const currentOutputAmount = parseInt(quote.outAmount) / Math.pow(10, outputDecimals);
      const targetOutputAmount = targetAmount; // Already in human-readable form
      logger.info(`[Bot ${this.botId}] Comparing amounts for ${targetMint}: Current=${currentOutputAmount}, Target=${targetOutputAmount}`);

      const ratioMet = currentOutputAmount >= targetOutputAmount;
      if (ratioMet) {
        logger.info(`[Bot ${this.botId}] Ratio met for ${targetTokenName}: ${currentOutputAmount} >= ${targetOutputAmount}. Executing trade...`);
        await this.tradeService.evaluateQuoteAndSwap(quote, this.initialInputAmount);
        return;
      } else {
        const difference = ((currentOutputAmount - targetOutputAmount) / targetOutputAmount) * 100;
        this.currentTrade = currentOutputAmount;
        this.difference = difference;
        logger.info(`[Bot ${this.botId}] Ratio not met for ${targetTokenName}: Difference=${difference.toFixed(3)}% (Current=${currentOutputAmount}, Target=${targetOutputAmount})`);

        const botData: BotData = {
          botId: this.botId,
          status: this.stopped ? "stopped" : "running",
          inputMint: currentTokenName,
          outputMint: targetTokenName,
          currentPrice: currentOutputAmount,
          targetTrade: targetOutputAmount,
          difference: difference,
          trades: this.tradeCounter
        };

        // Emit the bot data to update the dashboard
        this.notificationService.emit(this.socket, 'bot:difference', botData);
      }
    }
  }

  public postTransactionProcessing = async (quote: QuoteResponse, txid: string): Promise<void> => {
    const { inputMint, inAmount, outputMint, outAmount } = quote;
    const inputTokenName = await getTokenName(inputMint);
    const outputTokenName = await getTokenName(outputMint);
    logger.info(`[Bot ${this.botId}] Processing completed transaction: ${inputTokenName} -> ${outputTokenName}, TxID: ${txid}`);

    const outputDecimals = await getTokenDecimalsByAddressRaw(outputMint as Address);
    const inputDecimals = await getTokenDecimalsByAddressRaw(inputMint as Address);
    const receivedAmount = parseInt(outAmount) / Math.pow(10, outputDecimals);
    logger.info(`[Bot ${this.botId}] Expected to receive ${receivedAmount} ${outputTokenName}`);

    // Update the mint and token account after the trade
    this.currentMint = outputMint as Address;
    const pubWallet = await getAddressFromPublicKey(this.wallet.publicKey);
    if (!pubWallet) {
      const errorMsg = `[Bot ${this.botId}] Error fetching public key after trade`;
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }

    logger.info(`[Bot ${this.botId}] Fetching new token account for ${outputTokenName} (${this.currentMint})`);
    this.currentTokenAccount = await this.tradeService.getFilteredTokenAccounts(pubWallet, this.currentMint) as Address;
    if (!this.currentTokenAccount) {
      const errorMsg = `[Bot ${this.botId}] Failed to fetch token account for ${outputTokenName} (${this.currentMint})`;
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    logger.info(`[Bot ${this.botId}] Updated current token account to ${this.currentTokenAccount}`);

    // Verify the actual balance after the trade
    logger.info(`[Bot ${this.botId}] Verifying balance for new token account ${this.currentTokenAccount}`);
    const actualBalance = receivedAmount;
    if (actualBalance === undefined || actualBalance <= 0) {
      const errorMsg = `[Bot ${this.botId}] Invalid balance after trade: ${actualBalance} ${outputTokenName}`;
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    this.initialInputAmount = actualBalance;
    logger.info(`[Bot ${this.botId}] Updated current mint to ${outputTokenName} (${this.currentMint}) with verified balance ${this.initialInputAmount}`);

    // Update target amounts with the gain factor
    const gainFactor = 1 + (this.targetGainPercentage / 100);
    logger.info(`[Bot ${this.botId}] Updating target amounts with gain factor ${gainFactor} (${this.targetGainPercentage}%)`);
    this.targetAmounts = Object.fromEntries(
      Object.entries(this.targetAmounts).map(([mint, amount]) => {
        if (mint === outputMint) {
          const gain = Number(inAmount) * gainFactor;
          const newAmount = gain / Math.pow(10, inputDecimals);
          const newMint = inputMint as Address;
          return [newMint, newAmount];
        }
        return [mint, amount * gainFactor];
      })
    );

    try {
      await this.configService.updateBotConfig(this.botId, {
        botId: this.botId,
        initialInputToken: await getTokenName(this.currentMint)!,
        initialInputAmount: this.initialInputAmount,
        targetAmounts: this.targetAmounts,
        targetGainPercentage: this.targetGainPercentage,
        checkInterval: this.checkInterval,
      });
      logger.info(`[Bot ${this.botId}] Successfully updated config file after trade`);
    } catch (error) {
      logger.error(`[Bot ${this.botId}] Failed to update config file: ${error instanceof Error ? error.message : String(error)}`);
    }

    const logAmount = await getTokenDecimalsByAddress(inputMint as Address, parseFloat(inAmount));
    const logOutAmount = await getTokenDecimalsByAddress(outputMint as Address, parseFloat(outAmount));
    logger.info(`[Bot ${this.botId}] Logging swap: ${logAmount} ${inputTokenName} -> ${logOutAmount} ${outputTokenName}`);
    await this.notificationService.logSwap({
      botId: this.botId,
      tokenIn: address(inputMint),
      tokenInAmount: logAmount ?? 0,
      tokenInUSD: 0,
      tokenOut: address(outputMint),
      tokenOutAmount: logOutAmount ?? 0,
      tokenOutUSD: 0,
      totalValueUSD: 0,
      txid,
      date: new Date(),
    });

    this.tradeCounter += 1;
    const tradeMsg = `[Bot ${this.botId}] Trade completed: Swapped ${inputTokenName} for ${outputTokenName} (TxID: ${txid})`;
    logger.info(tradeMsg);
  };

  public terminateSession(): void {
    logger.info(`[Bot ${this.botId}] Terminating bot...`);
    this.notificationService.log(`[Bot ${this.botId}] ❌ Terminating bot...`, (this.botId));
    this.stopped = true;

    if (this.priceWatchIntervalId) {
      clearInterval(this.priceWatchIntervalId);
      this.priceWatchIntervalId = undefined;
    }

    logger.info(`[Bot ${this.botId}] Bot terminated successfully`);
    this.notificationService.log(`[Bot ${this.botId}] Bot terminated successfully`, (this.botId));
  }
}

export default MultiBot;

================
File: core/types.ts
================
import { RoutePlanStep } from "@jup-ag/api";
import { Address, Rpc, createSolanaRpcSubscriptions, SolanaRpcApiMainnet } from "@solana/kit";
import { Socket } from "socket.io-client";
import { MultiConfig, TargetAmount } from "@prisma/client";
import { Config } from "jest";
import { TradeBot } from "./bot.js";
import { type Token } from '../utils/tokenCache.js';
import MultiBot from "./multibot.js";

// Utility type for BigInt values that can be safely converted to/from numbers
export type SafeBigInt = bigint;

// Utility type for percentage values (0-100) stored as BigInt
export type PercentageBigInt = SafeBigInt;

// Utility functions for handling BigInt values
export const BigIntUtils = {
  // Convert a number to BigInt, handling decimal places
  fromNumber: (value: number, decimals: number = 0): SafeBigInt => {
    const multiplier = Math.pow(10, decimals);
    return BigInt(Math.floor(value * multiplier));
  },

  // Convert a BigInt back to a number, handling decimal places
  toNumber: (value: SafeBigInt, decimals: number = 0): number => {
    const divisor = Math.pow(10, decimals);
    return Number(value) / divisor;
  },

  // Convert a percentage (0-100) to BigInt
  fromPercentage: (percentage: number): PercentageBigInt => {
    return BigInt(Math.floor(percentage * 100)); // Store as basis points (1% = 100)
  },

  // Convert a BigInt percentage back to a number
  toPercentage: (value: PercentageBigInt): number => {
    return Number(value) / 100; // Convert from basis points
  },

  // Safe division of BigInt by number
  divide: (value: SafeBigInt, divisor: number): SafeBigInt => {
    return value / BigInt(Math.floor(divisor));
  },

  // Safe multiplication of BigInt by number
  multiply: (value: SafeBigInt, multiplier: number): SafeBigInt => {
    return value * BigInt(Math.floor(multiplier));
  }
};

export interface JupiterPriceResponse {
  data: {
    [mint: string]: {
      price: number;
    };
  };
}

export interface NewConfig {
  botId: string;
  inputToken: string;
  outputToken: string;
  inputAmount: number;
  firstTradePrice: number;
  targetGainPercentage: number;
  stopLossPercentage?: SafeBigInt;
}

export interface BotData {
  botId: string;
  status: string;
  balance?: number;
  inputMint: string;
  outputMint: string;
  targetTrade: number;
  difference?: number;
  tokenInPrice?: number;
  tokenOutPrice?: number;
  currentPrice: number;
  targetGainPercentage?: number;
  inBalance?: number;
  outBalance?: number;
  trades?: number;
  ratio?: number;
}

export interface TokenAccountInfo {
  pubkey: string;
  mint: string;
  balance: number;
}

export interface LogSwapArgs {
  botId: string;
  tokenIn: string;
  tokenInAmount: number;
  tokenOut: string;
  tokenOutAmount: number;
  tokenInUSD: number;
  tokenOutUSD: number;
  totalValueUSD: number;
  txid: string;
  date: Date;
}

export interface EmailArgs {
  subject: string;
  text: string;
}

export interface TradeBotConfig {
  botId: string;
  wallet: CryptoKeyPair;
  rpc: Rpc<SolanaRpcApiMainnet>;
  subscriptions?: ReturnType<typeof createSolanaRpcSubscriptions>;
  firstTradePrice: number;
  stopLossPercentage?: number;
  targetGainPercentage: number;
  checkInterval?: number;
  initialInputToken: string;
  initialInputAmount: number;
  initialOutputToken: string;
}

export interface MultiBotConfig {
  botId: string;
  wallet: CryptoKeyPair;
  rpc: Rpc<SolanaRpcApiMainnet>;
  subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
  initialInputToken?: string;
  initialInputAmount?: number;
  initialBalance?: number;
  targetAmounts?: Record<string, number>;
  targetGainPercentage?: number;
  stopLossPercentage?: number;
  checkInterval?: number;
}

export interface targetAmounts {
  outputMint: Address;
  amount: number;
}


// Extend the price target to QuoteGetRequest
export interface NextTrade extends QuoteGetRequest { }

declare const SwapMode: {
  readonly ExactIn: "ExactIn";
  readonly ExactOut: "ExactOut";
};
type SwapMode = (typeof SwapMode)[keyof typeof SwapMode];
export type PriorityLevel = "low" | "medium" | "high" | "very high";

interface QuoteGetRequest {
  inputMint: string;
  outputMint: string;
  amount: number;
  slippageBps?: number;
  autoSlippage?: boolean;
  maxAutoSlippageBps?: number;
  swapMode?: string;
  dexes?: Array<string>;
  excludeDexes?: Array<string>;
  restrictIntermediateTokens?: boolean;
  onlyDirectRoutes?: boolean;
  asLegacyTransaction?: boolean;
  platformFeeBps?: number;
  maxAccounts?: number;
  prioritizationFeeLamports?: {
    priorityLevelWithMaxLamports: {
      maxLamports: number;
      priorityLevel: PriorityLevel;
    };
  };
}

interface LogEntry {
  level: 'info' | 'error' | 'warn';
  timestamp: string;
  message: string;
  stack?: string;
  context?: Record<string, any>;
}


interface QuoteResponse {
  inputMint: string;
  inAmount: string;
  outputMint: string;
  outAmount: string;
  otherAmountThreshold: string;
  swapMode: SwapMode;
  slippageBps: number;
  feeAccount?: string;
  autoSlippage?: boolean;
  maxAutoSlippageBps?: number;
  platformFee?: {
    amount: string;
    feeBps: number
  }
  priceImpactPct: string;
  routePlan: Array<RoutePlanStep>;
  contextSlot?: number;
  timeTaken?: number;
}

export interface ConfigData {
  botId: string;
  initialInputToken: string;
  initialOutputToken?: string;
  initialInputAmount: number;
  firstTradePrice?: number;
  targetGainPercentage: number;
  stopLossPercentage?: number;
  checkInterval?: number;
  status?: BotStatus;
}

export interface MultiConfigData extends ConfigData {
  targetAmounts: Array<{ tokenAddress: string; amount: number }>;
}

interface QuicknodeRpcConfig {
  wssEndpoint: string;
}

interface CreateAddonsApiParams {
  endpoint: string;
  jupiterApi?: string;
}


export type {
  QuoteGetRequest,
  QuoteResponse,
  QuicknodeRpcConfig,
  CreateAddonsApiParams,
  LogEntry,
};
export interface Tags {
  verified?: string;
  unverified?: string;
  lst?: string;
  strict?: string;
  community?: string;
  pump?: string;
  clone?: string;
};

export type TokenInfo = {
  address: string;
  name: string;
  symbol: string;
  decimals: number;
  logoURI: string;
}

export type BotStatus = "running" | "stopped";

export interface BotResponse {
  botId: string;
  status: BotStatus;
}

export interface MultiBotResponse {
  botId: string;
  status: BotStatus;
  targetAmounts: targetAmounts[];
}

export interface Bot {
  botId: string;
  status: BotStatus;
  amount: number;
  initialInputToken: string;
  initialOutputToken?: string;
}

export interface BotWithType extends Bot {
  type: 'regular' | 'multi';
  firstTradePrice?: bigint | number;
  targetGainPercentage?: number;
  stopLossPercentage?: number;
  initialInputAmount?: bigint | number;
  initialOutputAmount?: bigint | number;
  checkInterval?: number;
  targetAmounts?: Array<{
    tokenAddress: string;
    amount: number;
  }>;
}

export interface ConfigListState {
  regularBots: Array<{
    botId: string;
    initialInputToken: string;
    initialOutputToken: string;
    initialInputAmount: number;
    firstTradePrice: number;
    targetGainPercentage: number;
    stopLossPercentage?: number;
    status: BotStatus;
  }>;
  multiBots: Array<{
    botId: string;
    initialInputToken: string;
    initialInputAmount: number;
    targetGainPercentage: number;
    stopLossPercentage?: number;
    checkInterval?: number;
    status: BotStatus;
    targetAmounts: Array<{
      id: number;
      configId: string;
      tokenAddress: string;
      amount: number;
    }>;
  }>;
}
export interface RpcClients {
  rpc: Rpc<SolanaRpcApiMainnet>;
  subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
}
export interface BotInitializer {
  initializeBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<TradeBot>;
  initializeMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<MultiBot>;
}

export interface BotManager {
  activeBots: Map<string, TradeBot>;
  activeMultiBots: Map<string, MultiBot>;
  startBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<void>;
  startMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<void>;
  stopBot(botId: string): Promise<void>;
  getBotStatus(botId: string): Promise<any>;
  getTransactionList(): Promise<Array<LogSwapArgs>>;
  getAllBots(): Promise<{
    regularBots: Array<Config & { status: string }>;
    multiBots: Array<MultiConfig & { status: string; targetAmounts: TargetAmount[] }>;
  }>;
  deleteConfig(botId: string, type: 'regular' | 'multi'): Promise<void>;
  updateBotConfig(botId: string, config: Partial<TradeBotConfig>): Promise<void>;
  updateMultiBotConfig(botId: string, config: Partial<MultiBotConfig>): Promise<void>;
}

export interface SocketService {
  getSocket(): Socket;
  emit(event: string, data: any): void;
  on(event: string, handler: (data: any) => void): void;
  off(event: string, handler: (data: any) => void): void;
  disconnect(): void;
}

export type SortField = 'type' | 'amount' | 'status';
export type SortDirection = 'asc' | 'desc';
export type FilterType = 'all' | 'active' | 'inactive';

export interface DashboardProps {
  socket: Socket;
  height?: number;
  onRefresh: () => void;
}

export interface Repository<T> {
  create(data: Partial<T>): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<T>;
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
}
export interface ConfigListProps {
  socket: Socket;
  botManager: BotManager;
  onBack: () => void;
  onEdit?: (type: 'regular' | 'multi', config: any) => void;
}

export interface RegularBotFormProps {
  onComplete: () => void;
  editingConfig?: any;
}

export interface MultiBotFormProps {
  onComplete: () => void;
  editingConfig?: any;
}


export interface TokenSelectorProps {
  onSelect: (token: Token) => void;
  onCancel: () => void;
}

================
File: scripts/run-cli.,mjs
================
#!/usr/bin/env node

import { spawn } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs';
import { createLogger } from './src/utils/logger.js';

const logger = createLogger('RunCLI');

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const LOCK_FILE = join(process.cwd(), 'cli.lock');

function acquireLock() {
  try {
    const fd = fs.openSync(LOCK_FILE, 'wx'); // Exclusive write
    fs.writeFileSync(fd, process.pid.toString());
    fs.closeSync(fd);
    logger.debug('Acquired CLI lock', { method: 'acquireLock', pid: process.pid });
    return true;
  } catch (error) {
    if (error.code === 'EEXIST') {
      logger.error('Another CLI instance is running', { method: 'acquireLock', error: error.message });
      console.error('Error: Another CLI instance is already running');
      process.exit(1);
    }
    logger.error('Failed to acquire CLI lock', { method: 'acquireLock', error: error.message });
    process.exit(1);
  }
}

function releaseLock() {
  try {
    if (fs.existsSync(LOCK_FILE)) {
      const pid = fs.readFileSync(LOCK_FILE, 'utf8');
      if (parseInt(pid) === process.pid) {
        fs.unlinkSync(LOCK_FILE);
        logger.debug('Released CLI lock', { method: 'releaseLock' });
      }
    }
  } catch (error) {
    logger.error('Failed to release CLI lock', { method: 'releaseLock', error: error.message });
  }
}

const tsxPath = join(process.cwd(), 'node_modules', '.bin', 'tsx.cmd');
const cliPath = join(process.cwd(), 'src', 'cli.ts');

if (!fs.existsSync(tsxPath)) {
  logger.error('tsx.cmd not found', { method: 'startCLI', tsxPath });
  console.error(`Error: tsx.cmd not found at ${tsxPath}. Ensure dependencies are installed.`);
  process.exit(1);
}

acquireLock();

const cli = spawn(tsxPath, [cliPath], {
  stdio: 'inherit',
  env: {
    ...process.env,
    FORCE_COLOR: '1',
    LOG_LEVEL: 'debug',
  },
  shell: true,
});

cli.on('error', (err) => {
  logger.error('Failed to start CLI', { method: 'startCLI', error: err.message });
  console.error('Failed to start CLI:', err);
  releaseLock();
  process.exit(1);
});

cli.on('exit', (code) => {
  logger.info('CLI process exited', { method: 'exitCLI', code });
  releaseLock();
  process.exit(code || 0);
});

process.on('SIGINT', () => {
  logger.info('Received SIGINT, shutting down CLI', { method: 'shutdown' });
  cli.kill('SIGINT');
});

process.on('SIGTERM', () => {
  logger.info('Received SIGTERM, shutting down CLI', { method: 'shutdown' });
  cli.kill('SIGTERM');
});

process.on('uncaughtException', (error) => {
  logger.error('Uncaught exception in run-cli', { method: 'uncaughtException', error: error.message });
  releaseLock();
  process.exit(1);
});

process.on('unhandledRejection', (reason) => {
  logger.error('Unhandled rejection in run-cli', { method: 'unhandledRejection', reason });
  releaseLock();
  process.exit(1);
});

================
File: scripts/seedTokens.ts
================
import { fetchTokenList } from '../services/tokenDataService.js';
import prisma from '../utils/prismaClient.js';
import { createLogger } from '../utils/logger.js';

const logger = createLogger('SeedTokensScript');

async function seedTokens() {
  try {
    logger.info('Starting token database seeding...');
    
    // Check if we have any tokens in the database
    const existingTokens = await prisma.token.findMany({
      take: 1
    });

    if (existingTokens.length === 0) {
      logger.info('No tokens found in database, fetching from Jupiter API...');
      await fetchTokenList();
    } else {
      logger.info('Tokens already exist in database, skipping fetch...');
    }

    logger.info('Token database seeding completed successfully');
  } catch (error) {
    logger.error(`Failed to seed token database: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

seedTokens();

================
File: server.ts
================
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { ENV } from './config/index.js';
import cors from 'cors';
import { ConfigService } from './services/configService.js';
import { getSingleTokenData, fetchTokenList } from './services/tokenDataService.js';
import prisma from './utils/prismaClient.js';
import { createLogger } from './utils/logger.js';
import { handleError } from './utils/errorHandler.js';
import { TradeBotError, ErrorCodes } from './utils/errors.js';
import { TransactionService } from './services/transactionService.js';

const logger = createLogger('Server');
const app = express();
app.use(cors());
app.use(express.json());

const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST'],
  },
});

const configService = new ConfigService();
const transactionService = new TransactionService();
// Helper function to serialize data for socket transmission
const serializeForSocket = (data: any): any => {
  if (data === null || data === undefined) {
    return data;
  }
  if (typeof data === 'bigint') {
    return data.toString();
  }
  if (Array.isArray(data)) {
    return data.map(serializeForSocket);
  }
  if (typeof data === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(data)) {
      result[key] = serializeForSocket(value);
    }
    return result;
  }
  return data;
};

// API Endpoints
app.get('/api/configs', async (req, res) => {
  logger.info('Fetching all configs', { method: 'getConfigs' });
  try {
    const configs = await configService.getAllConfigs();
    res.json(serializeForSocket(configs));
  } catch (error) {
    handleError(error, 'Failed to fetch configurations', ErrorCodes.DB_ERROR.code, { method: 'getConfigs' });
  }
});

app.get('/api/token/:mint', async (req, res) => {
  logger.info('Fetching token data', { method: 'getToken', mint: req.params.mint });
  try {
    const { mint } = req.params;
    if (!mint) {
      throw new TradeBotError('Mint address is required', ErrorCodes.INVALID_CONFIG.code, { method: 'getToken' });
    }
    const tokenData = await getSingleTokenData(mint);
    if (!tokenData) {
      res.status(404).json({ error: 'Token not found' });
      return;
    }
    res.json(serializeForSocket(tokenData));
  } catch (error) {
    handleError(error, 'Failed to fetch token data', ErrorCodes.DB_ERROR.code, { method: 'getToken', mint: req.params.mint });
  }
});

io.on('connection', (socket) => {
  logger.info('Client connected', { method: 'socketConnection', socketId: socket.id });

  socket.on('disconnect', () => {
    logger.info('Client disconnected', { method: 'socketDisconnect', socketId: socket.id });
  });

  socket.on('error', (error) => {
    handleError(error, 'Socket error', ErrorCodes.API_ERROR.code, { method: 'socketError', socketId: socket.id });
  });

  socket.on('config:get', async () => {
    logger.info('Fetching configs for socket', { method: 'socketConfigGet', socketId: socket.id });
    try {
      const configs = await configService.getAllConfigs();
      logger.info('Sending config response', {
        method: 'socketConfigGet',
        socketId: socket.id,
        regularCount: configs.regularBots.length,
        multiCount: configs.multiBots.length,
      });
      socket.emit('config:response', serializeForSocket(configs)); // Changed to config:response
    } catch (error) {
      handleError(error, 'Failed to fetch configurations for socket', ErrorCodes.DB_ERROR.code, {
        method: 'socketConfigGet',
        socketId: socket.id,
      });
    }
  });

  socket.on('config:edit', async (data) => {
    logger.info('Config edit requested', { method: 'socketConfigEdit', socketId: socket.id, data });
    try {
      await configService.updateBotConfig(data.config.botId, data.config);
      const configs = await configService.getAllConfigs();
      socket.emit('config:update', serializeForSocket(configs)); // Used for edit updates
    } catch (error) {
      handleError(error, 'Failed to update configuration', ErrorCodes.DB_ERROR.code, {
        method: 'socketConfigEdit',
        socketId: socket.id,
      });
    }
  });

  socket.on('bot:start', (data) => {
    logger.info('Bot start requested', { method: 'socketBotStart', socketId: socket.id, data });
    socket.emit('bot:start', serializeForSocket(data));
  });

  socket.on('bot:stop', (data) => {
    logger.info('Bot stop requested', { method: 'socketBotStop', socketId: socket.id, data });
    socket.emit('bot:stop', serializeForSocket(data));
  });

  socket.on('bot:difference', (data) => {
    logger.info('Bot difference update', { method: 'socketBotDifference', socketId: socket.id });
    io.emit('bot:difference', serializeForSocket(data));
  });

  socket.on('log', (data) => {
    logger.info('Bot log received', { method: 'socketLog', socketId: socket.id, data });
  });

  socket.on('transaction:get', async () => {
    logger.info('Fetching transactions for socket', { method: 'socketTransactionGet', socketId: socket.id });
    try {
      const transactions = await transactionService.handleGetTransactions();
      logger.info('Sending transaction response', {
        method: 'socketTransactionGet',
        socketId: socket.id,
        transactionCount: transactions.transactions.length,
      });
      socket.emit('transaction:response', serializeForSocket(transactions)); // Changed to transaction:response
    } catch (error) {
      handleError(error, 'Failed to fetch transactions for socket', ErrorCodes.DB_ERROR.code, {
        method: 'socketTransactionGet',
        socketId: socket.id,
      });
    }
  });
});
async function initializeTokens() {
  logger.info('Checking token list initialization', { method: 'initializeTokens' });
  try {
    await prisma.$connect();
    logger.debug('Database connection established', { method: 'initializeTokens' });

    const metadata = await prisma.metadata.findUnique({
      where: { key: 'tokens_seeded' },
    });

    if (metadata?.value === 'true') {
      const tokenCount = await prisma.token.count();
      logger.info('Token list already seeded', { method: 'initializeTokens', tokenCount });
      if (tokenCount === 0) {
        logger.warn('Tokens seeded flag set but no tokens found, resetting flag', { method: 'initializeTokens' });
        await prisma.metadata.delete({ where: { key: 'tokens_seeded' } });
      } else {
        return;
      }
    }

    logger.info('No seeding record found, checking token count', { method: 'initializeTokens' });
    const tokenCount = await prisma.token.count();
    if (tokenCount === 0) {
      logger.info('No tokens found, seeding initial token list', { method: 'initializeTokens' });
      const lock = await prisma.metadata.upsert({
        where: { key: 'token_seed_lock' },
        update: { value: 'locked' },
        create: { key: 'token_seed_lock', value: 'locked' },
      });

      if (lock.value !== 'locked') {
        logger.info('Token seeding already in progress, skipping', { method: 'initializeTokens' });
        return;
      }

      try {
        await fetchTokenList(true);
        const newTokenCount = await prisma.token.count();
        logger.info('Token list seeded successfully', { method: 'initializeTokens', newTokenCount });
        if (newTokenCount === 0) {
          throw new TradeBotError('Seeding completed but no tokens inserted', ErrorCodes.DB_ERROR.code, {
            method: 'initializeTokens',
          });
        }
        await prisma.metadata.upsert({
          where: { key: 'tokens_seeded' },
          update: { value: 'true' },
          create: { key: 'tokens_seeded', value: 'true' },
        });
      } finally {
        await prisma.metadata.delete({ where: { key: 'token_seed_lock' } });
      }
    } else {
      logger.info('Tokens found, marking as seeded', { method: 'initializeTokens', count: tokenCount });
      await prisma.metadata.upsert({
        where: { key: 'tokens_seeded' },
        update: { value: 'true' },
        create: { key: 'tokens_seeded', value: 'true' },
      });
    }
  } catch (error) {
    handleError(error, 'Failed to initialize token list', ErrorCodes.DB_ERROR.code, { method: 'initializeTokens' });
  }
}

const PORT = ENV.PORT || 4000;
httpServer.listen(PORT, async () => {
  logger.info(`Server running on port ${PORT}`, { method: 'startServer' });
  try {
    await initializeTokens();
  } catch (error) {
    logger.error('Server startup failed due to token initialization error', { method: 'startServer', error });
    process.exit(1);
  }
});

export const cleanup = async () => {
  logger.info('Starting server shutdown', { method: 'cleanup' });
  const forceShutdown = setTimeout(() => {
    logger.error('Forced shutdown after timeout', { method: 'cleanup' });
    process.exit(1);
  }, 10000);

  try {
    logger.info('Stopping new connections', { method: 'cleanup' });
    httpServer.close();

    logger.info('Closing socket connections', { method: 'cleanup' });
    if (io) {
      io.sockets.sockets.forEach((socket) => {
        socket.disconnect(true);
      });
      io.close();
    }

    logger.info('Waiting for existing connections to close', { method: 'cleanup' });
    await new Promise((resolve) => setTimeout(resolve, 2000));

    logger.info('Disconnecting from database', { method: 'cleanup' });
    await prisma.$disconnect();
    logger.info('Database disconnected successfully', { method: 'cleanup' });

    clearTimeout(forceShutdown);
    logger.info('Server shutdown complete', { method: 'cleanup' });
    process.exit(0);
  } catch (error) {
    handleError(error, 'Error during cleanup', ErrorCodes.API_ERROR.code, { method: 'cleanup' });
  }
};

const handleSignal = async (signal: string) => {
  logger.info(`Received ${signal} signal`, { method: 'handleSignal' });
  process.removeAllListeners('SIGINT');
  process.removeAllListeners('SIGTERM');
  await cleanup();
};

process.setMaxListeners(20);
process.removeAllListeners('SIGINT');
process.removeAllListeners('SIGTERM');

process.on('SIGINT', () => handleSignal('SIGINT'));
process.on('SIGTERM', () => handleSignal('SIGTERM'));

process.on('uncaughtException', (error) => {
  handleError(error, 'Uncaught Exception', ErrorCodes.API_ERROR.code, { method: 'uncaughtException' });
});

process.on('unhandledRejection', (reason, promise) => {
  handleError(reason, 'Unhandled Rejection', ErrorCodes.API_ERROR.code, { method: 'unhandledRejection', promise });
});

================
File: services/botService.ts
================
import { RegularConfigRepository, MultiConfigRepository } from './configRepository.js';
import { createLogger } from '../utils/logger.js';
import { Config, MultiConfig, TargetAmount } from '@prisma/client';
import { TradeBotError, ErrorCodes } from '../utils/errors.js';
import { handleError } from '../utils/errorHandler.js';

const logger = createLogger('BotService');

type BotConfig = Config | (MultiConfig & { targetAmounts: TargetAmount[] });
type BotData = Partial<Config> | Partial<MultiConfig & { targetAmounts: Record<string, number> }>;

interface Repository<T> {
  create(data: Partial<T>): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<T>;
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
}

export class BotService<T extends BotConfig> {
  constructor(protected repository: Repository<T>) { }

  async addConfig(data: BotData): Promise<T> {
    logger.info('Creating configuration', { botId: data.botId, method: 'addConfig' });
    try {
      const processedData = this.processData(data);
      const result = await this.repository.create(processedData);
      logger.info('Configuration created successfully', { botId: data.botId });
      return result;
    } catch (error) {
      handleError(error, 'Failed to create configuration', ErrorCodes.CONFIG_CREATION_FAILED.code, {
        botId: data.botId,
        data,
        method: 'addConfig',
      });
    }
  }

  async updateConfig(botId: string, data: Partial<BotData>): Promise<T> {
    logger.info('Updating configuration', { botId, method: 'updateConfig' });
    try {
      const processedData = this.processData(data);
      const result = await this.repository.update(botId, processedData);
      logger.info('Configuration updated successfully', { botId });
      return result;
    } catch (error) {
      handleError(error, 'Failed to update configuration', ErrorCodes.CONFIG_UPDATE_FAILED.code, {
        botId,
        data,
        method: 'updateConfig',
      });
    }
  }

  async deleteConfig(botId: string): Promise<T> {
    logger.info('Deleting configuration', { botId, method: 'deleteConfig' });
    try {
      const result = await this.repository.delete(botId);
      if (!result) {
        handleError(null, 'Configuration not found', ErrorCodes.NOT_FOUND.code, { botId, method: 'deleteConfig' });
      }
      logger.info('Configuration deleted successfully', { botId });
      return result;
    } catch (error) {
      handleError(error, 'Failed to delete configuration', ErrorCodes.DB_ERROR.code, { botId, method: 'deleteConfig' });
    }
  }

  async getConfig(botId: string): Promise<T | null> {
    logger.info('Retrieving configuration', { botId, method: 'getConfig' });
    try {
      const result = await this.repository.findById(botId);
      logger.info('Configuration retrieved', { botId, found: !!result });
      return result;
    } catch (error) {
      handleError(error, 'Failed to get configuration', ErrorCodes.DB_ERROR.code, { botId, method: 'getConfig' });
    }
  }

  async getAllConfigs(): Promise<T[]> {
    logger.info('Retrieving all configurations', { method: 'getAllConfigs' });
    try {
      const results = await this.repository.findAll();
      logger.info('All configurations retrieved', { count: results.length, method: 'getAllConfigs' });
      return results;
    } catch (error) {
      handleError(error, 'Failed to get all configurations', ErrorCodes.DB_ERROR.code, { method: 'getAllConfigs' });
    }
  }

  private processData(data: BotData): Partial<T> {
    if (!data) {
      throw new TradeBotError('Invalid configuration data', ErrorCodes.INVALID_CONFIG.code, { method: 'processData' });
    }

    const processed: any = { ...data };
    if ('stopLossPercentage' in processed) {
      processed.stopLossPercentage = this.convertStopLossPercentage(processed.stopLossPercentage);
    }
    if (
      typeof data === 'object' &&
      data !== null &&
      'targetAmounts' in data &&
      data.targetAmounts &&
      typeof data.targetAmounts === 'object'
    ) {
      if (!(data as any).botId) {
        throw new TradeBotError('Missing botId for targetAmounts', ErrorCodes.INVALID_CONFIG.code, {
          data,
          method: 'processData',
        });
      }
      processed.targetAmounts = Object.entries(data.targetAmounts).map(([tokenAddress, amount]) => ({
        tokenAddress,
        amount,
        configId: (data as any).botId as string,
      }));
    }
    return processed as Partial<T>;
  }

  private convertStopLossPercentage(value: bigint | number | null | undefined): number | null {
    return value == null ? null : typeof value === 'bigint' ? Number(value) : value;
  }
}

export const regularBotService = new BotService<Config>(new RegularConfigRepository());
export const multiBotService = new BotService<MultiConfig & { targetAmounts: TargetAmount[] }>(
  new MultiConfigRepository()
);

================
File: services/configRepository.ts
================
import { PrismaClient, Config, MultiConfig, TargetAmount } from '@prisma/client';
import { PrismaRepository } from './repository.js';

export class RegularConfigRepository extends PrismaRepository<Config> {
  constructor() {
    super(new PrismaClient().config);
  }
}

export class MultiConfigRepository extends PrismaRepository<MultiConfig & { targetAmounts: TargetAmount[] }> {
  constructor() {
    super(new PrismaClient().multiConfig);
  }

  async create(data: Partial<MultiConfig & { targetAmounts: Partial<TargetAmount>[] }>): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    const { targetAmounts, ...configData } = data;
    const config = await this.model.create({ data: configData });
    
    if (targetAmounts && targetAmounts.length > 0) {
      await this.prisma.targetAmount.createMany({
        data: targetAmounts.map(ta => ({
          configId: config.botId,
          tokenAddress: ta.tokenAddress || '',
          tokenName: ta.tokenName || '',
          amount: ta.amount || 0
        }))
      });
    }

    return this.findById(config.botId) as Promise<MultiConfig & { targetAmounts: TargetAmount[] }>;
  }

  async update(id: string, data: Partial<MultiConfig & { targetAmounts: Partial<TargetAmount>[] }>): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    const { targetAmounts, ...configData } = data;
    
    // Update the main config
    const config = await this.model.update({
      where: { botId: id },
      data: configData
    });

    // Update target amounts if provided
    if (targetAmounts) {
      // Delete existing target amounts
      await this.prisma.targetAmount.deleteMany({
        where: { configId: id }
      });

      // Create new target amounts
      if (targetAmounts.length > 0) {
        await this.prisma.targetAmount.createMany({
          data: targetAmounts.map(ta => ({
            configId: id,
            tokenAddress: ta.tokenAddress || '',
            tokenName: ta.tokenName ||  '',
            amount: ta.amount || 0
          }))
        });
      }
    }

    return this.findById(id) as Promise<MultiConfig & { targetAmounts: TargetAmount[] }>;
  }

  async findById(id: string): Promise<(MultiConfig & { targetAmounts: TargetAmount[] }) | null> {
    return this.model.findUnique({
      where: { botId: id },
      include: { targetAmounts: true }
    });
  }

  async findAll(): Promise<(MultiConfig & { targetAmounts: TargetAmount[] })[]> {
    return this.model.findMany({
      include: { targetAmounts: true }
    });
  }
}

================
File: services/configService.ts
================
import { Config, MultiConfig, TargetAmount } from '@prisma/client';
import { RegularConfigRepository } from './configRepository.js';
import { MultiConfigRepository } from './configRepository.js';
import { BigIntUtils, BotStatus } from '../core/types.js';
import { createLogger } from '../utils/logger.js';

const logger = createLogger('ConfigService');

export class RegularConfigService {
  private repository: RegularConfigRepository;

  constructor() {
    this.repository = new RegularConfigRepository();
  }

  async addConfig(data: {
    botId: string;
    initialInputToken: string;
    initialOutputToken: string;
    initialInputAmount: number;
    firstTradePrice: number;
    targetGainPercentage: number;
    stopLossPercentage?: number;
  }): Promise<Config> {
    const configData = {
      ...data,
      stopLossPercentage: data.stopLossPercentage ? 
        Number(BigIntUtils.fromPercentage(data.stopLossPercentage)) : 
        null
    };
    return this.repository.create(configData);
  }

  async updateConfig(botId: string, data: Partial<Config>): Promise<Config> {
    if (data.stopLossPercentage) {
      data.stopLossPercentage = Number(BigIntUtils.fromPercentage(data.stopLossPercentage));
    }
    return this.repository.update(botId, data);
  }

  async deleteConfig(botId: string): Promise<Config> {
    return this.repository.delete(botId);
  }

  async getConfig(botId: string): Promise<Config | null> {
    return this.repository.findById(botId);
  }

  async getAllConfigs(): Promise<Config[]> {
    return this.repository.findAll();
  }
}

export class MultiConfigService {
  private repository: MultiConfigRepository;

  constructor() {
    this.repository = new MultiConfigRepository();
  }

  async addConfig(data: {
    botId: string;
    initialInputToken: string;
    initialInputAmount: number;
    targetGainPercentage: number;
    stopLossPercentage?: number;
    checkInterval?: number;
    targetAmounts: Array<{
      tokenAddress: string;
      amount: number;
    }>;
  }): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    const configData = {
      ...data,
      stopLossPercentage: data.stopLossPercentage ? 
        Number(BigIntUtils.fromPercentage(data.stopLossPercentage)) : 
        null,
      targetAmounts: data.targetAmounts.map(ta => ({
        tokenAddress: ta.tokenAddress,
        amount: ta.amount
      }))
    };
    return this.repository.create(configData);
  }

  async updateConfig(
    botId: string, 
    data: Partial<MultiConfig & { targetAmounts: Array<{ tokenAddress: string; amount: number }> }>
  ): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    if (data.stopLossPercentage) {
      data.stopLossPercentage = Number(BigIntUtils.fromPercentage(data.stopLossPercentage));
    }
    return this.repository.update(botId, data);
  }

  async deleteConfig(botId: string): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    return this.repository.delete(botId);
  }

  async getConfig(botId: string): Promise<(MultiConfig & { targetAmounts: TargetAmount[] }) | null> {
    return this.repository.findById(botId);
  }

  async getAllConfigs(): Promise<(MultiConfig & { targetAmounts: TargetAmount[] })[]> {
    return this.repository.findAll();
  }
}

/**
 * ConfigService acts as the main facade for bot configuration management.
 * It provides a unified interface for both regular and multi-token bot configurations.
 * 
 * Responsibilities:
 * - Provides a single entry point for all configuration operations
 * - Delegates to specialized services for bot-specific operations
 * - Maintains backward compatibility
 */
export class ConfigService {
  private regularService: RegularConfigService;
  private multiService: MultiConfigService;

  constructor() {
    this.regularService = new RegularConfigService();
    this.multiService = new MultiConfigService();
  }

  async addConfig(data: any): Promise<Config> {
    return this.regularService.addConfig(data);
  }

  async addMultiConfig(data: any): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    return this.multiService.addConfig(data);
  }

  async updateBotConfig(botId: string, data: any): Promise<Config> {
    return this.regularService.updateConfig(botId, data);
  }

  async updateMultiBotConfig(botId: string, data: any): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    return this.multiService.updateConfig(botId, data);
  }

  async deleteConfig(botId: string): Promise<Config> {
    return this.regularService.deleteConfig(botId);
  }

  async deleteMultiConfig(botId: string): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    return this.multiService.deleteConfig(botId);
  }

  async updateBotStatus(botId: string, status: BotStatus): Promise<void> {
    try {
      // Try to update regular bot first
      try {
        await this.regularService.updateConfig(botId, { status });
        return;
      } catch (error) {
        // If regular bot update fails, try multi bot
        await this.multiService.updateConfig(botId, { status });
      }
    } catch (error) {
      logger.error(`Error updating bot status: ${error}`);
      throw new Error('Failed to update bot status');
    }
  }

  async getAllConfigs(): Promise<{
    regularBots: Config[];
    multiBots: (MultiConfig & { targetAmounts: TargetAmount[] })[];
  }> {
    const [regularBots, multiBots] = await Promise.all([
      this.regularService.getAllConfigs(),
      this.multiService.getAllConfigs()
    ]);
    return { regularBots, multiBots };
  }
}

================
File: services/eventBus.ts
================
import { Socket } from 'socket.io-client';
import { createLogger } from '../utils/logger.js';
import { handleError } from '../utils/errorHandler.js';
import { ErrorCodes } from '../utils/errors.js';
export class EventBus {
  private socket: Socket;
  private logger = createLogger('EventBus');
  private eventQueue: Array<{ event: string; data: unknown }> = [];

  constructor(socket: Socket) {
    this.socket = socket;
    this.setupEventListeners();
  }

  private setupEventListeners() {
    this.socket.on('connect', () => {
      this.logger.info('Socket connected', { method: 'socketConnect', socketId: this.socket.id });
    });

    this.socket.on('disconnect', (reason) => {
      this.logger.info('Socket disconnected', { method: 'socketDisconnect', reason, socketId: this.socket.id });
    });

    this.socket.on('error', (err: any) => {
      handleError(err, 'Socket error', ErrorCodes.API_ERROR.code, {
        method: 'socketError',
        error: err.message,
        socketId: this.socket.id,
      });
    });

    this.socket.on('connect_error', (err: any) => {
      handleError(err, 'Socket connection error', ErrorCodes.API_ERROR.code, {
        method: 'socketConnectError',
        error: err.message,
        socketId: this.socket.id,
      });
    });

    this.socket.on('reconnect_attempt', (attempt) => {
      this.logger.debug('Reconnect attempt', { method: 'reconnectAttempt', attempt });
    });

    this.socket.on('reconnect_failed', () => {
      this.logger.error('Reconnect failed after max attempts', { method: 'reconnectFailed' });
    });
  }

 

  emit(event: string, data: unknown) {
    if (!this.socket.connected) {
      this.logger.warn('Queueing event, socket disconnected', { method: 'emit', event });
      this.eventQueue.push({ event, data });
      return;
    }
    this.socket.emit(event, data);
    this.logger.debug('Emitted event', { method: 'emit', event });
  }

  on(event: string, callback: (data: unknown) => void) {
    this.socket.on(event, callback);
    this.logger.debug('Registered listener', { method: 'on', event });
  }

  off(event: string, callback: (data: unknown) => void) {
    this.socket.off(event, callback);
    this.logger.debug('Unregistered listener', { method: 'off', event });
  }

  disconnect() {
    this.socket.disconnect();
    this.logger.info('Socket disconnected manually', { method: 'disconnect' });
    this.eventQueue = [];
  }
}

================
File: services/getPrice.ts
================
import { JupiterPriceResponse } from '../core/types.js';
import { createLogger } from '../utils/logger.js';
import { ErrorCodes, TradeBotError } from '../utils/errors.js';

const logger = createLogger('PriceService');

export async function getPrice(mint: string): Promise<Record<string, number>> {
  if (mint.length === 0) {
    throw new TradeBotError('No mint addresses provided', ErrorCodes.INVALID_CONFIG.code);
  }

  try {
    const response = await fetch(`https://lite-api.jup.ag/price/v2?ids=${mint}`, {
      headers: { 'Accept': 'application/json' }
    });
    if (!response.ok) {
      logger.warn(`[PriceService] Invalid response from price API for mint ${mint}`);
      return { [mint]: 0 };
    }

    const data = await response.json() as JupiterPriceResponse;
    const prices: Record<string, number> = {};

    const priceValue = Number(data.data[mint].price);
    if (
      data.data &&
      data.data[mint] &&
      !isNaN(priceValue)
    ) {
      prices[mint] = priceValue;
    } else {
      logger.warn(`[PriceService] Price for mint '${mint}' not found or invalid.`);
      prices[mint] = 0;
    }

    logger.info(`[PriceService] Fetched prices: ${JSON.stringify(prices)}`);
    return prices;
  } catch (error) {
    logger.warn(`[PriceService] Failed to fetch price for mint ${mint}: ${error instanceof Error ? error.message : String(error)}`);
    return { [mint]: 0 };
  }
}

================
File: services/multiBotService.ts
================
import { MultiConfigRepository } from './configRepository.js';
import { createLogger } from '../utils/logger.js';
import { MultiConfig, TargetAmount } from '@prisma/client';

const logger = createLogger('MultiBotService');
/**
 * MultiBotService handles configuration management for multi-token trading bots.
 * 
 * Responsibilities:
 * - Manages multi-token bot configurations (add, update, delete, retrieve)
 * - Handles data validation and transformation for multi-token bots
 * - Manages target amounts for different tokens
 * - Provides error handling and logging for multi-token bot operations
 * - Maintains the connection between ConfigService and MultiConfigRepository
 */
export class MultiBotService {
  private repository: MultiConfigRepository;

  constructor() {
    this.repository = new MultiConfigRepository();
  }

  async addConfig(data: {
    botId: string;
    initialInputToken: string;
    initialInputAmount: number;
    targetGainPercentage: number;
    stopLossPercentage?: bigint | number;
    checkInterval?: number;
    targetAmounts: Record<string, number>;
  }): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    try {
      const { targetAmounts, ...configData } = data;
      const targetAmountEntries = Object.entries(targetAmounts).map(([tokenAddress, amount]) => ({
        tokenAddress,
        amount,
        configId: data.botId,
      }));
      return await this.repository.create({
        ...configData,
        stopLossPercentage: this.convertStopLossPercentage(configData.stopLossPercentage),
        targetAmounts: targetAmountEntries,
      });
    } catch (error) {
      logger.error(`Error adding multi config: ${error}`);
      throw new Error('Failed to add multi-bot configuration');
    }
  }

  async updateConfig(
    botId: string,
    data: Partial<MultiConfig & { targetAmounts: Record<string, number> }>
  ): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    try {
      const { targetAmounts, ...configData } = data;
      const targetAmountEntries = targetAmounts ? 
        Object.entries(targetAmounts).map(([tokenAddress, amount]) => ({
          tokenAddress,
          amount,
          configId: botId,
        })) : undefined;

      return await this.repository.update(botId, {
        ...configData,
        stopLossPercentage: configData.stopLossPercentage ? 
          this.convertStopLossPercentage(configData.stopLossPercentage) : 
          undefined,
        targetAmounts: targetAmountEntries,
      });
    } catch (error) {
      logger.error(`Error updating multi config: ${error}`);
      throw new Error('Failed to update multi-bot configuration');
    }
  }

  async deleteConfig(botId: string): Promise<MultiConfig & { targetAmounts: TargetAmount[] }> {
    try {
      return await this.repository.delete(botId);
    } catch (error) {
      logger.error(`Error deleting multi config: ${error}`);
      throw new Error('Failed to delete multi-bot configuration');
    }
  }

  async getConfig(botId: string): Promise<(MultiConfig & { targetAmounts: TargetAmount[] }) | null> {
    try {
      return await this.repository.findById(botId);
    } catch (error) {
      logger.error(`Error getting multi config: ${error}`);
      throw new Error('Failed to get multi-bot configuration');
    }
  }

  async getAllConfigs(): Promise<(MultiConfig & { targetAmounts: TargetAmount[] })[]> {
    try {
      return await this.repository.findAll();
    } catch (error) {
      logger.error(`Error getting all multi configs: ${error}`);
      throw new Error('Failed to get multi-bot configurations');
    }
  }

  private convertStopLossPercentage(value: bigint | number | null | undefined): number | null {
    if (value === null || value === undefined) return null;
    return typeof value === 'bigint' ? Number(value) : value;
  }
}

================
File: services/notificationService.ts
================
// src/services/notificationService.ts
import { Socket } from 'socket.io-client';
import { BotData, LogSwapArgs } from '../core/types.js';
import { formatPrice } from '../utils/helper.js';
import { createLogger } from '../utils/logger.js';
import { getPrice } from './getPrice.js';
import { createTransaction } from './transactionRepository.js';

const logger = createLogger('NotificationService');

export class NotificationService {

  constructor(
  ) {
  }

  private serializeForSocket(data: any): any {
    if (data === null || data === undefined) {
      return data;
    }

    if (typeof data === 'bigint') {
      return data.toString();
    }

    if (Array.isArray(data)) {
      return data.map(this.serializeForSocket.bind(this));
    }

    if (typeof data === 'object') {
      const result: any = {};
      for (const [key, value] of Object.entries(data)) {
        result[key] = this.serializeForSocket(value);
      }
      return result;
    }

    return data;
  }

  public emit(socket: Socket, event: string, data: any): void {
    if (socket) {
      socket.emit(event, this.serializeForSocket(data));
    }
  }

  public log(message: string, botId: string) {
    logger.info(`[Bot ${botId}] ${message}`);
  }

  async difference(socket: Socket, botData: BotData): Promise<void> {
    try {
      const { botId, inputMint, tokenInPrice, outputMint, tokenOutPrice, currentPrice, targetTrade } = botData;

      const ratio = tokenInPrice && tokenOutPrice ? (tokenInPrice / tokenOutPrice).toFixed(2) : '0';
      const differenceValue = ((targetTrade - currentPrice) / targetTrade) * 100;

      const message = {
        botId: botId.toString(),
        status: 'Running',
        inputMint,
        priceIn: formatPrice(tokenInPrice ?? 0),
        outputMint,
        priceOut: formatPrice(tokenOutPrice ?? 0),
        currentTrade: currentPrice ?? 0,
        targetTrade: targetTrade ?? 0,
        difference: differenceValue,
        ratio: Number(ratio),
        trades: 0
      };

      logger.info(`[Bot ${botId.toString()}] Difference Update: ${JSON.stringify(message)}`);

      if (socket) {
        socket.emit('bot:difference', message);
      }
    } catch (e) {
      logger.error('Error updating the UI:', e);
    }
  }

  async logSwap(args: LogSwapArgs): Promise<void> {
    const { botId, tokenIn, tokenInAmount, tokenOut, tokenOutAmount, txid } = args;

    try {
      const priceUSDIn = await getPrice(tokenIn);
      const priceUSDOut = await getPrice(tokenOut);

      const tokenInUSD = priceUSDIn[tokenIn] ? Number(priceUSDIn[tokenIn]) : 0;
      const tokenOutUSD = priceUSDOut[tokenOut] ? Number(priceUSDOut[tokenOut]) : 0;
      const totalValueUSD = tokenInUSD * Number(tokenInAmount);

      await createTransaction({
        botId,
        tokenIn,
        tokenInAmount,
        tokenOut,
        tokenOutAmount,
        tokenInUSD: tokenInUSD,
        tokenOutUSD: tokenOutUSD,
        totalValueUSD,
        txid,
        date: new Date()
      });

      logger.info(`[Bot ${botId}] Logged swap: ${tokenInAmount} ${tokenIn} -> ${tokenOutAmount} ${tokenOut}, TX: ${txid}`);
    } catch (error) {
      logger.error(`[Bot ${botId}] Error logging swap:`, error);
      throw error;
    }
  }
}

================
File: services/regularBotService.ts
================
import { RegularConfigRepository } from './configRepository.js';
import { createLogger } from '../utils/logger.js';
import { Config } from '@prisma/client';

const logger = createLogger('RegularBotService');
/**
 * RegularBotService handles configuration management for regular trading bots.
 * 
 * Responsibilities:
 * - Manages regular bot configurations (add, update, delete, retrieve)
 * - Handles data validation and transformation for regular bots
 * - Provides error handling and logging for regular bot operations
 * - Maintains the connection between ConfigService and RegularConfigRepository
 */
export class RegularBotService {
  private repository: RegularConfigRepository;

  constructor() {
    this.repository = new RegularConfigRepository();
  }

  async addConfig(data: {
    botId: string;
    initialInputToken: string;
    initialOutputToken: string;
    initialInputAmount: number;
    firstTradePrice: number;
    targetGainPercentage: number;
    stopLossPercentage?: bigint | number;
  }): Promise<Config> {
    try {
      const stopLoss = this.convertStopLossPercentage(data.stopLossPercentage);
      return await this.repository.create({ ...data, stopLossPercentage: stopLoss });
    } catch (error) {
      logger.error(`Error adding config: ${error}`);
      throw new Error('Failed to add configuration');
    }
  }

  async updateConfig(botId: string, data: Partial<Config>): Promise<Config> {
    try {
      if (data.stopLossPercentage) {
        data.stopLossPercentage = this.convertStopLossPercentage(data.stopLossPercentage);
      }
      return await this.repository.update(botId, data);
    } catch (error) {
      logger.error(`Error updating config: ${error}`);
      throw new Error('Failed to update configuration');
    }
  }

  async deleteConfig(botId: string): Promise<Config> {
    try {
      return await this.repository.delete(botId);
    } catch (error) {
      logger.error(`Error deleting config: ${error}`);
      throw new Error('Failed to delete configuration');
    }
  }

  async getConfig(botId: string): Promise<Config | null> {
    try {
      return await this.repository.findById(botId);
    } catch (error) {
      logger.error(`Error getting config: ${error}`);
      throw new Error('Failed to get configuration');
    }
  }

  async getAllConfigs(): Promise<Config[]> {
    try {
      return await this.repository.findAll();
    } catch (error) {
      logger.error(`Error getting all configs: ${error}`);
      throw new Error('Failed to get configurations');
    }
  }

  private convertStopLossPercentage(value: bigint | number | null | undefined): number | null {
    if (value === null || value === undefined) return null;
    return typeof value === 'bigint' ? Number(value) : value;
  }
}

================
File: services/repository.ts
================
import { PrismaClient } from '@prisma/client';

/**
 * Repository interface defining the contract for data access operations.
 * This interface ensures consistent data access patterns across different repositories.
 */
export interface Repository<T> {
  create(data: Partial<T>): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<T>;
  findById(id: string): Promise<T | null>;
  findAll(): Promise<T[]>;
}

/**
 * PrismaRepository provides a base implementation of the Repository interface using Prisma.
 * 
 * Responsibilities:
 * - Provides basic CRUD operations using Prisma
 * - Handles database connections
 * - Can be extended for specific entity types
 */
export abstract class PrismaRepository<T> implements Repository<T> {
  protected prisma: PrismaClient;
  protected model: any; // Prisma model type

  constructor(model: any) {
    this.prisma = new PrismaClient();
    this.model = model;
  }

  async create(data: Partial<T>): Promise<T> {
    return this.model.create({ data });
  }

  async update(id: string, data: Partial<T>): Promise<T> {
    return this.model.update({
      where: { botId: id },
      data
    });
  }

  async delete(id: string): Promise<T> {
    return this.model.delete({
      where: { botId: id }
    });
  }

  async findById(id: string): Promise<T | null> {
    return this.model.findUnique({
      where: { botId: id }
    });
  }

  async findAll(): Promise<T[]> {
    return this.model.findMany();
  }
}

================
File: services/rpcFactory.ts
================
import { createRpc, createSolanaRpcApi, createDefaultRpcTransport, createSolanaRpcSubscriptions, mainnet, ClusterUrl, SolanaRpcApiMainnet, Rpc} from "@solana/kit";
import  { createLogger } from "../utils/logger.js";
import { RpcClients } from "../core/types.js";
import { replacer } from "../utils/replacer.js";

const logger = createLogger("RpcFactory");

export async function createRpcClients(config: { solanaEndpoint: string; wssEndpoint: ClusterUrl }): Promise<RpcClients> {
  logger.info(`[RpcFactory] Creating RPC clients with solanaEndpoint: ${config.solanaEndpoint}, wssEndpoint: ${config.wssEndpoint}`);

  if (!config.solanaEndpoint || !config.solanaEndpoint.startsWith("http")) {
    logger.error(`[RpcFactory] Invalid solanaEndpoint: ${config.solanaEndpoint}`);
    throw new Error("Invalid solanaEndpoint: must be an HTTP/HTTPS URL");
  }
  if (!config.wssEndpoint || !config.wssEndpoint.startsWith("ws")) {
    logger.error(`[RpcFactory] Invalid wssEndpoint: ${config.wssEndpoint}`);
    throw new Error("Invalid wssEndpoint: must be a WebSocket URL");
  }

  try {
    logger.info("[RpcFactory] Creating RPC API...");
    const rpcApi = createSolanaRpcApi<SolanaRpcApiMainnet>({ defaultCommitment: "confirmed" });
    if (!rpcApi) {
      logger.error("[RpcFactory] Failed to create RPC API");
      throw new Error("Failed to create RPC API");
    }
    logger.info("[RpcFactory] RPC API created successfully");

    logger.info("[RpcFactory] Creating JSON-RPC transport...");
    const jsonRpcTransport = createDefaultRpcTransport({ url: config.solanaEndpoint });
    if (!jsonRpcTransport) {
      logger.error("[RpcFactory] Failed to create JSON-RPC transport");
      throw new Error("Failed to create JSON-RPC transport");
    }
    logger.info("[RpcFactory] JSON-RPC transport created successfully");

    logger.info("[RpcFactory] Creating RPC client...");
    const rpc = createRpc({ api: rpcApi, transport: jsonRpcTransport });
    if (!rpc || typeof rpc.getTokenAccountsByOwner !== "function") {
      logger.error("[RpcFactory] Failed to create valid RPC client");
      throw new Error("Failed to create valid RPC client");
    }
    logger.info("[RpcFactory] RPC client created successfully");

    logger.info("[RpcFactory] Creating subscriptions client...");
    const subscriptions = createSolanaRpcSubscriptions(mainnet(config.wssEndpoint));
    if (!subscriptions || typeof subscriptions.signatureNotifications !== "function") {
      logger.error("[RpcFactory] Failed to create valid subscriptions client");
      throw new Error("Failed to create valid subscriptions client");
    }
    logger.info("[RpcFactory] Subscriptions client created successfully");

    // Test RPC client connectivity
    logger.info("[RpcFactory] Testing RPC client connectivity...");
    try {
      const blockhash = await rpc.getLatestBlockhash().send();
      logger.info(`[RpcFactory] RPC test successful: ${JSON.stringify(blockhash, replacer)}`);
    } catch (err) {
      logger.warn(`[RpcFactory] RPC connectivity test failed: ${err instanceof Error ? err.message : String(err)}`);
      throw new Error("RPC connectivity test failed");
    }

    return { rpc, subscriptions };
  } catch (err) {
    logger.error(`[RpcFactory] Error creating RPC clients: ${err instanceof Error ? err.stack : String(err)}`);
    throw err;
  }
}

================
File: services/socketService.ts
================
import { Socket } from 'socket.io-client';
import { serializeForSocket } from '../utils/seralize.js';
import { createLogger } from '../utils/logger.js';

export class SocketService {
  private logger = createLogger('SocketService');

  constructor(private socket: Socket) {}

  emit(event: string, data: any): void {
    this.logger.info(`Emitting socket event: ${event}`);
    this.socket.emit(event, serializeForSocket(data));
  }
}

================
File: services/tokenDataService.ts
================
import { TokenInfo } from '../core/types.js';
import prisma from '../utils/prismaClient.js';
import { createLogger } from '../utils/logger.js';
import { handleError } from '../utils/errorHandler.js';
import { TradeBotError, ErrorCodes } from '../utils/errors.js';

const logger = createLogger('TokenDataService');

const UPDATE_INTERVAL = 24 * 60 * 60 * 1000;
const RATE_LIMIT_INTERVAL = 60 * 1000;
const BATCH_SIZE = 50; // Process tokens in batches

let lastApiCall: number | null = null;

export async function fetchTokenList(forceUpdate: boolean = false) {
  logger.debug('Checking token list update', { method: 'fetchTokenList', forceUpdate });
  try {
    const lock = await prisma.metadata.findUnique({
      where: { key: 'token_update_lock' },
    });

    if (lock?.value === 'locked' && !forceUpdate) {
      logger.debug('Token list update already in progress, skipping', { method: 'fetchTokenList' });
      return;
    }

    await prisma.metadata.upsert({
      where: { key: 'token_update_lock' },
      update: { value: 'locked' },
      create: { key: 'token_update_lock', value: 'locked' },
    });

    const now = Date.now();
    if (lastApiCall && now - lastApiCall < RATE_LIMIT_INTERVAL && !forceUpdate) {
      logger.debug('Rate limit enforced, skipping update', { method: 'fetchTokenList' });
      await prisma.metadata.delete({ where: { key: 'token_update_lock' } });
      return;
    }

    const lastUpdate = await prisma.token.findFirst({
      orderBy: { updatedAt: 'desc' },
      select: { updatedAt: true },
    });

    const currentTime = new Date();
    const lastUpdateTime = lastUpdate?.updatedAt || new Date(0);
    const shouldUpdate =
      forceUpdate || !lastUpdate || currentTime.getTime() - lastUpdateTime.getTime() > UPDATE_INTERVAL;

    if (!shouldUpdate) {
      logger.info('Token list is up to date, skipping update', { method: 'fetchTokenList' });
      await prisma.metadata.delete({ where: { key: 'token_update_lock' } });
      return;
    }

    logger.info('Fetching latest token data from Jupiter API', { method: 'fetchTokenList' });
    const response = await fetch('https://lite-api.jup.ag/tokens/v1/tagged/verified');
    if (!response.ok) {
      handleError(
        null,
        `Failed to fetch token list: HTTP ${response.status}`,
        ErrorCodes.API_ERROR.code,
        { method: 'fetchTokenList', status: response.status },
      );
    }
    const lstTaggedResponse = await response.json();

    if (Array.isArray(lstTaggedResponse)) {
      logger.info('Updating token list', { method: 'fetchTokenList', tokenCount: lstTaggedResponse.length });
      const tokens = lstTaggedResponse as TokenInfo[];
      for (let i = 0; i < tokens.length; i += BATCH_SIZE) {
        const batch = tokens.slice(i, i + BATCH_SIZE);
        logger.debug('Processing token batch', { method: 'fetchTokenList', batchSize: batch.length, batchIndex: i });
        await Promise.all(
          batch.map((token) =>
            updateTokenData(token).catch((error) => {
              handleError(error, 'Failed to update token data', ErrorCodes.DB_ERROR.code, {
                method: 'updateTokenData',
                address: token.address,
              });
            }),
          ),
        );
      }
    } else {
      logger.info('Updating single token', { method: 'fetchTokenList' });
      await updateTokenData(lstTaggedResponse as TokenInfo);
    }

    logger.info('Token list updated successfully', { method: 'fetchTokenList' });
    lastApiCall = now;
  } catch (error) {
    handleError(error, 'Failed to fetch token list', ErrorCodes.API_ERROR.code, { method: 'fetchTokenList' });
  } finally {
    await prisma.metadata.delete({ where: { key: 'token_update_lock' } });
  }
}

export async function updateTokenData(tokenInfo: TokenInfo) {
  logger.debug('Updating token data', { method: 'updateTokenData', address: tokenInfo.address }); // Changed to debug
  try {
    if (!tokenInfo.address) {
      throw new TradeBotError('Token address is required', ErrorCodes.INVALID_CONFIG.code, {
        method: 'updateTokenData',
        tokenInfo,
      });
    }

    const existingToken = await prisma.token.findUnique({
      where: { address: tokenInfo.address },
    });

    const tokenData = existingToken
      ? await prisma.token.update({
          where: { id: existingToken.id },
          data: {
            name: tokenInfo.name,
            symbol: tokenInfo.symbol,
            decimals: tokenInfo.decimals,
            logoURI: tokenInfo.logoURI,
            updatedAt: new Date(),
          },
        })
      : await prisma.token.create({
          data: {
            address: tokenInfo.address,
            name: tokenInfo.name,
            symbol: tokenInfo.symbol,
            decimals: tokenInfo.decimals,
            logoURI: tokenInfo.logoURI,
            updatedAt: new Date(),
          },
        });

    logger.debug('Token data updated successfully', { method: 'updateTokenData', address: tokenInfo.address }); // Changed to debug
    return tokenData;
  } catch (error) {
    handleError(error, 'Failed to update token data', ErrorCodes.DB_ERROR.code, {
      method: 'updateTokenData',
      address: tokenInfo.address,
    });
  }
}
export async function getTokenDataList() {
  logger.info('Retrieving token data list', { method: 'getTokenDataList' });
  try {
    const tokenDataList = await prisma.token.findMany();
    logger.info('Token data list retrieved', { method: 'getTokenDataList', count: tokenDataList.length });
    return tokenDataList;
  } catch (error) {
    handleError(error, 'Failed to fetch token data list', ErrorCodes.DB_ERROR.code, { method: 'getTokenDataList' });
  }
}

export async function getSingleTokenData(address: string) {
  logger.info('Retrieving single token data', { method: 'getSingleTokenData', address });
  try {
    if (!address) {
      throw new TradeBotError('Token address is required', ErrorCodes.INVALID_CONFIG.code, {
        method: 'getSingleTokenData',
      });
    }

    const tokenData = await prisma.token.findUnique({
      where: { address },
    });
    logger.info('Single token data retrieved', { method: 'getSingleTokenData', address, found: !!tokenData });
    return tokenData;
  } catch (error) {
    handleError(error, 'Failed to fetch single token data', ErrorCodes.DB_ERROR.code, {
      method: 'getSingleTokenData',
      address,
    });
  }
}

================
File: services/tradeService.ts
================
import { QuoteGetRequest, QuoteResponse } from "../core/types.js";
import { ErrorCodes,TradeBotError } from "../utils/errors.js";
import { handleError } from "../utils/errorHandler.js";
import { getAddressFromPublicKey, getTransactionDecoder, signTransaction, assertTransactionIsFullySigned, getSignatureFromTransaction, SolanaRpcSubscriptionsApi, RpcSubscriptions, sendAndConfirmTransactionFactory, Rpc, Address, SolanaRpcApiMainnet, Signature, address } from "@solana/kit";
import dotenv from "dotenv";
import { PublicKey } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from "@solana/spl-token";
import  { createLogger } from "../utils/logger.js";
import NodeCache from 'node-cache';
import { replacer } from "../utils/replacer.js";

dotenv.config();

const logger = createLogger('TradeService');
const cache = new NodeCache({ stdTTL: 300 }); // 5-minute TTL


export class TradeService {
  private readonly baseUrl: string = "https://lite-api.jup.ag/swap/v1";

  constructor(
    private botId: string,
    private readonly wallet: CryptoKeyPair,
    private readonly rpc: Rpc<SolanaRpcApiMainnet>,
    private readonly subscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>,
    public postTransactionProcessing: (route: QuoteResponse, signature: string) => Promise<void>,
    public setwaitingForConfirmation: (flag: boolean) => void
  ) {
   if (!rpc) {
      handleError(null, 'RPC client is undefined', ErrorCodes.INVALID_CONFIG.code, { botId });
    }
    if (!subscriptions) {
      handleError(null, 'Subscriptions client is undefined', ErrorCodes.INVALID_CONFIG.code, { botId });
    }
    if (!wallet.publicKey) {
      handleError(null, 'Wallet public key is undefined', ErrorCodes.WALLET_ERROR.code, { botId });
    }
  }

  async getFilteredTokenAccounts(wallet: Address, mint: Address): Promise<string> {
    const cacheKey = `${wallet}:${mint}`;
    const cached = cache.get<string>(cacheKey);
    if (cached) {
      logger.info(`[TradeService] Returning cached token account: ${cached}`);
      return cached;
    }
    logger.info(`[TradeService] Fetching filtered token accounts for wallet: ${wallet}, mint: ${mint}`);
    try {
      const response = await this.rpc.getTokenAccountsByOwner(address(wallet), { mint: mint }, { encoding: "jsonParsed" }).send();
      const accountData = response.value[0]?.account?.data?.parsed?.info;
      const uiAmountString = accountData?.tokenAmount?.uiAmountString;
      logger.warn(`[TradeService] Available balance: ${uiAmountString}`);
      if (!response.value || response.value.length === 0) {
        throw new TradeBotError(`No token account found for mint ${mint}`, ErrorCodes.TOKEN_ACCOUNT_ERROR.code, { mint });
      }

      const tokenAccount = response.value[0].pubkey;
      if (!tokenAccount || typeof tokenAccount !== 'string') {
        throw new TradeBotError(`Invalid token account public key`, ErrorCodes.TOKEN_ACCOUNT_ERROR.code, { mint, pubkey: tokenAccount });
      }

      logger.warn(`[TradeService] Selected token account: ${tokenAccount}`);
      cache.set(cacheKey, tokenAccount);
      return tokenAccount;
    } catch (error) {
      handleError(error, `Error fetching token accounts for wallet ${wallet} and mint ${mint}`, ErrorCodes.TOKEN_ACCOUNT_ERROR.code, { wallet, mint });
    }
  }
  async getTokenAccountBalance(mint: string): Promise<string> {
    if (!this.wallet || !this.wallet.publicKey) {
      throw new Error("Wallet is not initialized or public key is missing");
    }
    try {
      const publicKeyString = await getAddressFromPublicKey(this.wallet.publicKey);
      const wallet = publicKeyString;

      const tokenAccount = await this.rpc
        .getTokenAccountsByOwner(wallet, { mint: mint as Address }, { encoding: "jsonParsed" })
        .send();
      if (!tokenAccount.value || tokenAccount.value.length === 0) {
        throw new Error(`No token account found for mint ${mint}`);
      }

      const balance = await this.rpc.getTokenAccountBalance(tokenAccount.value[0].pubkey).send();
      return balance.value.uiAmountString || "0";
    } catch (err) {
      logger.error(`[TradeService] Error fetching token balance: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  async signatureSub(signature: Signature): Promise<void> {
    try {
      logger.warn(`[TradeService] Subscribing to signature: ${signature}`);
      this.subscriptions.signatureNotifications(signature, { enableReceivedNotification: true });
    } catch (err) {
      logger.error(`[TradeService] Error subscribing to signature: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  async getSwap(quoteResponse: QuoteResponse, userPublicKey: Address, feeAccount?: Address): Promise<any> {
    logger.warn(`[TradeService] Initiating swap with quote: ${JSON.stringify(quoteResponse, replacer)}`);
    try {
      const swapResponse = await (
        await fetch(`${this.baseUrl}/swap`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            quoteResponse,
            userPublicKey,
            feeAccount,
            wrapAndUnwrapSol: true,
            dynamicComputeUnitLimit: true,
            dynamicSlippage: true,
            prioritizationFeeLamports: {
              priorityLevelWithMaxLamports: {
                maxLamports: 1_000_000,
                priorityLevel: "veryHigh",
              },
            },
          }),
        })
      ).json();
      logger.warn(`[TradeService] Swap response: ${JSON.stringify(swapResponse, replacer)}`);
      return swapResponse;
    } catch (err) {
      logger.error(`[TradeService] Error executing swap: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  public async ata(quoteRequest: QuoteResponse): Promise<string> {
    try {
      const pubWallet = "8sZ5yWf1TPk86ehw7ekPMcrXr76YXgMnLwWe8ZLRjDqz"
      logger.warn(`🔍 [TradeService] Checking ATA for mint: ${quoteRequest.outputMint}`);

      const ata = await getAssociatedTokenAddress(
        new PublicKey(quoteRequest.outputMint),
        new PublicKey(pubWallet),
        false,
        TOKEN_PROGRAM_ID,
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
      logger.warn(`✅ [TradeService] ATA: ${ata.toBase58()}`);
      return ata.toBase58();
    } catch (err) {
      logger.error(`[TradeService] Error fetching ATA: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  public async getQuote2(quoteRequest: QuoteGetRequest): Promise<QuoteResponse | undefined> {
    try {
      if (!quoteRequest.inputMint || !quoteRequest.outputMint || !quoteRequest.amount) {
        throw new Error("Missing required fields: inputMint, outputMint, or amount");
      }

      const url = new URL(`${this.baseUrl}/quote`);
      url.searchParams.append("inputMint", quoteRequest.inputMint);
      url.searchParams.append("outputMint", quoteRequest.outputMint);
      url.searchParams.append("amount", quoteRequest.amount.toString());
      url.searchParams.append("autoSlippage", (quoteRequest.autoSlippage ?? true).toString());
      url.searchParams.append("maxAutoSlippageBps", (quoteRequest.maxAutoSlippageBps ?? 50).toString());
      url.searchParams.append("platformFeeBps", (quoteRequest.platformFeeBps ?? 10).toString());

      const response = await fetch(url.toString(), {
        headers: { Accept: "application/json" },
        method: "GET",
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new TradeBotError(
          `HTTP error fetching quote: ${response.status} ${response.statusText} - ${errorText}`,
          ErrorCodes.QUOTE_FETCH_ERROR.code,
          { 
            status: response.status,
            statusText: response.statusText,
            url: url.toString(),
            errorText
          }
        );
      }

      const quote = await response.json() as QuoteResponse;
      if (!quote || !quote.outAmount) {
        throw new TradeBotError('Invalid quote response: Missing outAmount', ErrorCodes.QUOTE_FETCH_ERROR.code, { response: quote });
      }

      return quote;
    } catch (err) {
      const error = err instanceof TradeBotError ? err : new TradeBotError(
        `Failed to fetch quote: ${err instanceof Error ? err.message : String(err)}`,
        ErrorCodes.QUOTE_FETCH_ERROR.code,
        { quoteRequest }
      );
      logger.error(`[TradeService] ${error.message}`, error);
      throw error;
    }
  }

  public async evaluateQuoteAndSwap(quote: QuoteResponse, thresholdPrice: number, forceSwap: boolean = false): Promise<boolean> {
    if (!quote || !quote.outAmount) {
      throw new TradeBotError('Invalid quote response: Missing outAmount', ErrorCodes.QUOTE_FETCH_ERROR.code, { response: quote });
    }

    const currentPrice = parseInt(quote.outAmount);

    if (forceSwap || currentPrice >= thresholdPrice) {
      try {
        this.setwaitingForConfirmation(true);
        await this.executeSwap(quote);
        return true;
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : 'Failed to execute swap';
        logger.error(`[TradeService] ${errorMsg}`);
        return false;
      }
    }
    return false;
  }

  private async executeSwap(route: QuoteResponse): Promise<void> {
    const abortController = new AbortController();
    try {
      logger.warn(`📡 [TradeService] Starting swap execution...`);

      const pubKey = await getAddressFromPublicKey(this.wallet.publicKey);
      if (!pubKey) {
        throw new TradeBotError('Error fetching public key', ErrorCodes.WALLET_ERROR.code);
      }

      const feeAccount = await this.ata(route);

      const tx = await this.getSwap(route, pubKey, feeAccount as Address);
      const swapTransactionBuf = Buffer.from(tx.swapTransaction, "base64");
      if (!Buffer.isBuffer(swapTransactionBuf)) throw new Error("Invalid transaction buffer");

      const transactionDecoder = getTransactionDecoder();
      const swapTransaction = transactionDecoder.decode(swapTransactionBuf);
      const signedTransaction = await signTransaction([this.wallet], swapTransaction);
      assertTransactionIsFullySigned(signedTransaction);

      const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
        rpc: this.rpc,
        rpcSubscriptions: this.subscriptions,
      });
      const latestBlockhash = await this.rpc.getLatestBlockhash().send();
      const signedTransactionWithLifetime = {
        ...signedTransaction,
        lifetimeConstraint: {
          blockhash: latestBlockhash.value.blockhash,
          lastValidBlockHeight: latestBlockhash.value.lastValidBlockHeight,
        },
      };

      const signature = getSignatureFromTransaction(signedTransactionWithLifetime);
      logger.warn(`📜 [TradeService] Transaction signature: ${signature}`);

      await sendAndConfirmTransaction(signedTransactionWithLifetime, {
        commitment: "confirmed",
        abortSignal: abortController.signal,
        maxRetries: BigInt(3),
      });

      logger.warn(`✅ [TradeService] Transaction confirmed: ${signature}`);
      await this.postTransactionProcessing(route, signature);
      logger.warn(`✅ [TradeService] Post-transaction processing completed`);

      this.setwaitingForConfirmation(false);
    } catch (err) {
      const error = err instanceof TradeBotError ? err : new TradeBotError(
        err instanceof Error && err.name === "AbortError"
          ? `Transaction timed out: ${err.message}`
          : `Swap execution failed: ${err instanceof Error ? err.message : String(err)}`,
        ErrorCodes.SWAP_EXECUTION_ERROR.code,
        { route }
      );
      logger.error(`❌ [TradeService] ${error.message}`, error);
      this.setwaitingForConfirmation(false);
      throw error;
    }
  }
}

================
File: services/transactionRepository.ts
================
import prisma from '../utils/prismaClient.js';
import { TradeBotError, ErrorCodes } from '../utils/errors.js';
import { LogSwapArgs } from '../core/types.js';
import { createLogger } from '../utils/logger.js';
import { handleError } from '../utils/errorHandler.js';

const logger = createLogger('TransactionRepository');

   export const createTransaction = async(data: LogSwapArgs) => {
    try {
      const transaction = await prisma.transaction.create({ data });
      logger.info(`[TransactionRepository] Created transaction: ${JSON.stringify(transaction)}`);
      return transaction;
    } catch (error) {
      const err = new TradeBotError(
        `Error logging swap to DB: ${error instanceof Error ? error.message : String(error)}`,
        ErrorCodes.DB_ERROR.code,
        { botId: data.botId, txid: data.txid }
      );
      logger.error(err.message, err);
      throw err;
    } 
  }

  export const getTransactions = async() => {
    try {
      let transaction = []
      const transactions = await prisma.transaction.findMany({
        orderBy: {
          date: 'desc',
        },
      });
      for (const tx of transactions) {
        transaction.push({
          ...tx,
        });
      }
      return transaction;
    } catch (error) {
     handleError(error, 'Failed to fetch transactions', ErrorCodes.DB_ERROR.code)    
    }
  }

================
File: services/transactionService.ts
================
import { Socket } from 'socket.io-client';
import { createLogger } from '../utils/logger.js';
import { getTransactions } from './transactionRepository.js';

const logger = createLogger('TransactionService');

export class TransactionService {

  constructor(
  ) {
  }

  public async handleGetTransactions(): Promise<any> {
    try {
      logger.info('Fetching transactions from repository');
      const transactions = await getTransactions();
      logger.info(`Retrieved ${transactions.length} transactions`);
      return { transactions };
    } catch (error) {
      logger.error('Error fetching transactions:', error);
      throw new Error('Failed to fetch transactions');
    }
  }

  public async broadcastTransactionUpdate(socket: Socket): Promise<void> {
    try {
      const transactions = await getTransactions();
      socket.emit('transactionUpdate', { transactions });
    } catch (error) {
      logger.error('Error broadcasting transaction update:', error);
    }
  }
}

================
File: utils/errorHandler.ts
================
// src/utils/errorHandler.ts
import { createLogger } from './logger.js';
import { TradeBotError, ErrorCode, ErrorCodes } from './errors.js';

/**
 * Error handler utility for the trading bot.
 * It standardizes error handling by creating a TradeBotError
 * and logging it with additional metadata.
 */
const logger = createLogger('ErrorHandler');

export function handleError<T>(
  error: unknown,
  defaultMessage: string,
  defaultCode: ErrorCode,
  metadata: Record<string, any> = {}
): never {
  const tradeBotError = error instanceof TradeBotError
    ? error
    : new TradeBotError(
        defaultMessage,
        defaultCode,
        { ...metadata, originalError: error instanceof Error ? error.message : String(error) }
      );
  logger.error(tradeBotError.message, { ...tradeBotError.toJSON(), metadata });
  throw tradeBotError;
}

================
File: utils/errors.ts
================
export const ErrorCodes = {
  QUOTE_FETCH_ERROR: { code: 'QUOTE_FETCH_ERROR', description: 'Failed to fetch quote from API' },
  SWAP_EXECUTION_ERROR: { code: 'SWAP_EXECUTION_ERROR', description: 'Failed to execute swap transaction' },
  DB_ERROR: { code: 'DB_ERROR', description: 'Database operation failed' },
  WALLET_ERROR: { code: 'WALLET_ERROR', description: 'Wallet-related error' },
  TOKEN_ACCOUNT_ERROR: { code: 'TOKEN_ACCOUNT_ERROR', description: 'Error with token account' },
  INVALID_CONFIG: { code: 'INVALID_CONFIG', description: 'Invalid bot configuration' },
  API_ERROR: { code: 'API_ERROR', description: 'General API error' },
  BOT_INIT_ERROR: { code: 'BOT_INIT_ERROR', description: 'Failed to initialize bot' },
  BOT_STOP_ERROR: { code: 'BOT_STOP_ERROR', description: 'Failed to stop bot' },
  NOT_FOUND: { code: 'NOT_FOUND', description: 'Resource not found' },
  CONFIG_CREATION_FAILED: { code: 'CONFIG_CREATION_FAILED', description: 'Failed to create configuration' },
  CONFIG_UPDATE_FAILED: { code: 'CONFIG_UPDATE_FAILED', description: 'Failed to update configuration' },
  UNKNOWN_ERROR: { code: 'UNKNOWN_ERROR', description: 'Unexpected error' },
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes]['code'];

export class TradeBotError<T = unknown> extends Error {
  constructor(
    message: string,
    public code: ErrorCode,
    public details?: T
  ) {
    super(message);
    this.name = 'TradeBotError';
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, TradeBotError);
    }
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      details: this.details,
      stack: this.stack,
    };
  }
}

================
File: utils/helper.ts
================
// tokenService.ts
import NodeCache from "node-cache";
import { ENV } from "../config/index.js";
import prisma from "./prismaClient.js";
import { createLogger } from "./logger.js";

const logger = createLogger("TokenService");

/**
 * Fetches the decimals for a token by its name.
 *
 * @param tokenName - The name of the token.
 * @returns An object containing the decimals of the token.
 */
export async function getTokenDecimalsByName(tokenName: string): Promise<{ decimals: number }> {
  try {
    const tokens = await prisma.token.findFirst({
      where: {
        OR: [
          { symbol: { equals: tokenName } },
          { name: { equals: tokenName } }
        ]
      },
      select: { decimals: true },
    });

    if (!tokens) {
      throw new Error(`Token with name "${tokenName}" not found.`);
    }

    return { decimals: tokens.decimals };
  } catch (error) {
    throw error;
  }
}

/**
 * Calculates the token value with decimals applied, using the token's blockchain address.
 *
 * @param address - The blockchain address of the token.
 * @param value - The raw token value without decimals.
 * @returns The token value with decimals applied.
 * @throws Will throw an error if the token is not found or a database error occurs.
 */
export async function getTokenDecimalsByAddress(address: string, value: number): Promise<number> {
  try {
    const token = await prisma.token.findUnique({
      where: { address },
    });

    if (!token) {
      throw new Error(`Token with address "${address}" not found.`);
    }

    const tokenValue = value / Math.pow(10, token.decimals);
    return parseFloat(tokenValue.toFixed(2));
  } catch (error) {
    throw error;
  }
}

export async function getTokenDecimalsByAddressRaw(address: string): Promise<number> {
  try {
    const token = await prisma.token.findUnique({
      where: { address },
    });

    if (!token) {
      throw new Error(`Token with address "${address}" not found.`);
    }

    return token.decimals;
  } catch (error) {
    throw error;
  }
}

export async function addTokenDecimalsByAddress(address: string, value: number): Promise<number> {
  try {
    const token = await prisma.token.findUnique({
      where: { address },
    });

    if (!token) {
      throw new Error(`Token with address "${address}" not found.`);
    }

    const tokenValue = value * Math.pow(10, token.decimals);
    return tokenValue;
  } catch (error) {
    throw error;
  }
}

interface dexScreenerRewquest {
  "schemaVersion": string,
  "pairs": [
    {
      "chainId": string,
      "dexId": string,
      "url": string,
      "pairAddress": string,
      "labels": [
        string
      ],
      "baseToken": {
        "address": string,
        "name": string,
        "symbol": string
      },
      "quoteToken": {
        "address": string,
        "name": string,
        "symbol": string
      },
      "priceNative": string,
      "priceUsd": string,
      "liquidity": {
        "usd": number,
        "base": number,
        "quote": number
      },
      "fdv": number,
      "marketCap": number,
      "pairCreatedAt": number,
      "info": {
        "imageUrl": string,
        "websites": [
          {
            "url": string
          }
        ],
        "socials": [
          {
            "platform": string,
            "handle": string
          }
        ]
      },
      "boosts": {
        "active": number
      }
    }
  ]
}
/**
 * Fetches the name of a token by its blockchain address.
 *
 * @param address - The blockchain address of the token.
 * @returns The name of the token.
 * @throws Will throw an error if the token is not found or a database error occurs.
 */
export async function getTokenName(address: string): Promise<string> {
  try {
    const tokens = await prisma.token.findMany({
      where: { address },
    });

    if (!tokens.length) {
      logger.warn(`[TokenService] Token with address ${address} not in strict list. Checking if it's a token account`);
      try {
        const accountInfo = await fetch(`${ENV.solanaEndpoint}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "getAccountInfo",
            params: [address, { encoding: "jsonParsed" }],
          }),
        }).then((res) => res.json());
        if (accountInfo.result && accountInfo.result.value && accountInfo.result.value.data.parsed.info.mint) {
          const mint = accountInfo.result.value.data.parsed.info.mint;
          const dexScreener = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`, {
            method: "GET",
            headers: {},
          });
          const data: dexScreenerRewquest = await dexScreener.json();
          if (data && data.pairs && data.pairs.length > 0) {
            const name = data.pairs[0].baseToken.name;
            if (name) {
              logger.info(`[TokenService] Found token name ${name} for mint ${mint} via DexScreener`);
              return name;
            }
          }
        }
        logger.error(`[TokenService] No mint data or DexScreener response for account ${address}`);
        return address;
      } catch (dexError) {
        logger.error(`[TokenService] Error fetching account info or DexScreener for ${address}: ${dexError instanceof Error ? dexError.message : String(dexError)}`);
        return address;
      }
    } else {
      logger.info(`[TokenService] Found token name ${tokens[0].name} for address ${address} in database`);
      return tokens[0].name;
    }
  } catch (error) {
    logger.error(`[TokenService] Error getting token name for address ${address}: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/**
 * Formats a numeric price to 4 decimal places.
 *
 * @param price - The numeric price to format.
 * @returns The formatted price or undefined if the price is invalid.
 */
export function formatPrice(price: number): number | undefined {
  try {
    if (price < 0) {
      throw new Error("Price cannot be negative");
    }
    return parseFloat(price.toFixed(4));
  } catch (error) {
    return undefined;
  }
}

/**
 * Formats a numeric value as a percentage with 2 decimal places.
 *
 * @param value - The numeric value to format.
 * @returns The formatted percentage value.
 */
export function formatPercentage(value: number): number {
  return parseFloat(value.toFixed(2));
}
const cache = new NodeCache({ stdTTL: 300 }); // 5-minute TTL
export async function getTokenList(): Promise<{ name: string; address: string; symbol: string }[]> {
  const cached = cache.get('tokenList');
  if (Array.isArray(cached)) {
    return cached as { name: string; address: string; symbol: string }[];
  }
  try {
    const tokens = await prisma.token.findMany({
      select: { name: true, address: true, symbol: true },
    });
    if (tokens.length === 0) {
      logger.warn('No tokens found in the database. Please seed the token table.');
    }
    const tokenList = tokens.map(token => ({
      name: token.name,
      address: token.address,
      symbol: token.symbol,
    }));
    cache.set('tokenList', tokenList);
    return tokenList;
  } catch (error) {
    logger.error(`Failed to fetch token list: ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}


export async function getTokenAddressByName(name: string): Promise<string> {
  try {
    if (!name || typeof name !== 'string') {
      logger.error(`Invalid input to getTokenAddressByName: ${JSON.stringify(name)}`);
      throw new Error('Token name must be a non-empty string');
    }
    const lowerName = name.toLowerCase();
    const token = await prisma.token.findFirst({
      where: {
        OR: [
          { name: { contains: lowerName } },
          { symbol: { contains: lowerName } },
        ],
      },
      select: { address: true },
    });
    if (!token) {
      logger.error(`Token not found for input: ${name}`);
      throw new Error(`Token ${name} not found`);
    }
    return token.address;
  } catch (error) {
    logger.error(`getTokenAddressByName error: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

export function shortenUUID(uuid: string): string {
  // Take first 8 characters and last 4 characters
  return `${uuid.slice(0, 8)}`;
}

================
File: utils/logger.ts
================
import winston from 'winston';
import path from 'path';
import fs from 'fs';
import DailyRotateFile from 'winston-daily-rotate-file';

// Ensure logs directory exists
const logsDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

const customLevels = {
  levels: {
    error: 0,
    warn: 1,
    info: 2,
    debug: 3, // Added debug level
    component: 4,
    fetching: 5,
    balance: 6,
    trade: 7,
    separator: 8,
  },
  colors: {
    info: 'green',
    warn: 'yellow',
    error: 'red',
    component: 'cyan',
    fetching: 'blue',
    balance: 'magenta',
    trade: 'bold green',
    separator: 'gray',
  },
};

winston.addColors(customLevels.colors);

// Structured JSON format for file logging
const jsonFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' }),
  winston.format.json()
);

// Pretty-printed format for console (for development)
const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.printf(({ level, message, timestamp, service = 'unknown', ...metadata }) => {
    const componentTagMatch = typeof message === 'string' ? message.match(/^\[.*?\]/) : null;
    const componentTag = componentTagMatch ? componentTagMatch[0] : '';
    const messageBody = componentTagMatch
      ? (message as string).slice(componentTag.length).trim()
      : message;

    let errorDetails = '';
    if (metadata.error) {
      errorDetails = `\n  Details: ${JSON.stringify(metadata.error, null, 2)}`;
    }

    return `${timestamp} [${level.toUpperCase()}] [${service}] ${componentTag} ${messageBody}${errorDetails}`;
  })
);

export interface LogMetadata {
  service?: string;
  botId?: string;
  method?: string;
  error?: Record<string, any>;
  [key: string]: any;
}

export const logger = winston.createLogger({
  levels: customLevels.levels,
  level: process.env.LOG_LEVEL || 'debug', // Allow debug logs
  format: winston.format.combine(winston.format.errors({ stack: true }), jsonFormat),
  transports: [
    new winston.transports.Console({
      format: consoleFormat,
      silent: true,
    }),
    new winston.transports.File({
      filename: path.join(logsDir, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
      tailable: true,
    }),
    new winston.transports.File({
      filename: path.join(logsDir, 'combined.log'),
      maxsize: 5242880,
      maxFiles: 5,
      tailable: true,
    }),
    new DailyRotateFile({
      filename: path.join(logsDir, 'daily-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '5m',
      maxFiles: '14d',
      format: jsonFormat,
    }),
  ],
});

export type CustomLogger = winston.Logger & {
  info: (message: string, meta?: LogMetadata) => void;
  warn: (message: string, meta?: LogMetadata) => void;
  error: (message: string, meta?: LogMetadata) => void;
  debug: (message: string, meta?: LogMetadata) => void; // Added debug
};

export function createLogger(service: string): CustomLogger {
  return logger.child({ service }) as CustomLogger;
}

================
File: utils/prismaClient.ts
================
import { PrismaClient } from "@prisma/client";
import { createLogger } from "./logger.js";
import path from "path";
import { fileURLToPath } from "url";

const logger = createLogger("PrismaClient");

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create a single instance
const prisma = new PrismaClient({
  log: ['error', 'warn'], // Reduce logging in production
  datasources: {
    db: {
      url: `file:${path.join(__dirname, '../../prisma/dev.db')}`
    }
  }
});

// Test the connection
prisma.$connect()
  .then(() => {
    logger.info('Successfully connected to the database');
  })
  .catch((error) => {
    logger.error('Failed to connect to the database:', error);
  });

// Handle cleanup
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

export default prisma;

================
File: utils/replacer.ts
================
export const replacer = (key: string, value: any) => (typeof value === "bigint" ? value.toString() : value);

================
File: utils/seralize.ts
================
export function serializeForSocket(data: any): any {
  if (data === null || data === undefined) return data;
  if (typeof data === 'bigint') return data.toString();
  if (Array.isArray(data)) return data.map(serializeForSocket);
  if (typeof data === 'object') {
    return Object.fromEntries(
      Object.entries(data).map(([key, value]) => [key, serializeForSocket(value)])
    );
  }
  return data;
}

================
File: utils/tokenCache.ts
================
import NodeCache from 'node-cache';
import { getTokenList } from './helper.js';

// Cache tokens for 1 hour (3600 seconds)
const tokenCache = new NodeCache({ stdTTL: 3600 });

export interface Token {
  address: string;
  name: string;
  symbol: string;
}

export async function getCachedTokens(): Promise<Token[]> {
  // Try to get tokens from cache first
  const cachedTokens = tokenCache.get<Token[]>('tokens');
  if (cachedTokens) {
    return cachedTokens;
  }

  // If not in cache, fetch from API
  const tokens = await getTokenList();
  
  // Store in cache
  tokenCache.set('tokens', tokens);
  
  return tokens;
}

// Force refresh the cache
export async function refreshTokenCache(): Promise<Token[]> {
  const tokens = await getTokenList();
  tokenCache.set('tokens', tokens);
  return tokens;
}
