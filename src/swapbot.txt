This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-27T07:52:09.801Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
cli.ts
cli/App.tsx
cli/components/ConfigList.tsx
cli/components/Dashboard.tsx
cli/components/EnvVarInput.tsx
cli/components/MainMenu.tsx
cli/components/StopAllBotsDialog.tsx
cli/components/TokenSelector.tsx
cli/forms/MultiBotForm.tsx
cli/forms/RegularBotForm.tsx
cli/hooks/useBotManagement.ts
cli/services/CLISocket.ts
config/index.ts
core/bot.ts
core/botManager.ts
core/multibot.ts
core/types.ts
scripts/run-cli.js
scripts/seedTokens.ts
server.ts
services/configService.ts
services/getTradeLogs.ts
services/notificationService.ts
services/rpcFactory.ts
services/tokenDataService.ts
services/tradeService.ts
utils/error.ts
utils/helper.ts
utils/logger.ts
utils/prismaClient.ts
utils/tokenCache.ts

================================================================
Repository Files
================================================================

================
File: cli.ts
================
import cli from './cli/App.js';

// Run the CLI
cli();

================
File: cli/App.tsx
================
import React from 'react';
import { render, Box, Text, useInput, useApp } from 'ink';
import RegularBotForm from './forms/RegularBotForm.js';
import MultiBotForm from './forms/MultiBotForm.js';
import ConfigList from './components/ConfigList.js';
import Dashboard from './components/Dashboard.js';
import { DefaultBotManager } from '../core/botManager.js';
import { Socket } from 'socket.io-client';
import { CLISocket } from './services/CLISocket.js';
import { EnvVarInput } from './components/EnvVarInput.js';
import { StopAllBotsDialog } from './components/StopAllBotsDialog.js';
import { MainMenu } from './components/MainMenu.js';
import { useBotManagement } from './hooks/useBotManagement.js';
import logger from '../utils/logger.js';

const TRADE_BOT_ASCII = `
████████╗██████╗  █████╗ ██████╗ ███████╗    ██████╗  ██████╗ ████████╗
╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗██╔════╝    ██╔══██╗██╔═══██╗╚══██╔══╝
   ██║   ██████╔╝███████║██║  ██║█████╗      ██████╔╝██║   ██║   ██║   
   ██║   ██╔══██╗██╔══██║██║  ██║██╔══╝      ██╔══██╗██║   ██║   ██║   
   ██║   ██║  ██║██║  ██║██████╔╝███████╗    ██████╔╝╚██████╔╝   ██║   
   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝    ╚═════╝  ╚═════╝    ╚═╝   
`;

// Initialize BotManager and socket
const socket = new CLISocket();
const botManager = new DefaultBotManager();

const App = () => {
  const { exit } = useApp();
  const [selectedOption, setSelectedOption] = React.useState(0);
  const [showForm, setShowForm] = React.useState(false);
  const [formType, setFormType] = React.useState<'regular' | 'multi' | null>(null);
  const [editingConfig, setEditingConfig] = React.useState<any>(null);
  const [showConfigList, setShowConfigList] = React.useState(false);
  const [showConfirmStopAll, setShowConfirmStopAll] = React.useState(false);
  const [showConfirmStartAll, setShowConfirmStartAll] = React.useState(false);
  const [envVarsComplete, setEnvVarsComplete] = React.useState(false);

  const {
    activeBots,
    stoppingProgress,
    startingProgress,
    checkActiveBots,
    handleStopAllBots,
    handleStartAllBots,
    setStoppingProgress,
    setStartingProgress
  } = useBotManagement(botManager, socket);

  const options = [
    'View All Configs',
    'Add New Config',
    'Add Multi Config',
    'Start All Bots',
    'Stop All Bots',
    'Exit'
  ];

  React.useEffect(() => {
    if (envVarsComplete) {
      checkActiveBots();
      // Set up an interval to refresh active bots every 5 seconds
      const interval = setInterval(checkActiveBots, 5000);
      return () => clearInterval(interval);
    }
  }, [envVarsComplete, checkActiveBots]);

  // Set up socket listener for config edit
  React.useEffect(() => {
    const handleConfigEdit = (data: { type: 'regular' | 'multi', config: any }) => {
      setFormType(data.type);
      setEditingConfig(data.config);
      setShowForm(true);
      setShowConfigList(false);
    };

    socket.getSocket().on('config:edit', handleConfigEdit);

    return () => {
      socket.getSocket().off('config:edit', handleConfigEdit);
    };
  }, [socket]);

  // Add cleanup function
  const cleanup = React.useCallback(async () => {
    try {
      // Stop all active bots
      const botIds = [...botManager.activeBots.keys()];
      for (const botId of botIds) {
        await botManager.stopBot(botId);
      }
      
      // Disconnect socket
      if (socket.getSocket()) {
        socket.getSocket().disconnect();
      }
      
      // Exit the app
      exit();
    } catch (error) {
      logger.error('Error during cleanup:', error);
      process.exit(1);
    }
  }, [botManager, socket, exit]);

  // Add signal handlers
  React.useEffect(() => {
    const handleSignal = async () => {
      await cleanup();
    };

    process.on('SIGINT', handleSignal);
    process.on('SIGTERM', handleSignal);

    return () => {
      process.off('SIGINT', handleSignal);
      process.off('SIGTERM', handleSignal);
    };
  }, [cleanup]);

  useInput((input, key) => {
    if (!envVarsComplete || showForm || showConfigList) return;

    if (showConfirmStopAll) {
      if (key.return && stoppingProgress.status === 'idle') {
        handleStopAllBots();
      } else if (key.escape && stoppingProgress.status === 'idle') {
        setShowConfirmStopAll(false);
        setStoppingProgress({ current: 0, total: 0, status: 'idle', message: '' });
      } else if (stoppingProgress.status === 'success' && input) {
        setShowConfirmStopAll(false);
        setStoppingProgress({ current: 0, total: 0, status: 'idle', message: '' });
      }
      return;
    }

    if (showConfirmStartAll) {
      if (key.return && startingProgress.status === 'idle') {
        handleStartAllBots();
      } else if (key.escape && startingProgress.status === 'idle') {
        setShowConfirmStartAll(false);
        setStartingProgress({ current: 0, total: 0, status: 'idle', message: '' });
      } else if (startingProgress.status === 'success' && input) {
        setShowConfirmStartAll(false);
        setStartingProgress({ current: 0, total: 0, status: 'idle', message: '' });
      }
      return;
    }

    if (key.upArrow) {
      setSelectedOption(prev => (prev > 0 ? prev - 1 : options.length - 1));
    }
    if (key.downArrow) {
      setSelectedOption(prev => (prev < options.length - 1 ? prev + 1 : 0));
    }
    if (key.return) {
      if (selectedOption === options.length - 1) {
        cleanup();
      } else if (selectedOption === 0) { // View All Configs
        setShowConfigList(true);
      } else if (selectedOption === 1) { // Add New Config
        setFormType('regular');
        setShowForm(true);
      } else if (selectedOption === 2) { // Add Multi Config
        setFormType('multi');
        setShowForm(true);
      } else if (selectedOption === 3) { // Start All Bots
        setShowConfirmStartAll(true);
      } else if (selectedOption === 4) { // Stop All Bots
        setShowConfirmStopAll(true);
      }
    }
  });

  if (!envVarsComplete) {
    return <EnvVarInput onComplete={() => setEnvVarsComplete(true)} />;
  }

  if (showForm) {
    if (formType === 'regular') {
      return (
        <RegularBotForm 
          onComplete={() => {
            setShowForm(false);
            setEditingConfig(null);
          }} 
          botManager={botManager} 
          socket={socket.getSocket()}
          editingConfig={editingConfig}
        />
      );
    } else if (formType === 'multi') {
      return (
        <MultiBotForm 
          onComplete={() => {
            setShowForm(false);
            setEditingConfig(null);
          }} 
          botManager={botManager} 
          socket={socket.getSocket()}
          editingConfig={editingConfig}
        />
      );
    }
  }

  if (showConfigList) {
    return <ConfigList onBack={() => setShowConfigList(false)} botManager={botManager} socket={socket.getSocket()} />;
  }

  if (showConfirmStopAll) {
    return (
      <StopAllBotsDialog
        activeBots={activeBots}
        stoppingProgress={stoppingProgress}
        onConfirm={handleStopAllBots}
        onCancel={() => {
          setShowConfirmStopAll(false);
          setStoppingProgress({ current: 0, total: 0, status: 'idle', message: '' });
        }}
      />
    );
  }

  return (
    <Box flexDirection="column">
      <Text color="cyan">{TRADE_BOT_ASCII}</Text>
      <Text bold color="white">Welcome to Trading Bot CLI</Text>
      <Text color="yellow">Note: After starting bots, it may take 20-30 seconds for the table to populate with data</Text>
      
      {/* Dashboard Section */}
      <Box marginTop={1}>
        <Dashboard 
          socket={socket.getSocket() as unknown as Socket} 
          height={12} 
          onRefresh={() => checkActiveBots()} 
        />
      </Box>

      {/* Menu Section */}
      <MainMenu selectedOption={selectedOption} options={options} />

      {/* Start All Bots Confirmation */}
      {showConfirmStartAll && (
        <Box marginTop={2} flexDirection="column">
          <Text bold color="green">Confirm Start All Bots</Text>
          <Box marginTop={1}>
            <Text color="yellow">Are you sure you want to start all inactive bots?</Text>
          </Box>
          <Box marginTop={1}>
            <Text color="cyan">Inactive bots: {startingProgress.total}</Text>
          </Box>
          {startingProgress.status !== 'idle' && (
            <Box marginTop={1} flexDirection="column">
              {startingProgress.status === 'starting' && (
                <Box>
                  <Text color="yellow">
                    Progress: {startingProgress.current}/{startingProgress.total}
                  </Text>
                </Box>
              )}
              <Text color={
                startingProgress.status === 'success' ? 'green' :
                startingProgress.status === 'error' ? 'red' : 'white'
              }>
                {startingProgress.message}
              </Text>
            </Box>
          )}
          <Box marginTop={1}>
            <Text color="blue">
              {startingProgress.status === 'idle' ? 
                'Press Enter to confirm, Escape to cancel' :
                startingProgress.status === 'success' ? 
                  'Press any key to continue' :
                  'Press Escape to cancel'
              }
            </Text>
          </Box>
        </Box>
      )}
    </Box>
  );
};

// Entry point
const cli = () => {
  render(<App />);
};

export default cli;

================
File: cli/components/ConfigList.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import { getTokenName, shortenUUID } from '../../utils/helper.js';
import { ConfigListProps, SortField, SortDirection, FilterType, BotWithType, ConfigListState } from '../../core/types.js';
import { ENV } from '../../config/index.js';
import { getSingleTokenData } from '../../services/tokenDataService.js';

const ConfigList: React.FC<ConfigListProps> = ({ onBack, botManager, socket }) => {
  const [configs, setConfigs] = React.useState<ConfigListState>({ regularBots: [], multiBots: [] });
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const [sortField, setSortField] = React.useState<SortField>('type');
  const [sortDirection, setSortDirection] = React.useState<SortDirection>('asc');
  const [filter, setFilter] = React.useState<FilterType>('all');
  const [error, setError] = React.useState<string | null>(null);
  const [selectedConfig, setSelectedConfig] = React.useState<BotWithType | null>(null);
  const [selectedAction, setSelectedAction] = React.useState<'view' | 'delete' | 'edit'>('view');
  const [tokenNames, setTokenNames] = React.useState<Map<string, string>>(new Map());

  const fetchConfigs = React.useCallback(() => {
    try {
      // Emit event to request configs
      socket.emit('config:get');
    } catch (error) {
      console.error('Failed to request configs:', error);
      setError('Failed to fetch configurations');
    }
  }, [socket]);

  // Set up socket listener for config updates
  React.useEffect(() => {
    const handleConfigUpdate = (data: any) => {
      try {
        // Transform the data to match our types
        const regularBots = data.regularBots.map((bot: any) => ({
          botId: bot.botId,
          initialInputToken: bot.initialInputToken,
          initialOutputToken: bot.initialOutputToken,
          initialInputAmount: bot.initialInputAmount,
          firstTradePrice: bot.firstTradePrice,
          targetGainPercentage: bot.targetGainPercentage,
          stopLossPercentage: bot.stopLossPercentage,
          status: bot.status
        }));

        const multiBots = data.multiBots.map((bot: any) => ({
          botId: bot.botId,
          initialInputToken: bot.initialInputToken,
          initialInputAmount: bot.initialInputAmount,
          targetGainPercentage: bot.targetGainPercentage,
          stopLossPercentage: bot.stopLossPercentage,
          checkInterval: bot.checkInterval,
          status: bot.status,
          targetAmounts: bot.targetAmounts.map((target: any) => ({
            id: target.id,
            configId: target.configId,
            tokenAddress: target.tokenAddress,
            amount: target.amount
          }))
        }));

        setConfigs({ regularBots, multiBots });
        setError(null);
      } catch (error) {
        console.error('Failed to process configs:', error);
        setError('Failed to process configurations');
      }
    };

    // Listen for config updates
    socket.on('config:update', handleConfigUpdate);

    // Request initial configs
    fetchConfigs();

    // Cleanup
    return () => {
      socket.off('config:update', handleConfigUpdate);
    };
  }, [socket, fetchConfigs]);

  const fetchTokenNames = React.useCallback(async (mints: (string | undefined)[]) => {
    try {
      const names = new Map<string, string>();
      const validMints = mints.filter((mint): mint is string => typeof mint === 'string' && mint !== '');
      
      for (const mint of validMints) {
        try {
          const tokenData = await getSingleTokenData(mint);
          if (tokenData) {
            names.set(mint, tokenData.name || tokenData.symbol || mint);
          } else {
            names.set(mint, mint); // Fallback to mint address if not found in DB
          }
        } catch (error) {
          console.error(`Failed to fetch token data for ${mint}:`, error);
          names.set(mint, mint); // Fallback to mint address if fetch fails
        }
      }
      setTokenNames(prev => new Map([...prev, ...names]));
    } catch (error) {
      console.error('Failed to fetch token names:', error);
    }
  }, []);

  React.useEffect(() => {
    if (configs.regularBots.length > 0 || configs.multiBots.length > 0) {
      const allMints = new Set<string>();
      configs.regularBots.forEach(bot => {
        if (bot.initialInputToken) allMints.add(bot.initialInputToken);
        if (bot.initialOutputToken) allMints.add(bot.initialOutputToken);
      });
      configs.multiBots.forEach(bot => {
        if (bot.initialInputToken) allMints.add(bot.initialInputToken);
        if (bot.targetAmounts) {
          bot.targetAmounts.forEach((target: { tokenAddress: string }) => {
            if (target.tokenAddress) allMints.add(target.tokenAddress);
          });
        }
      });
      fetchTokenNames(Array.from(allMints));
    }
  }, [configs, fetchTokenNames]);

  React.useEffect(() => {
    if (selectedConfig) {
      const mints = new Set<string>();
      if (selectedConfig.initialInputToken) mints.add(selectedConfig.initialInputToken);
      if (selectedConfig.type === 'regular' && 'initialOutputToken' in selectedConfig) {
        mints.add(selectedConfig.initialOutputToken || '');
      }
      if (selectedConfig.type === 'multi' && 'targetAmounts' in selectedConfig) {
        selectedConfig.targetAmounts?.forEach(target => {
          if (target.tokenAddress) mints.add(target.tokenAddress);
        });
      }
      fetchTokenNames(Array.from(mints));
    }
  }, [selectedConfig, fetchTokenNames]);

  const allBots = React.useMemo(() => {
    const regular = configs.regularBots.map(bot => ({
      ...bot,
      type: 'regular' as const,
      amount: bot.initialInputAmount,
      targetGainPercentage: BigInt(bot.targetGainPercentage),
      stopLossPercentage: bot.stopLossPercentage ? BigInt(bot.stopLossPercentage) : undefined
    }));
    const multi = configs.multiBots.map(bot => ({
      ...bot,
      type: 'multi' as const,
      amount: bot.initialInputAmount,
      targetGainPercentage: BigInt(bot.targetGainPercentage),
      stopLossPercentage: bot.stopLossPercentage ? BigInt(bot.stopLossPercentage) : undefined,
      targetAmounts: bot.targetAmounts.map(target => ({
        ...target,
        tokenName: tokenNames.get(target.tokenAddress) || target.tokenAddress
      }))
    }));
    return [...regular, ...multi] as BotWithType[];
  }, [configs, tokenNames]);

  const filteredBots = React.useMemo(() => {
    let filtered = allBots;
    
    // Apply filter
    if (filter === 'active') {
      filtered = filtered.filter(bot => bot.status === 'active');
    } else if (filter === 'inactive') {
      filtered = filtered.filter(bot => bot.status === 'inactive');
    }

    // Apply sort
    return filtered.sort((a, b) => {
      let comparison = 0;
      if (sortField === 'type') {
        comparison = a.type.localeCompare(b.type);
      } else if (sortField === 'amount') {
        comparison = a.amount - b.amount;
      } else if (sortField === 'status') {
        comparison = a.status.localeCompare(b.status);
      }
      return sortDirection === 'asc' ? comparison : -comparison;
    });
  }, [allBots, sortField, sortDirection, filter]);

  useInput((input, key) => {
    if (key.escape) {
      if (selectedConfig) {
        setSelectedConfig(null);
        setSelectedAction('view');
      } else {
        onBack();
      }
      return;
    }

    if (selectedConfig) {
      if (key.upArrow) {
        const actions: Array<'view' | 'delete' | 'edit'> = ['view', 'delete', 'edit'];
        const currentIndex = actions.indexOf(selectedAction);
        const nextIndex = (currentIndex - 1 + actions.length) % actions.length;
        setSelectedAction(actions[nextIndex]);
      }
      if (key.downArrow) {
        const actions: Array<'view' | 'delete' | 'edit'> = ['view', 'delete', 'edit'];
        const currentIndex = actions.indexOf(selectedAction);
        const nextIndex = (currentIndex + 1) % actions.length;
        setSelectedAction(actions[nextIndex]);
      }
      if (key.return) {
        if (selectedAction === 'delete') {
          handleDelete();
        } else if (selectedAction === 'edit') {
          handleEdit();
        } else {
          setSelectedConfig(null);
          setSelectedAction('view');
        }
      }
      return;
    }

    if (key.upArrow) {
      setSelectedIndex(prev => (prev > 0 ? prev - 1 : filteredBots.length - 1));
    }
    if (key.downArrow) {
      setSelectedIndex(prev => (prev < filteredBots.length - 1 ? prev + 1 : 0));
    }
    if (key.return) {
      const selectedBot = filteredBots[selectedIndex];
      if (selectedBot) {
        setSelectedConfig(selectedBot);
      }
      return;
    }
    if (key.leftArrow) {
      const fields: SortField[] = ['type', 'amount', 'status'];
      const currentIndex = fields.indexOf(sortField);
      const nextIndex = (currentIndex - 1 + fields.length) % fields.length;
      setSortField(fields[nextIndex]);
    }
    if (key.rightArrow) {
      const fields: SortField[] = ['type', 'amount', 'status'];
      const currentIndex = fields.indexOf(sortField);
      const nextIndex = (currentIndex + 1) % fields.length;
      setSortField(fields[nextIndex]);
    }
    if (input.toLowerCase() === 'f') {
      const filters: FilterType[] = ['all', 'active', 'inactive'];
      const currentIndex = filters.indexOf(filter);
      const nextIndex = (currentIndex + 1) % filters.length;
      setFilter(filters[nextIndex]);
    }
  });

  const handleDelete = async () => {
    if (!selectedConfig) return;
    
    try {
      // First stop the bot if it's running
      await botManager.stopBot(selectedConfig.botId);
      
      // Then delete the configuration
      await botManager.deleteConfig(
        selectedConfig.botId,
        selectedConfig.type
      );
      
      // Clear selection and refresh the list
      setSelectedConfig(null);
      setSelectedAction('view');
      fetchConfigs();
    } catch (error) {
      console.error('Failed to delete bot:', error);
      setError('Failed to delete configuration');
    }
  };

  const handleEdit = () => {
    if (!selectedConfig) return;
    
    // Emit the edit event first
    socket.emit('config:edit', {
      type: selectedConfig.type,
      config: selectedConfig
    });

    // Then go back to main menu
    onBack();
  };

  const handleViewConfig = (config: BotWithType) => {
    setSelectedConfig(config);
    setSelectedAction('view');
  };

  const handleDeleteConfig = (config: BotWithType) => {
    setSelectedConfig(config);
    setSelectedAction('delete');
  };

  const renderBotInfo = (bot: BotWithType) => {
    const inputTokenName = tokenNames.get(bot.initialInputToken) || bot.initialInputToken;
    const outputTokenName = bot.initialOutputToken ? (tokenNames.get(bot.initialOutputToken) || bot.initialOutputToken) : '';
    const shortId = shortenUUID(bot.botId);

    return (
      <Box flexDirection="column">
        <Text>ID: {shortId}</Text>
        <Text>Type: {bot.type === 'regular' ? 'Regular Bot' : 'Multi Bot'}</Text>
        <Text>Status: {bot.status}</Text>
        <Text>Input Token: {inputTokenName}</Text>
        {bot.type === 'regular' && <Text>Output Token: {outputTokenName}</Text>}
        {bot.type === 'multi' && bot.targetAmounts && (
          <Box flexDirection="column">
            <Text>Target Amounts:</Text>
            {bot.targetAmounts.map((target, index) => (
              <Text key={index}>
                - {tokenNames.get(target.tokenAddress) || target.tokenAddress}: {target.amount}
              </Text>
            ))}
          </Box>
        )}
      </Box>
    );
  };

  if (error) {
    return (
      <Box flexDirection="column">
        <Text color="red">{error}</Text>
      </Box>
    );
  }

  if (selectedConfig) {
    return (
      <Box flexDirection="column">
        <Text bold color="cyan">Configuration Details</Text>
        <Box marginTop={1} flexDirection="column">
          {renderBotInfo(selectedConfig)}
        </Box>
        <Box marginTop={1} flexDirection="column">
          <Text color="yellow">Actions:</Text>
          <Box marginLeft={1} flexDirection="column">
            <Text color={selectedAction === 'delete' ? 'cyan' : 'white'}>
              {selectedAction === 'delete' ? '> ' : '  '}Delete Configuration
            </Text>
            <Text color={selectedAction === 'edit' ? 'cyan' : 'white'}>
              {selectedAction === 'edit' ? '> ' : '  '}Edit Configuration
            </Text>
            <Text color={selectedAction === 'view' ? 'cyan' : 'white'}>
              {selectedAction === 'view' ? '> ' : '  '}Back to List
            </Text>
          </Box>
        </Box>
        <Box marginTop={1}>
          <Text color="blue">
            ↑↓ to select action, Enter to confirm, Escape to go back
          </Text>
        </Box>
      </Box>
    );
  }

  const activeBots = filteredBots.filter(bot => bot.status === 'active');
  const inactiveBots = filteredBots.filter(bot => bot.status === 'inactive');

  return (
    <Box flexDirection="column">
      <Text bold>All Configurations</Text>
      <Text>Sort by: {sortField} ({sortDirection}) - Filter: {filter}</Text>
      <Box marginTop={1} flexDirection="column">
        {activeBots.length > 0 && (
          <Box flexDirection="column">
            <Text bold color="green">Active Bots ({activeBots.length})</Text>
            {activeBots.map((bot, index) => (
              <Box key={`active-${bot.botId}`} marginLeft={2}>
                <Text
                  color={selectedIndex === index ? 'cyan' : 'green'}
                >
                  {bot.type} #{shortenUUID(bot.botId)}
                </Text>
              </Box>
            ))}
          </Box>
        )}
        {inactiveBots.length > 0 && (
          <Box marginTop={1} flexDirection="column">
            <Text bold color="yellow">
              Inactive Bots ({inactiveBots.length})
            </Text>
            {inactiveBots.map((bot, index) => (
              <Box key={`inactive-${bot.botId}`} marginLeft={2}>
                <Text
                  color={selectedIndex === activeBots.length + index ? 'cyan' : 'yellow'}
                >
                  {bot.type} #{shortenUUID(bot.botId)}
                </Text>
              </Box>
            ))}
          </Box>
        )}
        {activeBots.length === 0 && inactiveBots.length === 0 && (
          <Text>No configurations found</Text>
        )}
      </Box>
      <Box marginTop={1}>
        <Text color="blue">
          ↑↓ to select, Enter to view details
          {'\n'}
          ←→ to change sort, 'f' to change filter, Escape to go back
        </Text>
      </Box>
    </Box>
  );
};

export default ConfigList;

================
File: cli/components/Dashboard.tsx
================
// cli/components/Dashboard.tsx
import React from 'react';
import { Box, Text } from 'ink';
import { ConfigService } from '../../services/configService.js';
import { Socket } from 'socket.io-client';
import { shortenUUID } from '../../utils/helper.js';

interface DashboardProps {
  socket: Socket;
  height?: number; // Number of rows for the dashboard
  onRefresh: () => void; // Callback for manual refresh
}

interface BotMetrics {
  botId: string;
  targetMint?: string;
  difference: number;
  currentPrice: number;
  ratio: number;
  inputToken: string;
  outputToken: string;
  trades: number;
  type: 'regular' | 'multi';
}

const Dashboard: React.FC<DashboardProps> = ({ socket, height = 20 }) => {
  const [activeBotIds, setActiveBotIds] = React.useState<Set<string>>(new Set());
  const [metrics, setMetrics] = React.useState<Map<string, Map<string, BotMetrics>>>(new Map());
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  // Fetch active bot IDs and trade logs
  const fetchData = React.useCallback(async () => {
    try {
      console.clear(); // Clear the console before refreshing
      setLoading(true);
      const configService = new ConfigService();
      const allConfigs = await configService.getAllConfigs();
      
      // Get active bot IDs
      const activeIds = new Set<string>();
      allConfigs.regularBots.forEach(bot => {
        if (bot.status === 'active') {
          activeIds.add(bot.botId.toString());
        }
      });
      allConfigs.multiBots.forEach(bot => {
        if (bot.status === 'active') {
          activeIds.add(bot.botId.toString());
        }
      });
      setActiveBotIds(activeIds);


      setError(null);
    } catch (err) {
      setError('Failed to fetch dashboard data');
      console.error('Error fetching dashboard data:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  React.useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Handle bot:difference events
  React.useEffect(() => {
    const handleDifference = (data: any) => {
      setMetrics(prev => {
        const newMetrics = new Map(prev);
        const botMetrics = newMetrics.get(data.botId) || new Map();
        
        // Check if this is a multi-bot by looking for targetAmounts in the data
        const isMultiBot = 'targetAmounts' in data;
        const key = isMultiBot ? data.targetMint : data.outputMint;
        
        // For multi-bots, ensure we have the correct type and target mint
        if (isMultiBot && !data.targetMint) {
          console.warn('Multi-bot data missing targetMint:', data);
          return prev;
        }

        // Get token names for display
        const inputToken = data.inputMint || 'N/A';
        const outputToken = data.outputMint || 'N/A';

        botMetrics.set(key, {
          botId: data.botId,
          targetMint: isMultiBot ? data.targetMint : undefined,
          difference: Number(data.difference) || 0,
          currentPrice: Number(data.currentPrice) || 0,
          ratio: Number(data.ratio) || 0,
          inputToken,
          outputToken,
          trades: Number(data.trades) || 0,
          type: isMultiBot ? 'multi' : 'regular'
        });
        
        newMetrics.set(data.botId, botMetrics);
        return newMetrics;
      });
    };

    socket.on('bot:difference', handleDifference);
    return () => {
      socket.off('bot:difference', handleDifference);
    };
  }, [socket]);

  if (loading) {
    return (
      <Box>
        <Text>Loading dashboard data...</Text>
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Text color="red">{error}</Text>
      </Box>
    );
  }

  // Add message when no metrics are available but bots are active
  if (activeBotIds.size > 0 && (!metrics.size || Array.from(metrics.values()).every(m => m.size === 0))) {
    return (
      <Box flexDirection="column">
        <Text bold>Active Bots Dashboard</Text>
        <Box marginTop={1}>
          <Text color="yellow">Please wait 20-30 seconds for the table to populate with bot data...</Text>
        </Box>
      </Box>
    );
  }

  return (
    <Box flexDirection="column" height={height}>
      <Text bold>Active Bots Dashboard</Text>
      <Box marginTop={1}>
        <Text>
          {'Bot ID'.padEnd(12)} {'Diff %'.padEnd(10)} {'Current'.padEnd(10)} {'Input'.padEnd(12)} {'Output'.padEnd(18)} {'Trades'.padEnd(8)}
        </Text>
      </Box>
      <Box marginTop={1} flexDirection="column">
        {Array.from(metrics.entries()).map(([botId, targetMetrics]) => (
          <Box key={botId} flexDirection="column">
            {Array.from(targetMetrics.values()).map((metric, index) => (
              <Text key={`${botId}-${metric.targetMint || metric.outputToken || index}`}>
                {shortenUUID(botId).padEnd(12)} 
                {metric.difference.toFixed(2).padEnd(10)} 
                {metric.currentPrice.toFixed(2).padEnd(12)} 
                {(metric.inputToken || 'N/A').padEnd(15)} 
                {(metric.outputToken || 'N/A').padEnd(21)} 
                {metric.trades.toString().padEnd(8)}
              </Text>
            ))}
          </Box>
        ))}
      </Box>
    </Box>
  );
};

export default Dashboard;

================
File: cli/components/EnvVarInput.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import { checkVariables } from '../../config/index.js';
import { writeFileSync, readFileSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

interface EnvVarInputProps {
  onComplete: () => void;
}

export const EnvVarInput: React.FC<EnvVarInputProps> = ({ onComplete }) => {
  const [missingVars, setMissingVars] = React.useState<string[]>([]);
  const [currentVarIndex, setCurrentVarIndex] = React.useState(0);
  const [inputValue, setInputValue] = React.useState('');

  React.useEffect(() => {
    const variableCheck = checkVariables();
    if (!variableCheck.success) {
      setMissingVars(variableCheck.missingVars);
    } else {
      onComplete();
    }
  }, [onComplete]);

  const saveEnvVariable = (key: string, value: string) => {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const envPath = join(__dirname, '../../../.env');
    
    try {
      let envContent = '';
      try {
        envContent = readFileSync(envPath, 'utf8');
      } catch (error) {
        // File doesn't exist, that's okay
      }

      // Check if variable already exists
      const lines = envContent.split('\n');
      const existingIndex = lines.findIndex(line => line.startsWith(`${key}=`));
      
      if (existingIndex !== -1) {
        lines[existingIndex] = `${key}=${value}`;
      } else {
        lines.push(`${key}=${value}`);
      }

      writeFileSync(envPath, lines.join('\n'));
      return true;
    } catch (error) {
      console.error('Failed to save environment variable:', error);
      return false;
    }
  };

  useInput((input, key) => {
    if (key.return && inputValue.trim()) {
      const currentVar = missingVars[currentVarIndex];
      if (saveEnvVariable(currentVar, inputValue.trim())) {
        setInputValue('');
        if (currentVarIndex < missingVars.length - 1) {
          setCurrentVarIndex(prev => prev + 1);
        } else {
          // Recheck variables after all are set
          const newCheck = checkVariables();
          if (!newCheck.success) {
            setMissingVars(newCheck.missingVars);
            setCurrentVarIndex(0);
          } else {
            onComplete();
          }
        }
      }
    } else if (key.backspace) {
      setInputValue(prev => prev.slice(0, -1));
    } else if (input) {
      setInputValue(prev => prev + input);
    }
  });

  if (missingVars.length === 0) {
    return null;
  }

  return (
    <Box flexDirection="column">
      <Text bold color="yellow">Missing Environment Variables</Text>
      <Box marginTop={1}>
        <Text color="cyan">
          Please enter value for {missingVars[currentVarIndex]}:
        </Text>
      </Box>
      <Box marginTop={1}>
        <Text color="green">{inputValue}</Text>
      </Box>
      <Box marginTop={1}>
        <Text color="blue">Press Enter to save, Backspace to delete</Text>
      </Box>
    </Box>
  );
};

================
File: cli/components/MainMenu.tsx
================
import React from 'react';
import { Box, Text } from 'ink';

interface MainMenuProps {
  selectedOption: number;
  options: string[];
}

export const MainMenu: React.FC<MainMenuProps> = ({ selectedOption, options }) => {
  return (
    <Box flexDirection="column">
      <Box marginTop={2}>
        <Text color="blue">Use ↑↓ arrows to select an option and Enter to confirm</Text>
      </Box>
      <Box marginTop={1} flexDirection="column">
        {options.map((option, index) => {
          let color = 'white';
          if (index === selectedOption) {
            color = 'cyan';
          } else if (option === 'Stop All Bots') {
            color = 'cyan';
          } else if (option === 'Start All Bots') {
            color = 'cyan';
          } else if (option === 'Exit') {
            color = 'cyan';
          } else if (option === 'View All Configs') {
            color = 'cyan';
          } else if (option === 'Add New Config' || option === 'Add Multi Config') {
            color = 'cyan';
          }
          return (
            <Text key={option} color={color}>
              {index === selectedOption ? '> ' : '  '}{option}
            </Text>
          );
        })}
      </Box>
    </Box>
  );
};

================
File: cli/components/StopAllBotsDialog.tsx
================
import React from 'react';
import { Box, Text } from 'ink';

interface StopAllBotsDialogProps {
  activeBots: {
    regularBots: Array<{ botId: string; status: string }>;
    multiBots: Array<{ botId: string; status: string }>;
  };
  stoppingProgress: {
    current: number;
    total: number;
    status: 'idle' | 'stopping' | 'success' | 'error';
    message: string;
  };
  onConfirm: () => void;
  onCancel: () => void;
}

export const StopAllBotsDialog: React.FC<StopAllBotsDialogProps> = ({
  activeBots,
  stoppingProgress,
  onConfirm,
  onCancel
}) => {
  return (
    <Box flexDirection="column">
      <Text bold color="red">Confirm Stop All Bots</Text>
      <Box marginTop={1}>
        <Text color="yellow">Are you sure you want to stop all active bots?</Text>
      </Box>
      <Box marginTop={1}>
        <Text color="cyan">Active bots: {activeBots.regularBots.length + activeBots.multiBots.length}</Text>
      </Box>
      {stoppingProgress.status !== 'idle' && (
        <Box marginTop={1} flexDirection="column">
          {stoppingProgress.status === 'stopping' && (
            <Box>
              <Text color="yellow">
                Progress: {stoppingProgress.current}/{stoppingProgress.total}
              </Text>
            </Box>
          )}
          <Text color={
            stoppingProgress.status === 'success' ? 'green' :
            stoppingProgress.status === 'error' ? 'red' : 'white'
          }>
            {stoppingProgress.message}
          </Text>
        </Box>
      )}
      <Box marginTop={1}>
        <Text color="blue">
          {stoppingProgress.status === 'idle' ? 
            'Press Enter to confirm, Escape to cancel' :
            stoppingProgress.status === 'success' ? 
              'Press any key to continue' :
              'Press Escape to cancel'
          }
        </Text>
      </Box>
    </Box>
  );
};

================
File: cli/components/TokenSelector.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import { getCachedTokens, type Token } from '../../utils/tokenCache.js';


interface TokenSelectorProps {
  onSelect: (token: Token) => void;
  onCancel: () => void;
}

const DISPLAY_LIMIT = 10;

const TokenSelector: React.FC<TokenSelectorProps> = ({ onSelect, onCancel }) => {
  const [searchTerm, setSearchTerm] = React.useState('');
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const [tokens, setTokens] = React.useState<Token[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [displayOffset, setDisplayOffset] = React.useState(0);

  React.useEffect(() => {
    const fetchTokens = async () => {
      try {
        setLoading(true);
        const cachedTokens = await getCachedTokens();
        // Sort tokens by symbol for better usability
        const sortedTokens = cachedTokens.sort((a, b) => a.symbol.localeCompare(b.symbol));
        setTokens(sortedTokens);
        setError(null);
      } catch (err) {
        setError('Failed to load tokens. Please try again.');
        console.error('Error loading tokens:', err);
      } finally {
        setLoading(false);
      }
    };
    fetchTokens();
  }, []);

  const filteredTokens = React.useMemo(() => {
    if (!searchTerm) {
      return tokens;
    }
    const searchLower = searchTerm.toLowerCase();
    return tokens.filter(token => 
      token.symbol.toLowerCase().includes(searchLower) ||
      token.name.toLowerCase().includes(searchLower) ||
      token.address.toLowerCase().includes(searchLower)
    );
  }, [tokens, searchTerm]);

  const displayedTokens = React.useMemo(() => {
    return filteredTokens.slice(displayOffset, displayOffset + DISPLAY_LIMIT);
  }, [filteredTokens, displayOffset]);

  const hasMore = displayOffset + DISPLAY_LIMIT < filteredTokens.length;
  const hasPrevious = displayOffset > 0;

  useInput((input, key) => {
    if (key.escape) {
      onCancel();
      return;
    }

    if (key.return) {
      if (displayedTokens.length > 0) {
        onSelect(displayedTokens[selectedIndex]);
      }
      return;
    }

    if (key.upArrow) {
      if (selectedIndex > 0) {
        setSelectedIndex(prev => prev - 1);
      } else if (hasPrevious) {
        setDisplayOffset(prev => prev - DISPLAY_LIMIT);
        setSelectedIndex(DISPLAY_LIMIT - 1);
      }
    }

    if (key.downArrow) {
      if (selectedIndex < displayedTokens.length - 1) {
        setSelectedIndex(prev => prev + 1);
      } else if (hasMore) {
        setDisplayOffset(prev => prev + DISPLAY_LIMIT);
        setSelectedIndex(0);
      }
    }

    if (key.backspace) {
      setSearchTerm(prev => prev.slice(0, -1));
      setSelectedIndex(0);
      setDisplayOffset(0);
    } else if (input) {
      setSearchTerm(prev => prev + input);
      setSelectedIndex(0);
      setDisplayOffset(0);
    }
  });

  if (loading) {
    return (
      <Box>
        <Text>Loading tokens...</Text>
      </Box>
    );
  }

  if (error) {
    return (
      <Box>
        <Text color="red">{error}</Text>
      </Box>
    );
  }

  return (
    <Box flexDirection="column">
      <Text>Search Token (type to search): {searchTerm}</Text>
      <Box marginTop={1} flexDirection="column">
        {displayedTokens.map((token, index) => (
          <Box key={token.address}>
            <Text color={index === selectedIndex ? 'green' : 'white'}>
              {index === selectedIndex ? '> ' : '  '}
              <Text bold>{token.symbol.padEnd(8)}</Text>
              <Text>{token.name.padEnd(30)}</Text>
              <Text color={index === selectedIndex ? 'green' : 'gray'} dimColor>
                {token.address}
              </Text>
            </Text>
          </Box>
        ))}
        {hasMore && (
          <Box marginTop={1}>
            <Text color="gray">... {filteredTokens.length - (displayOffset + DISPLAY_LIMIT)} more tokens</Text>
          </Box>
        )}
      </Box>
      <Box marginTop={1}>
        <Text>
          {filteredTokens.length > 0 ? 
            `Showing ${displayOffset + 1}-${Math.min(displayOffset + DISPLAY_LIMIT, filteredTokens.length)} of ${filteredTokens.length} tokens` :
            'No tokens found'
          }
        </Text>
      </Box>
      <Box marginTop={1}>
        <Text>↑↓ to select, Enter to confirm, Escape to cancel</Text>
      </Box>
    </Box>
  );
};

export default TokenSelector;

================
File: cli/forms/MultiBotForm.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import { ConfigService } from '../../services/configService.js';
import TokenSelector from '../components/TokenSelector.js';
import { v4 as uuidv4 } from 'uuid';
import { MultiBotFormProps } from '../../core/types.js';

interface TargetAmount {
  token: { name: string; symbol: string };
  amount: string;
}

const MultiBotForm = ({ onComplete }: MultiBotFormProps) => {
  const [currentField, setCurrentField] = React.useState(0);
  const [inputValue, setInputValue] = React.useState('');
  const [error, setError] = React.useState('');
  const [showTokenSelector, setShowTokenSelector] = React.useState(false);
  const [currentTargetAmount, setCurrentTargetAmount] = React.useState<TargetAmount>({
    token: { name: '', symbol: '' },
    amount: ''
  });

  const [formData, setFormData] = React.useState({
    initialInputToken: { address: '', name: '', symbol: '' },
    botId: '',
    initialInputAmount: '',
    targetGainPercentage: '',
    stopLossPercentage: '',
    checkInterval: '',
    targetAmounts: {} as Record<string, number>
  });

  const [targetAmounts, setTargetAmounts] = React.useState<TargetAmount[]>([]);

  const fields = [
    { name: 'initialInputToken', label: 'Initial Input Token', type: 'token' },
    { name: 'initialInputAmount', label: 'Initial Input Amount', type: 'number' },
    { name: 'targetGainPercentage', label: 'Target Gain Percentage', type: 'number' },
    { name: 'stopLossPercentage', label: 'Stop Loss Percentage (optional)', type: 'number' },
    { name: 'checkInterval', label: 'Check Interval (seconds, optional)', type: 'number' }
  ];

  const handleTokenSelect = (token: { address: string; symbol: string; name: string }) => {
    if (currentField === fields.length) {
      setCurrentTargetAmount(prev => ({
        ...prev,
        token: { name: token.name, symbol: token.symbol }
      }));
    } else {
      setFormData(prev => ({ 
        ...prev, 
        initialInputToken: { 
          address: token.address,
          name: token.name,
          symbol: token.symbol
        } 
      }));
    }
    setShowTokenSelector(false);
  };

  const handleTokenCancel = () => {
    setShowTokenSelector(false);
  };

  const handleSubmit = async () => {
    try {
      const targetAmountsRecord: Record<string, number> = {};
      targetAmounts.forEach(target => {
        targetAmountsRecord[target.token.name] = Number(target.amount);
      });

      const botId = uuidv4();
      const configService = new ConfigService();
      await configService.addMultiConfig({
        botId,
        initialInputToken: formData.initialInputToken.address,
        initialInputAmount: Number(formData.initialInputAmount),
        targetGainPercentage: Number(formData.targetGainPercentage),
        stopLossPercentage: formData.stopLossPercentage ? Number(formData.stopLossPercentage) : undefined,
        checkInterval: formData.checkInterval ? Number(formData.checkInterval) : undefined,
        targetAmounts: targetAmountsRecord
      });

      onComplete();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save configuration');
    }
  };

  useInput((input, key) => {
    if (key.escape) {
      onComplete();
      return;
    }

    if (input.toLowerCase() === 's') {
      if (targetAmounts.length === 0) {
        setError('At least one target amount is required');
        return;
      }
      handleSubmit();
      return;
    }

    if (key.upArrow) {
      setCurrentField(prev => (prev > 0 ? prev - 1 : prev));
      if (currentField === fields.length) {
        setInputValue(currentTargetAmount.amount);
      } else {
        setInputValue(String(formData[fields[currentField].name as keyof typeof formData]));
      }
    } else if (key.downArrow) {
      setCurrentField(prev => (prev < fields.length ? prev + 1 : prev));
      if (currentField === fields.length) {
        setInputValue(currentTargetAmount.amount);
      } else {
        setInputValue(String(formData[fields[currentField].name as keyof typeof formData]));
      }
    } else if (key.return) {
      if (currentField === fields.length) {
        if (!currentTargetAmount.token.name) {
          setShowTokenSelector(true);
          return;
        }

        if (!currentTargetAmount.amount) {
          setError('Please enter a target amount');
          return;
        }

        setTargetAmounts(prev => [...prev, currentTargetAmount]);
        setCurrentTargetAmount({
          token: { name: '', symbol: '' },
          amount: ''
        });
        setInputValue('');
      } else {
        const field = fields[currentField];
        if (field.type === 'token') {
          setShowTokenSelector(true);
        } else {
          setFormData(prev => ({ ...prev, [field.name]: inputValue }));
        }
      }
    } else {
      if (currentField === fields.length) {
        if (key.backspace) {
          setCurrentTargetAmount(prev => ({
            ...prev,
            amount: prev.amount.slice(0, -1)
          }));
          setInputValue(prev => prev.slice(0, -1));
        } else {
          setCurrentTargetAmount(prev => ({
            ...prev,
            amount: prev.amount + input
          }));
          setInputValue(prev => prev + input);
        }
      } else {
        if (key.backspace) {
          setInputValue(prev => prev.slice(0, -1));
        } else {
          setInputValue(prev => prev + input);
        }
      }
    }
  });

  if (showTokenSelector) {
    return <TokenSelector onSelect={handleTokenSelect} onCancel={handleTokenCancel} />;
  }

  return (
    <Box flexDirection="column">
      <Text bold color="cyan">Multi Bot Configuration</Text>
      
      {/* Initial Configuration */}
      {fields.map((field, index) => (
        <Box key={field.name} marginTop={1}>
          <Text color={currentField === index ? 'yellow' : 'white'}>
            {field.label}: {
              field.type === 'token' 
                ? formData.initialInputToken.symbol || 'Select token'
                : String(formData[field.name as keyof typeof formData])
            }
          </Text>
        </Box>
      ))}

      {/* Target Amounts */}
        {targetAmounts.map((target, index) => (
          <Text key={index} color="green">
            {target.token.symbol}: {target.amount}
          </Text>
        ))}
        <Box marginTop={1}>
          <Text color={currentField === fields.length ? 'yellow' : 'white'}>
            Add Target: {currentTargetAmount.token.symbol || 'Select token'} {currentTargetAmount.amount ? `Amount: ${currentTargetAmount.amount}` : ''}
          </Text>
        </Box>

      {/* Instructions */}
      <Box marginTop={2}>
        <Text color="yellow">Instructions:</Text>
        <Box marginLeft={2} flexDirection="column">
          <Text>• Use ↑↓ arrow keys to navigate between fields</Text>
          <Text>• Press Enter to:</Text>
          <Box marginLeft={2}>
            <Text>  - Select a token when on token fields</Text>
            <Text>  - Add a target amount when on target field</Text>
          </Box>
          <Text>• Press 'S' to save configuration</Text>
          <Text>• Press Escape to exit</Text>
        </Box>
      </Box>

      {error && (
        <Box marginTop={1}>
          <Text color="red">{error}</Text>
        </Box>
      )}
    </Box>
  );
};

export default MultiBotForm;

================
File: cli/forms/RegularBotForm.tsx
================
import React from 'react';
import { Box, Text, useInput } from 'ink';
import { ConfigService } from '../../services/configService.js';
import TokenSelector from '../components/TokenSelector.js';
import { v4 as uuidv4 } from 'uuid';
import { RegularBotFormProps } from '../../core/types.js';

const RegularBotForm: React.FC<RegularBotFormProps> = ({ onComplete, botManager, socket, editingConfig }) => {
  const [currentField, setCurrentField] = React.useState(0);
  const [inputValue, setInputValue] = React.useState('');
  const [formData, setFormData] = React.useState({
    initialInputToken: '',
    initialOutputToken: '',
    initialInputAmount: '',
    firstTradePrice: '',
    targetGainPercentage: '',
    stopLossPercentage: ''
  });
  const [showTokenSelector, setShowTokenSelector] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);

  // Initialize form with editing config if provided
  React.useEffect(() => {
    if (editingConfig) {
      setFormData({
        initialInputToken: editingConfig.initialInputToken,
        initialOutputToken: editingConfig.initialOutputToken || '',
        initialInputAmount: editingConfig.amount.toString(),
        firstTradePrice: editingConfig.firstTradePrice?.toString() || '',
        targetGainPercentage: editingConfig.targetGainPercentage?.toString() || '',
        stopLossPercentage: editingConfig.stopLossPercentage?.toString() || ''
      });
    }
  }, [editingConfig]);

  const fields = [
    { name: 'initialInputToken', label: 'Input Token', type: 'token' },
    { name: 'initialOutputToken', label: 'Output Token', type: 'token' },
    { name: 'initialInputAmount', label: 'Input Amount', type: 'number' },
    { name: 'firstTradePrice', label: 'First Trade Price', type: 'number' },
    { name: 'targetGainPercentage', label: 'Target Gain %', type: 'number' },
    { name: 'stopLossPercentage (Optional)', label: 'Stop Loss %', type: 'number' }
  ];

  const handleTokenSelect = (token: { address: string; symbol: string; name: string }) => {
    setFormData(prev => ({
      ...prev,
      [fields[currentField].name]: token.name
    }));
    setShowTokenSelector(false);
    setCurrentField(prev => prev + 1);
  };

  const handleTokenCancel = () => {
    setShowTokenSelector(false);
  };

  useInput((input, key) => {
    if (showTokenSelector) return;

    if (key.escape) {
      onComplete();
      return;
    }

    if (key.upArrow) {
      setCurrentField(prev => (prev > 0 ? prev - 1 : prev));
      const prevField = fields[currentField - 1];
      if (prevField) {
        setInputValue(formData[prevField.name as keyof typeof formData] || '');
      }
      return;
    }

    if (key.downArrow) {
      setCurrentField(prev => (prev < fields.length - 1 ? prev + 1 : prev));
      const nextField = fields[currentField + 1];
      if (nextField) {
        setInputValue(formData[nextField.name as keyof typeof formData] || '');
      }
      return;
    }

    if (key.return) {
      const field = fields[currentField];
      
      if (field.type === 'token') {
        setShowTokenSelector(true);
        return;
      }

      if (currentField < fields.length - 1) {
        if (field.type === 'number' && isNaN(Number(inputValue))) {
          setError('Please enter a valid number');
          return;
        }
        if (!inputValue && field.name !== 'stopLossPercentage') {
          setError('This field is required');
          return;
        }

        setFormData(prev => ({
          ...prev,
          [field.name]: inputValue
        }));

        setCurrentField(prev => prev + 1);
        const nextField = fields[currentField + 1];
        setInputValue(formData[nextField.name as keyof typeof formData] || '');
        setError('');
      } else {
        // On last field, just save the value but don't submit
        if (field.type === 'number' && isNaN(Number(inputValue))) {
          setError('Please enter a valid number');
          return;
        }
        if (!inputValue && field.name !== 'stopLossPercentage') {
          setError('This field is required');
          return;
        }

        setFormData(prev => ({
          ...prev,
          [field.name]: inputValue
        }));
        setInputValue('');
        setError('');
      }
    } else if (input.toLowerCase() === 's' && currentField === fields.length - 1) {
      // Only allow saving if we're on the last field and all fields are filled
      const allFieldsFilled = fields.every(field => 
        field.name === 'stopLossPercentage' || formData[field.name as keyof typeof formData]
      );
      
      if (allFieldsFilled) {
        handleSubmit();
      } else {
        setError('Please fill in all required fields');
      }
    } else if (key.backspace) {
      setInputValue(prev => prev.slice(0, -1));
    } else if (input) {
      setInputValue(prev => prev + input);
    }
  });

  const handleSubmit = async () => {
    try {
      const config = {
        botId: editingConfig?.botId || crypto.randomUUID(),
        initialInputToken: formData.initialInputToken,
        initialOutputToken: formData.initialOutputToken,
        initialInputAmount: parseFloat(formData.initialInputAmount),
        firstTradePrice: parseFloat(formData.firstTradePrice),
        targetGainPercentage: parseFloat(formData.targetGainPercentage),
        stopLossPercentage: formData.stopLossPercentage ? 
          BigInt(Math.floor(parseFloat(formData.stopLossPercentage) * 100)) : 
          undefined
      };

      if (editingConfig) {
        // Update existing config
        await botManager.updateBotConfig(config.botId, config);
      } else {
        // Create new config
        await botManager.startBot(config, socket);
      }

      onComplete();
    } catch (error) {
      console.error('Failed to save configuration:', error);
      setError('Failed to save configuration');
    }
  };

  if (showTokenSelector) {
    return <TokenSelector onSelect={handleTokenSelect} onCancel={handleTokenCancel} />;
  }

  return (
    <Box flexDirection="column">
      <Text bold>Add New Bot Configuration</Text>
      <Box marginTop={1} flexDirection="column">
        {fields.map((field, index) => (
          <Box key={field.name}>
            <Text color={index === currentField ? 'green' : 'white'}>
              {field.label}: {index === currentField ? inputValue : formData[field.name as keyof typeof formData] || ''}
            </Text>
          </Box>
        ))}
      </Box>
      {error && (
        <Box marginTop={1}>
          <Text color="red">{error}</Text>
        </Box>
      )}
      <Box marginTop={1}>
        <Text>Press Enter to continue, 'S' to save when done, Escape to exit</Text>
      </Box>
    </Box>
  );
};

export default RegularBotForm;

================
File: cli/hooks/useBotManagement.ts
================
import React from 'react';
import { DefaultBotManager } from '../../core/botManager.js';
import { CLISocket } from '../services/CLISocket.js';

export const useBotManagement = (botManager: DefaultBotManager, socket: CLISocket) => {
  const [activeBots, setActiveBots] = React.useState<{
    regularBots: Array<{ botId: string; status: string }>;
    multiBots: Array<{ botId: string; status: string }>;
  }>({ regularBots: [], multiBots: [] });

  const [stoppingProgress, setStoppingProgress] = React.useState<{
    current: number;
    total: number;
    status: 'idle' | 'stopping' | 'success' | 'error';
    message: string;
  }>({ current: 0, total: 0, status: 'idle', message: '' });

  const [startingProgress, setStartingProgress] = React.useState<{
    current: number;
    total: number;
    status: 'idle' | 'starting' | 'success' | 'error';
    message: string;
  }>({ current: 0, total: 0, status: 'idle', message: '' });

  const checkActiveBots = React.useCallback(async () => {
    try {
      const allBots = await botManager.getAllBots();
      setActiveBots({
        regularBots: allBots.regularBots.filter(bot => bot.status === 'active').map(bot => ({
          botId: bot.botId,
          status: bot.status
        })),
        multiBots: allBots.multiBots.filter(bot => bot.status === 'active').map(bot => ({
          botId: bot.botId,
          status: bot.status
        }))
      });
      return [...allBots.regularBots, ...allBots.multiBots].filter(bot => bot.status === 'active');
    } catch (error) {
      console.error('Failed to check active bots:', error);
      return [];
    }
  }, [botManager]);

  const handleStopAllBots = React.useCallback(async () => {
    try {
      const activeBots = await checkActiveBots();
      if (activeBots.length === 0) {
        setStoppingProgress({
          current: 0,
          total: 0,
          status: 'success',
          message: 'No active bots to stop'
        });
        return;
      }

      setStoppingProgress({
        current: 0,
        total: activeBots.length,
        status: 'stopping',
        message: `Stopping ${activeBots.length} active bots...`
      });

      for (let i = 0; i < activeBots.length; i++) {
        const bot = activeBots[i];
        await botManager.stopBot(bot.botId);
        setStoppingProgress(prev => ({
          ...prev,
          current: i + 1,
          message: `Stopping bot ${i + 1} of ${activeBots.length}...`
        }));
      }

      setStoppingProgress(prev => ({
        ...prev,
        status: 'success',
        message: `Successfully stopped ${activeBots.length} bots`
      }));
    } catch (error) {
      setStoppingProgress({
        current: 0,
        total: 0,
        status: 'error',
        message: `Failed to stop all bots: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }, [botManager, checkActiveBots]);

  const handleStartAllBots = React.useCallback(async () => {
    try {
      const { regularBots, multiBots } = await botManager.getAllBots();
      const inactiveBots = [...regularBots, ...multiBots].filter(bot => bot.status === 'inactive');

      if (inactiveBots.length === 0) {
        setStartingProgress({
          current: regularBots.length + multiBots.length,
          total: regularBots.length + multiBots.length,
          status: 'success',
          message: 'No inactive bots to start'
        });
        return;
      }

      setStartingProgress({
        current: 0,
        total: inactiveBots.length,
        status: 'starting',
        message: `Starting ${inactiveBots.length} inactive bots...`
      });

      for (let i = 0; i < inactiveBots.length; i++) {
        const bot = inactiveBots[i];
        try {
          if ('targetAmounts' in bot) {
            // Handle multi bot
            const targetAmounts: Record<string, number> = {};
            for (const target of bot.targetAmounts) {
              targetAmounts[target.tokenAddress] = target.amount;
            }

            await botManager.startMultiBot({
              botId: bot.botId,
              initialInputToken: bot.initialInputToken,
              initialInputAmount: bot.initialInputAmount,
              targetGainPercentage: bot.targetGainPercentage,
              stopLossPercentage: bot.stopLossPercentage ?? undefined,
              checkInterval: bot.checkInterval ?? undefined,
              targetAmounts
            }, socket.getSocket());
          } else {
            // Handle regular bot
            await botManager.startBot({
              botId: bot.botId,
              initialInputToken: bot.initialInputToken,
              initialInputAmount: bot.initialInputAmount,
              firstTradePrice: bot.firstTradePrice,
              targetGainPercentage: bot.targetGainPercentage,
              stopLossPercentage: bot.stopLossPercentage ? BigInt(bot.stopLossPercentage.toString()) : undefined,
              initialOutputToken: bot.initialOutputToken
            }, socket.getSocket());
          }

          setStartingProgress(prev => ({
            ...prev,
            current: i + 1,
            message: `Starting bot ${i + 1} of ${inactiveBots.length}...`
          }));
        } catch (error) {
          console.error(`Failed to start bot ${bot.botId}:`, error);
        }
      }

      setStartingProgress(prev => ({
        ...prev,
        status: 'success',
        message: `Successfully started ${inactiveBots.length} bots`
      }));
    } catch (error) {
      setStartingProgress({
        current: 0,
        total: 0,
        status: 'error',
        message: `Failed to start all bots: ${error instanceof Error ? error.message : String(error)}`
      });
    }
  }, [botManager, socket]);

  return {
    activeBots,
    stoppingProgress,
    startingProgress,
    checkActiveBots,
    handleStopAllBots,
    handleStartAllBots,
    setStoppingProgress,
    setStartingProgress
  };
};

================
File: cli/services/CLISocket.ts
================
import { Socket, io } from 'socket.io-client';
import { ENV } from '../../config/index.js';
import logger from '../../utils/logger.js';

export class CLISocket {
  private socket: Socket;
  private eventHandlers: Map<string, Set<(data: unknown) => void>> = new Map();
  private isShuttingDown: boolean = false;

  constructor() {
    // Connect to the server using the correct port from ENV
    this.socket = io(`http://localhost:${ENV.PORT || 4000}`, {
      transports: ['websocket'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000
    });

    // Set up socket event handlers
    this.socket.on('connect', () => {
      logger.info('[CLISocket] Connected to server');
    });

    this.socket.on('disconnect', () => {
      if (!this.isShuttingDown) {
        logger.warn('[CLISocket] Disconnected from server');
      }
    });

    this.socket.on('error', (error: Error) => {
      logger.error('[CLISocket] Socket error:', error);
    });

    // Forward all events from the socket to our handlers
    this.socket.onAny((event: string, data: unknown) => {
      const handlers = this.eventHandlers.get(event);
      if (handlers) {
        handlers.forEach(callback => callback(data));
      }
    });

    // Set up signal handlers
    this.setupSignalHandlers();
  }

  private setupSignalHandlers() {
    const signals = ['SIGINT', 'SIGTERM'] as const;
    
    signals.forEach(signal => {
      process.on(signal, async () => {
        logger.info(`[CLISocket] Received ${signal} signal`);
        await this.cleanup();
        process.exit(0);
      });
    });

    // Handle uncaught errors
    process.on('uncaughtException', async (error) => {
      logger.error('[CLISocket] Uncaught Exception:', error);
      await this.cleanup();
      process.exit(1);
    });

    process.on('unhandledRejection', async (reason) => {
      logger.error('[CLISocket] Unhandled Rejection:', reason);
      await this.cleanup();
      process.exit(1);
    });
  }

  async cleanup() {
    if (this.isShuttingDown) return;
    this.isShuttingDown = true;

    logger.info('[CLISocket] Starting cleanup...');

    try {
      // Remove all event listeners
      this.eventHandlers.clear();
      
      // Disconnect the socket
      if (this.socket.connected) {
        logger.info('[CLISocket] Disconnecting socket...');
        this.socket.disconnect();
      }

      logger.info('[CLISocket] Cleanup complete');
    } catch (error) {
      logger.error('[CLISocket] Error during cleanup:', error);
      throw error;
    }
  }

  emit(event: string, data: unknown) {
    if (this.isShuttingDown) {
      logger.warn('[CLISocket] Attempted to emit event during shutdown:', event);
      return;
    }
    this.socket.emit(event, data);
  }

  on(event: string, callback: (data: unknown) => void) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, new Set());
    }
    this.eventHandlers.get(event)!.add(callback);
  }

  off(event: string, callback: (data: unknown) => void) {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.delete(callback);
    }
  }

  disconnect() {
    this.cleanup();
  }

  getSocket(): Socket {
    return this.socket;
  }
}

================
File: config/index.ts
================
import dotenv from 'dotenv';
import fs from 'fs';
import logger from '../utils/logger.js';

dotenv.config();
function reloadEnv() {
  const envConfig = dotenv.parse(fs.readFileSync('.env'));
  for (const k in envConfig) {
    process.env[k] = envConfig[k];
  }
}
reloadEnv();

export const ENV = {
  PORT: process.env.PORT || 4000,
  wallet: process.env.KEY,
  solanaEndpoint: process.env.RPC_URL,
  wss: process.env.WSS_URL,
  // Add other environment variables here
};

export function checkVariables() {
  const requiredVars = ['KEY', 'RPC_URL', 'WSS_URL'];
  const missingVars = requiredVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    logger.error('Required environment variables are not set:', missingVars);
  }
  
  return {
    success: missingVars.length === 0,
    missingVars
  };
}

================
File: core/bot.ts
================
import { QuoteResponse, TradeBotConfig, NextTrade, BotData, BotStatus } from "./types.js";
import logger from "../utils/logger.js";
import {
  address,
  Address,
  createSolanaRpcSubscriptions,
  getAddressFromPublicKey,
  Rpc,
  SolanaRpcApiMainnet,
} from "@solana/kit";
import { getTokenDecimalsByAddress, getTokenName } from "../utils/helper.js";
import { Socket } from "socket.io-client";
import { TradeService } from "../services/tradeService.js";
import { NotificationService } from "../services/notificationService.js";
import { ConfigService } from "../services/configService.js";

export class TradeBot {
  // Public properties
  public readonly botId: string;
  public status: BotStatus = 'inactive';
  public difference: number;
  public ratio: number;
  public currentTrade: number;
  public inputTokenAccount: Address;
  public outputTokenAccount: Address;
  public firstTradePrice: number;
  public targetGainPercentage: number | undefined;
  public stopLossPercentage: bigint | undefined;
  public nextTrade: NextTrade;
  public tradeCounter: number;

  // Private properties
  private readonly wallet: CryptoKeyPair;
  private readonly rpc: Rpc<SolanaRpcApiMainnet>;
  private readonly subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
  private readonly tradeService: TradeService;
  private readonly notificationService: NotificationService;
  private readonly socket: Socket;
  private priceWatchIntervalId?: NodeJS.Timeout;
  private readonly checkInterval: number;
  private lastCheck: number;
  private stopped: boolean;
  private waitingForConfirmation: boolean = false;
  public configService: ConfigService;
  private monitorInterval?: NodeJS.Timeout;

  constructor(config: TradeBotConfig, socket: Socket) {
    if (!config.rpc) {
      throw new Error('RPC client is required');
    }
    if (!config.subscriptions) {
      throw new Error('Subscriptions client is required');
    }

    this.botId = config.botId.toString();
    this.wallet = config.wallet;
    this.rpc = config.rpc;
    this.subscriptions = config.subscriptions;
    this.socket = socket;
    this.difference = 0;
    this.ratio = 0;
    this.currentTrade = 0;
    this.targetGainPercentage = config.targetGainPercentage || undefined;
    this.inputTokenAccount = config.initialInputToken as Address;
    this.outputTokenAccount = config.initialOutputToken as Address;
    this.firstTradePrice = config.firstTradePrice;
    this.tradeCounter = 0;
    this.stopLossPercentage = config.stopLossPercentage || undefined;
    this.stopped = false;
    this.checkInterval = config.checkInterval || 20000;
    this.lastCheck = 0;

    this.nextTrade = {
      inputMint: config.initialInputToken as Address,
      outputMint: config.initialOutputToken as Address,
      amount: config.initialInputAmount,
      swapMode: "ExactIn",
    };

    this.tradeService = new TradeService(
      this.botId,
      this.wallet,
      this.rpc,
      this.subscriptions,
      this.postTransactionProcessing.bind(this),
      this.setWaitingForConfirmation.bind(this),
    );
    this.notificationService = new NotificationService();
    this.configService = new ConfigService();
    this.initialize().catch((error) => {
      logger.error(`Bot ID: ${this.botId} - Error starting bot: ${error instanceof Error ? error.message : String(error)}`);
    });
  }

  /**
   * Initializes the bot by fetching token accounts and starting the price watch.
   * @returns {Promise<void>}
   * @throws {Error} If public key fetching or balance refresh fails after retries.
   */
  private async initialize(): Promise<void> {
    this.notificationService.log(`Bot ID: ${this.botId} 🤖 Initiating trade bot`, this.botId);

    const pubWallet = await getAddressFromPublicKey(this.wallet.publicKey);
    if (!pubWallet) {
      logger.error(`Bot ID: ${this.botId} - Error fetching public key.`);
      throw new Error("Error fetching public key. Make sure keypair provided is set and valid.");
    }
    this.startPriceWatch();
    logger.info(`${this.botId} started successfully`);
  }

  /**
   * Starts a periodic interval to monitor price changes and execute trades.
   * @private
   */
  private startPriceWatch(): void {
    this.priceWatchIntervalId = setInterval(async () => {
      if (this.stopped || !this.priceWatchIntervalId) {
        clearInterval(this.priceWatchIntervalId);
        this.priceWatchIntervalId = undefined;
        logger.info(`Bot ID: ${this.botId} - Price watch stopped.`);
        return;
      }

      const currentTime = Date.now();
      if (currentTime - this.lastCheck < this.checkInterval) return;

      this.lastCheck = currentTime;

      if (this.waitingForConfirmation) {
        logger.info(`Bot ID: ${this.botId} - Waiting for transaction confirmation...`);
        return;
      }

      try {
        const timeout = setTimeout(() => {
          throw new Error("Quote fetch timed out");
        }, 10000);
        logger.debug(`Bot ID: ${this.botId} - calling getQuote()`);
        const quote = await this.tradeService.getQuote2(this.nextTrade);
        clearTimeout(timeout);
        if (quote) {
          await this.updateUI(quote);
          logger.debug(`Bot ID: ${this.botId} - Evaluating quote`);
          await this.tradeService.evaluateQuoteAndSwap(quote, this.firstTradePrice);
        }
      } catch (error) {
        const errorMsg = `Bot ID: ${this.botId} - Error in price watch: ${error instanceof Error ? error.message : String(error)}`;
        logger.error(errorMsg);
      }
    }, this.checkInterval);
  }

  /**
   * Sets the waiting for confirmation flag.
   * @param {boolean} flag - Whether the bot is waiting for transaction confirmation.
   * @public
   */
  public setWaitingForConfirmation(flag: boolean): void {
    logger.debug(`Bot ID: ${this.botId} - setWaitingForConfirmation(${flag})`);
    this.waitingForConfirmation = flag;
  }

  /**
   * Updates the UI with current price data and checks stop loss.
   * @param {QuoteResponse} quote - The latest quote response from the trade service.
   * @returns {Promise<void>}
   * @throws {Error} If token name or decimal conversion fails.
   * @private
   */
  private async updateUI(quote: QuoteResponse): Promise<void> {
    const currentPrice = parseInt(quote.outAmount);
    const thresholdPrice = this.firstTradePrice;

    const currentPriceWithDecimals = await getTokenDecimalsByAddress(
      this.nextTrade.outputMint as Address,
      currentPrice
    );
    const currentThresholdPrice = await getTokenDecimalsByAddress(this.nextTrade.outputMint as Address, thresholdPrice);
    logger.info(`Bot ID: ${this.botId} - updateUI() => Current Price=${currentPriceWithDecimals}, Threshold Price=${currentThresholdPrice}`);

    const diff = ((currentPriceWithDecimals - currentThresholdPrice) / currentThresholdPrice) * 100;
    this.difference = diff;
    this.currentTrade = currentPriceWithDecimals;

    if (this.stopLossPercentage && diff < -Number(this.stopLossPercentage)) {
      this.notificationService.log(`Bot ID: ${this.botId} - Stop loss triggered at ${currentPriceWithDecimals}. Terminating.`, this.botId);
      this.terminateSession();
      return;
    }

    const inputName = await getTokenName(this.nextTrade.inputMint);
    const outputName = await getTokenName(this.nextTrade.outputMint);
    const botData: BotData = {
      botId: this.botId,
      status: this.stopped ? "Stopped" : "Running",
      inputMint: inputName,
      outputMint: outputName,
      currentPrice: this.currentTrade,
      targetTrade: currentThresholdPrice,
      difference: this.difference,
      trades: this.tradeCounter,
      tokenInPrice: 0,
      tokenOutPrice: 0
    };

    // Emit the bot data to update the dashboard
    this.emit('bot:difference', botData);
  }

  /**
   * Updates the next trade configuration based on the last trade result.
   * @param {QuoteResponse} lastTrade - The result of the last executed trade.
   * @returns {Promise<void>}
   * @throws {Error} If target gain percentage is invalid or calculation overflows.
   * @private
   */
  private async updateNextTrade(lastTrade: QuoteResponse): Promise<void> {
    const inLamports = BigInt(lastTrade.inAmount);
    if (!this.targetGainPercentage || this.targetGainPercentage <= 0) {
      throw new Error(`Bot ID: ${this.botId} - Invalid target gain percentage: ${this.targetGainPercentage}`);
    }

    const targetGainLamports = inLamports * BigInt(Math.floor(this.targetGainPercentage * 100)) / BigInt(10000);
    const currentGainLamports = BigInt(lastTrade.outAmount) - inLamports;

    if (currentGainLamports >= targetGainLamports) {
      this.notificationService.log(`Bot ID: ${this.botId} - Target gain reached! Stopping bot.`, this.botId);
      this.terminateSession();
      return;
    }

    this.nextTrade = {
      inputMint: this.nextTrade.outputMint,
      outputMint: this.nextTrade.inputMint,
      amount: parseInt(lastTrade.outAmount),
      swapMode: "ExactIn",
    };
    this.firstTradePrice = Number(inLamports + targetGainLamports);
  }

  /**
   * Processes a completed transaction and updates bot state.
   * @param {QuoteResponse} quote - The quote response for the completed trade.
   * @param {string} txid - Transaction ID of the completed trade.
   * @returns {Promise<void>}
   * @throws {Error} If token decimal conversion or config update fails.
   * @public
   */
  public async postTransactionProcessing(quote: QuoteResponse, txid: string): Promise<void> {
    const { inputMint, inAmount, outputMint, outAmount } = quote;
    if (this.targetGainPercentage) {
      const priceChange = this.targetGainPercentage / 100;
      await this.updateNextTrade(quote);

      const getTokenA = await getTokenDecimalsByAddress(this.nextTrade.inputMint as Address, parseInt(quote.outAmount));
      const getTokenB = await getTokenDecimalsByAddress(this.nextTrade.outputMint as Address, parseInt(quote.inAmount) * (1 + priceChange));
      await this.configService.updateBotConfig(this.botId, {
        botId: this.botId,
        initialInputToken: await getTokenName(this.nextTrade.inputMint)!,
        initialOutputToken: await getTokenName(this.nextTrade.outputMint)!,
        initialInputAmount: Number(getTokenA)!,
        firstTradePrice: Number(getTokenB)!,
        targetGainPercentage: this.targetGainPercentage,
        stopLossPercentage: this.stopLossPercentage ? Number(this.stopLossPercentage) : null,
      });
    }

    const logAmount = await getTokenDecimalsByAddress(inputMint as Address, parseFloat(inAmount));
    const logOutAmount = await getTokenDecimalsByAddress(outputMint as Address, parseFloat(outAmount));
    await this.notificationService.logSwap({
      botId: this.botId,
      tokenIn: address(inputMint),
      tokenInAmount: logAmount ?? 0,
      tokenInUSD: 0,
      tokenOut: address(outputMint),
      tokenOutAmount: logOutAmount ?? 0,
      tokenOutUSD: 0,
      totalValueUSD: 0,
      txid,
      date: new Date(),
    });

    this.tradeCounter += 1;
    logger.info(`Bot ID: ${this.botId} - Trade completed: Swapped ${await getTokenName(inputMint)} for ${await getTokenName(outputMint)}`);

    if (!this.targetGainPercentage || this.targetGainPercentage === 0) {
      logger.info(`${this.botId} - No target gain percentage set. Stopping bot.`);
      this.terminateSession();
    }
  }

  /**
   * Terminates the bot session and stops all operations.
   * @public
   */
  public terminateSession(): void {
    this.notificationService.log(`Bot ID: ${this.botId} ❌ Terminating bot...`, this.botId);
    this.stopped = true;

    if (this.priceWatchIntervalId) {
      clearInterval(this.priceWatchIntervalId);
      this.priceWatchIntervalId = undefined;
    }
    this.notificationService.log(`Bot ID: ${this.botId} - Bot terminated successfully`, this.botId);
  }

  private serializeForSocket(data: any): any {
    if (data === null || data === undefined) {
      return data;
    }
    
    if (typeof data === 'bigint') {
      return data.toString();
    }
    
    if (Array.isArray(data)) {
      return data.map(this.serializeForSocket.bind(this));
    }
    
    if (typeof data === 'object') {
      const result: any = {};
      for (const [key, value] of Object.entries(data)) {
        result[key] = this.serializeForSocket(value);
      }
      return result;
    }
    
    return data;
  }

  private emit(event: string, data: any) {
    this.socket.emit(event, this.serializeForSocket(data));
  }

  async start(): Promise<void> {
    if (this.status === 'Running') {
      throw new Error('Bot is already running');
    }

    if (!this.inputTokenAccount || !this.nextTrade.amount) {
      throw new Error('Missing required configuration: initialInputToken or initialInputAmount');
    }

    try {
      this.status = 'Running';
      this.socket.emit('botStatus', { botId: this.botId, status: this.status });
      
      this.monitorInterval = setInterval(async () => {
        try {
          await this.checkAndExecute();
        } catch (error) {
          logger.error(`Error in monitor interval: ${error}`);
          this.socket.emit('error', { 
            botId: this.botId, 
            message: `Monitor error: ${error instanceof Error ? error.message : String(error)}` 
          });
        }
      }, this.checkInterval || 60000);
    } catch (error) {
      this.status = 'Stopped';
      this.socket.emit('botStatus', { botId: this.botId, status: this.status });
      throw error;
    }
  }

  async stop(): Promise<void> {
    if (this.status !== 'Running') {
      throw new Error('Bot is not running');
    }

    try {
      if (this.monitorInterval) {
        clearInterval(this.monitorInterval);
        this.monitorInterval = undefined;
      }
      this.status = 'Stopped';
      this.socket.emit('botStatus', { botId: this.botId, status: this.status });
    } catch (error) {
      this.status = 'Stopped';
      this.socket.emit('botStatus', { botId: this.botId, status: this.status });
      throw error;
    }
  }

  private async checkAndExecute(): Promise<void> {
    try {
      const currentBalance = await this.getCurrentBalance();
      const gainPercentage = ((currentBalance - this.firstTradePrice) / this.firstTradePrice) * 100;

      if (this.targetGainPercentage && gainPercentage >= this.targetGainPercentage) {
        await this.executeTrade();
        await this.stop();
      } else if (this.stopLossPercentage && gainPercentage <= -Number(this.stopLossPercentage)) {
        logger.warn(`Stop loss triggered at ${gainPercentage}% loss`);
        await this.stop();
      }
    } catch (error) {
      logger.error(`Error in checkAndExecute: ${error}`);
      this.socket.emit('error', { 
        botId: this.botId, 
        message: `Trade check error: ${error instanceof Error ? error.message : String(error)}` 
      });
      throw error;
    }
  }

  private async getCurrentBalance(): Promise<number> {
    // Implementation of getCurrentBalance
    return 0;
  }

  private async executeTrade(): Promise<void> {
    // Implementation of executeTrade
  }
}

export interface NewConfig {
  botId: string;
  // ...
  stopLossPercentage?: bigint; // undefined if not set
}

================
File: core/botManager.ts
================
import { Socket } from "socket.io-client";
import { TradeBot } from "./bot.js";
import { MultiBot } from "./multibot.js";
import { TradeBotConfig, MultiBotConfig, BotResponse, BotManager } from "./types.js";
import { createRpcClients } from "../services/rpcFactory.js";
import { getTokenDecimalsByName, getTokenAddressByName } from "../utils/helper.js";
import { ENV } from "../config/index.js";
import logger from "../utils/logger.js";
import bs58 from "bs58";
import { createKeyPairFromBytes, Address } from "@solana/kit";
import { Config, MultiConfig, TargetAmount } from "@prisma/client";
import { ConfigService } from "../services/configService.js";

export class DefaultBotManager implements BotManager {
  public activeBots: Map<string, TradeBot> = new Map();
  public activeMultiBots: Map<string, MultiBot> = new Map();
  private configService: ConfigService;

  constructor() {
    this.configService = new ConfigService();
  }


  private async initializeBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<TradeBot> {
    const solanaEndpoint: string = ENV.solanaEndpoint!;
    const wallet: string = ENV.wallet!;
    const wssEndpoint: string = ENV.wss!;
    if (!solanaEndpoint || !wallet || !wssEndpoint) {
      throw new Error('Required environment variables are not set');
    }

    const { rpc, subscriptions } = await createRpcClients({ solanaEndpoint, wssEndpoint });
    const decodedKey = new Uint8Array(bs58.decode(wallet));
    const keypair = await createKeyPairFromBytes(decodedKey);

    if (
      typeof config.initialInputToken !== 'string' ||
      typeof config.initialOutputToken !== 'string' ||
      typeof config.initialInputAmount !== 'number' ||
      typeof config.firstTradePrice !== 'number' ||
      !config.botId
    ) {
      throw new Error('Missing or invalid required config fields');
    }

    const inputToken = await getTokenDecimalsByName(config.initialInputToken);
    const outputToken = await getTokenDecimalsByName(config.initialOutputToken);
    const tokenIn = await getTokenAddressByName(config.initialInputToken);
    const tokenOut = await getTokenAddressByName(config.initialOutputToken);
    const initialInputAmount = Number(config.initialInputAmount) * 10 ** inputToken.decimals;
    const firstTradePrice = Number(config.firstTradePrice) * 10 ** outputToken.decimals;

    const botConfig: TradeBotConfig = {
      botId: config.botId,
      wallet: keypair,
      firstTradePrice,
      rpc,
      subscriptions,
      targetGainPercentage: config.targetGainPercentage!,
      initialInputToken: tokenIn as Address,
      initialInputAmount,
      initialOutputToken: tokenOut as Address,
      stopLossPercentage: config.stopLossPercentage,
    };

    const bot = new TradeBot(botConfig, socket);
    this.activeBots.set(botConfig.botId, bot);
    return bot;
  }

  private async initializeMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<MultiBot> {
    const solanaEndpoint: string = ENV.solanaEndpoint!;
    const wallet: string = ENV.wallet!;
    const wssEndpoint: string = ENV.wss!;
    if (!solanaEndpoint || !wallet || !wssEndpoint) {
      logger.error('Required environment variables are not set');
      throw new Error('Required environment variables are not set');
    }

    const { rpc, subscriptions } = await createRpcClients({ solanaEndpoint, wssEndpoint });
    const decodedKey = new Uint8Array(bs58.decode(wallet));
    const keypair = await createKeyPairFromBytes(decodedKey);

    if (
      typeof config.initialInputToken !== 'string' ||
      typeof config.initialInputAmount !== 'number' ||
      !config.botId ||
      typeof config.targetGainPercentage !== 'number'
    ) {
      logger.error('Missing or invalid required config fields');
      throw new Error('Missing or invalid required config fields');
    }

    const inputToken = await getTokenDecimalsByName(config.initialInputToken);
    const tokenIn = await getTokenAddressByName(config.initialInputToken);
    // Store the raw amount without decimal multiplication
    const initialInputAmount = Number(config.initialInputAmount);

    const targetAmounts: Record<string, number> = {};
    if (config.targetAmounts) {
      for (const [tokenName, amount] of Object.entries(config.targetAmounts)) {
        try {
          const token = await getTokenDecimalsByName(tokenName);
          const tokenAddress = await getTokenAddressByName(tokenName);
          // Store target amounts in raw form without decimal multiplication
          targetAmounts[tokenAddress] = Number(amount);
        } catch (error) {
          logger.error(`Failed to process target amount for token ${tokenName}: ${error}`);
          throw new Error(`Invalid token name: ${tokenName}`);
        }
      }
    }

    if (Object.keys(targetAmounts).length === 0) {
      throw new Error('At least one target token and amount must be specified for MultiBot');
    }

    const botConfig: MultiBotConfig & {
      targetAmounts: Record<string, number>;
      initialBalance: number;
      targetGainPercentage: number;
    } = {
      botId: config.botId,
      wallet: keypair,
      rpc,
      subscriptions,
      initialInputToken: tokenIn as Address,
      initialInputAmount,
      initialBalance: config.initialBalance ?? initialInputAmount,
      targetAmounts,
      targetGainPercentage: config.targetGainPercentage,
      stopLossPercentage: config.stopLossPercentage,
      checkInterval: config.checkInterval,
    };

    const bot = new MultiBot(botConfig, socket);
    this.activeMultiBots.set(botConfig.botId, bot);
    return bot;
  }

  public async startBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<void> {
    try {
      if (!config.botId) {
        throw new Error('botId is required');
      }
      const bot = await this.initializeBot({ ...config, botId: config.botId }, socket);
      await this.configService.updateBotStatus(config.botId, 'active');
    } catch (error) {
      console.error('Failed to start bot:', error);
      throw error;
    }
  }

  public async startMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<void> {
    try {
      if (!config.botId) {
        throw new Error('botId is required');
      }
      const bot = await this.initializeMultiBot({ ...config, botId: config.botId }, socket);
      await this.configService.updateBotStatus(config.botId, 'active');
    } catch (error) {
      console.error('Failed to start multi bot:', error);
      throw error;
    }
  }

  public async stopBot(botId: string): Promise<void> {
    const bot = this.activeBots.get(botId);
    if (bot) {
      bot.terminateSession();
      this.activeBots.delete(botId);
      await this.configService.updateBotStatus(botId, 'inactive');
    }

    const multiBot = this.activeMultiBots.get(botId);
    if (multiBot) {
      multiBot.terminateSession();
      this.activeMultiBots.delete(botId);
      await this.configService.updateBotStatus(botId, 'inactive');
    }
  }

  private serializeForSocket(data: any): any {
    if (data === null || data === undefined) {
      return data;
    }
    
    if (typeof data === 'bigint') {
      return data.toString();
    }
    
    if (Array.isArray(data)) {
      return data.map(this.serializeForSocket.bind(this));
    }
    
    if (typeof data === 'object') {
      const result: any = {};
      for (const [key, value] of Object.entries(data)) {
        result[key] = this.serializeForSocket(value);
      }
      return result;
    }
    
    return data;
  }

  public async getBotStatus(botId: string): Promise<BotResponse> {
    const bot = this.activeBots.get(botId);
    if (bot) {
      return this.serializeForSocket({
        botId,
        status: bot.status,
        difference: bot.difference,
        currentTrade: bot.currentTrade,
        ratio: bot.ratio,
        tradeCounter: bot.tradeCounter
      });
    }

    const multiBot = this.activeMultiBots.get(botId);
    if (multiBot) {
      return this.serializeForSocket({
        botId,
        status: multiBot.status,
        difference: multiBot.difference,
        currentTrade: multiBot.currentTrade,
        tradeCounter: multiBot.tradeCounter
      });
    }

    // If bot is not found in either activeBots or activeMultiBots, return an empty object with botId and status 'inactive'
    return this.serializeForSocket({
      botId,
      status: 'inactive'
    });
  }

  public async getAllBots(): Promise<{
    regularBots: (Partial<Config> & { botId: string; status: string })[];
    multiBots: (MultiConfig & { botId: string; status: string; targetAmounts: TargetAmount[] })[];
  }> {
    const { regularBots, multiBots } = await this.configService.getAllConfigs();
    return this.serializeForSocket({
      regularBots: regularBots.map(bot => ({
        ...bot,
        status: this.activeBots.has(bot.botId) ? 'active' : 'inactive'
      })),
      multiBots: multiBots.map(bot => ({
        ...bot,
        status: this.activeMultiBots.has(bot.botId) ? 'active' : 'inactive'
      }))
    });
  }

  public async getConfigs() {
    const { regularBots, multiBots } = await this.configService.getAllConfigs();
    return this.serializeForSocket({
      regularBots: regularBots.map((bot: Config) => ({
        ...bot,
        status: this.activeBots.has(bot.botId) ? 'active' : 'inactive'
      })),
      multiBots: multiBots.map((bot: MultiConfig & { targetAmounts: TargetAmount[] }) => ({
        ...bot,
        status: this.activeMultiBots.has(bot.botId) ? 'active' : 'inactive'
      }))
    });
  }

  public async deleteConfig(botId: string, type: 'regular' | 'multi'): Promise<void> {
    try {
      if (type === 'regular') {
        await this.configService.deleteConfig(botId);
      } else {
        await this.configService.deleteMultiConfig(botId);
      }
    } catch (error) {
      logger.error(`Error deleting configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to delete configuration');
    }
  }

  public async updateBotConfig(botId: string, config: Partial<TradeBotConfig>): Promise<void> {
    try {
      // First stop the bot if it's running
      await this.stopBot(botId);
      // Update the configuration, ensuring stopLossPercentage is a number or null if present
      const configToUpdate = { 
        ...config, 
        stopLossPercentage: config.stopLossPercentage !== undefined 
          ? config.stopLossPercentage === null 
            ? null 
            : Number(config.stopLossPercentage) 
          : config.stopLossPercentage 
      };
      await this.configService.updateBotConfig(botId, configToUpdate);
    } catch (error) {
      logger.error(`Error updating bot configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to update configuration');
    }
  }

  public async updateMultiBotConfig(botId: string, config: Partial<MultiBotConfig>): Promise<void> {
    try {
      // First stop the bot if it's running
      await this.stopBot(botId);
      
      // Update the configuration
      await this.configService.updateMultiBotConfig(botId, config);
    } catch (error) {
      logger.error(`Error updating multi-bot configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to update multi-bot configuration');
    }
  }
}

================
File: core/multibot.ts
================
import { QuoteResponse, BotData, MultiBotConfig } from "./types.js";
import logger from "../utils/logger.js";
import { address, Address, createSolanaRpcSubscriptions, getAddressFromPublicKey, Rpc, SolanaRpcApiMainnet } from "@solana/kit";
import { getTokenDecimalsByAddress, getTokenDecimalsByAddressRaw, getTokenName } from "../utils/helper.js";
import { TradeService } from "../services/tradeService.js";
import { NotificationService } from "../services/notificationService.js";
import { Socket } from "socket.io-client";

/**
 * Manages automated trading operations for a specific bot instance on the Solana blockchain.
 * This class starts with a single token balance, monitors trade ratios for multiple token pairs,
 * executes trades when targets are met, and updates target ratios based on a gain percentage.
 */
export class MultiBot {
  // Public properties
  public readonly botId: string;
  public status: BotStatus;
  public difference: number;
  public ratio: number;
  public currentTrade: number;
  public currentMint: Address;
  public currentTokenAccount: Address;
  public initialBalance: number;
  public targetAmounts: Record<string, number>;
  public targetGainPercentage: number;
  public checkInterval: number;
  public tradeCounter: number;
  public waitingForConfirmation: boolean = false;

  // Private properties
  private readonly wallet: CryptoKeyPair;
  private readonly rpc: Rpc<SolanaRpcApiMainnet>;
  private readonly subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
  private readonly socket: Socket;
  private readonly tradeService: TradeService;
  private readonly notificationService: NotificationService;
  private priceWatchIntervalId?: NodeJS.Timeout;
  private lastCheck: number;
  private stopped: boolean;

  constructor(
    config: MultiBotConfig & { targetAmounts: Record<string, number>; initialBalance: number; targetGainPercentage: number },
    socket: Socket,
  ) {
    if (!config.rpc) {
      throw new Error('RPC client is required');
    }
    if (!config.subscriptions) {
      throw new Error('Subscriptions client is required');
    }

    logger.info(`[Bot ${config.botId}] Constructing new MultiBot instance`);
    this.botId = config.botId;
    this.wallet = config.wallet;
    this.rpc = config.rpc;
    this.subscriptions = config.subscriptions;
    this.socket = socket;
    this.difference = 0;
    this.currentTrade = 0;
    this.ratio = 0;
    this.status = "Running";
    this.initialBalance = config.initialBalance;
    this.targetAmounts = config.targetAmounts;
    this.targetGainPercentage = config.targetGainPercentage;
    this.tradeCounter = 0;
    this.stopped = false;
    this.checkInterval = config.checkInterval || 20000;
    this.lastCheck = 0;
    this.currentMint = config.initialInputToken as Address;
    this.currentTokenAccount = config.initialInputToken as Address;

    this.tradeService = new TradeService(
      this.botId,
      this.wallet,
      this.rpc,
      this.subscriptions,
      this.postTransactionProcessing.bind(this),
      this.setWaitingForConfirmation.bind(this)
    );
    this.notificationService = new NotificationService();

    logger.info(`[Bot ${this.botId}] Starting initialization`);
    this.init().catch((error) => {
      const errorMsg = `[Bot ${this.botId}] Initialization failed: ${error instanceof Error ? error.message : String(error)}`;
      logger.error(errorMsg);
    });
  }

  async init(): Promise<void> {
    const tokenName = await getTokenName(this.currentMint); // Use mint for token name
    const logMsg = `[Bot ${this.botId}] Initiating trade bot with ${this.initialBalance} ${tokenName}`;
    logger.info(logMsg);

    logger.info(`[Bot ${this.botId}] Fetching public key from wallet`);
    const pubWallet = await getAddressFromPublicKey(this.wallet.publicKey);
    if (!pubWallet) {
      const errorMsg = `[Bot ${this.botId}] Error fetching public key`;
      logger.error(errorMsg);
      throw new Error("Error fetching public key. Make sure keypair provided is set and valid.");
    }
    logger.info(`[Bot ${this.botId}] Public key fetched: ${pubWallet}`);

    logger.info(`[Bot ${this.botId}] Fetching token account for ${tokenName} (${this.currentMint})`);
    this.currentTokenAccount = await this.tradeService.getFilteredTokenAccounts(pubWallet as Address, this.currentMint) as Address;
    logger.info(`[Bot ${this.botId}] Token account updated: ${this.currentTokenAccount}`);

    const MAX_RETRIES = 3;
    let retries = 0;
    let balance: number | undefined;

    logger.info(`[Bot ${this.botId}] Starting balance refresh for ${tokenName}`);
    while (retries < MAX_RETRIES) {
      try {
        logger.info(`[Bot ${this.botId}] Refreshing balance, attempt ${retries + 1}/${MAX_RETRIES}`);
        balance = this.initialBalance
        logger.info(`[Bot ${this.botId}] Balance fetched: ${balance}`);
        if (balance === undefined || balance < this.initialBalance) {
          const errorMsg = `[Bot ${this.botId}] Insufficient initial balance: ${balance} < ${this.initialBalance}`;
          logger.error(errorMsg);
          throw new Error(errorMsg);
        }
        break;
      } catch (error) {
        retries++;
        const errorMsg = `[Bot ${this.botId}] Error refreshing balance, attempt ${retries}/${MAX_RETRIES}: ${error instanceof Error ? error.message : String(error)}`;
        logger.error(errorMsg);
        if (retries >= MAX_RETRIES) {
          const retryErrorMsg = `[Bot ${this.botId}] Failed to refresh balance after ${MAX_RETRIES} retries`;
          logger.error(retryErrorMsg);
          throw new Error(retryErrorMsg);
        }
        logger.info(`[Bot ${this.botId}] Retrying after delay of ${1000 * retries}ms`);
        await new Promise((resolve) => setTimeout(resolve, 1000 * retries));
      }
    }

    if (balance !== undefined) {
      this.initialBalance = balance; // Update initialBalance with the actual balance
      logger.info(`[Bot ${this.botId}] Updated initial balance to ${this.initialBalance}`);
      logger.info(`[Bot ${this.botId}] Initiating price watch`);
      this.initiatePriceWatch();
    }
  }

  private initiatePriceWatch(): void {
    logger.info(`[Bot ${this.botId}] Starting price watch with interval ${this.checkInterval}ms`);
    this.priceWatchIntervalId = setInterval(async () => {
      if (this.stopped || !this.priceWatchIntervalId) {
        logger.info(`[Bot ${this.botId}] Price watch stopped`);
        clearInterval(this.priceWatchIntervalId);
        this.priceWatchIntervalId = undefined;
        return;
      }

      const currentTime = Date.now();
      if (currentTime - this.lastCheck < this.checkInterval) return;

      this.lastCheck = currentTime;

      if (this.waitingForConfirmation) {
        logger.info(`[Bot ${this.botId}] Waiting for transaction confirmation...`);
        return;
      }

      try {
        const timeout = setTimeout(() => {
          throw new Error("Quote fetch timed out");
        }, 40000);
        logger.info(`[Bot ${this.botId}] Checking trade opportunities...`);
        await this.checkTradeOpportunities();
        clearTimeout(timeout);
      } catch (error) {
        const errorMsg = `[Bot ${this.botId}] Error in price watch: ${error instanceof Error ? error.message : String(error)}`;
        logger.error(errorMsg);
      }
    }, this.checkInterval);
  }

  public setWaitingForConfirmation(flag: boolean): void {
    logger.info(`[Bot ${this.botId}] Setting waitingForConfirmation to ${flag}`);
    this.waitingForConfirmation = flag;
  }

  private async checkTradeOpportunities(): Promise<void> {
    const currentTokenName = await getTokenName(this.currentMint); // Use mint for token name

    const inputDecimals = await getTokenDecimalsByAddressRaw(this.currentMint);
    const amountInLamports = this.initialBalance * Math.pow(10, inputDecimals);

    for (const [targetMint, targetAmount] of Object.entries(this.targetAmounts)) {
      const targetTokenName = await getTokenName(targetMint as Address);
      logger.info(`[Bot ${this.botId}] Fetching quote for ${currentTokenName} -> ${targetTokenName} (${targetMint})`);

      const quote = await this.tradeService.getQuote2({
        inputMint: this.currentMint, // Use mint, not token account
        outputMint: targetMint as Address,
        amount: amountInLamports,
        swapMode: "ExactIn",
      });

      if (!quote || !quote.outAmount) {
        const logMsg = `[Bot ${this.botId}] No quote available for ${targetMint}`;
        logger.error(logMsg);
        continue;
      }

      const outputDecimals = await getTokenDecimalsByAddressRaw(targetMint as Address);
      const currentOutputAmount = parseInt(quote.outAmount) / Math.pow(10, outputDecimals);
      const targetOutputAmount = targetAmount; // Already in human-readable form
      logger.info(`[Bot ${this.botId}] Comparing amounts for ${targetMint}: Current=${currentOutputAmount}, Target=${targetOutputAmount}`);

      const ratioMet = currentOutputAmount >= targetOutputAmount;
      if (ratioMet) {
        logger.info(`[Bot ${this.botId}] Ratio met for ${targetTokenName}: ${currentOutputAmount} >= ${targetOutputAmount}. Executing trade...`);
        await this.executeTrade(targetMint as Address, currentOutputAmount);
        return;
      } else {
        const difference = ((currentOutputAmount - targetOutputAmount) / targetOutputAmount) * 100;
        this.currentTrade = currentOutputAmount;
        this.difference = difference;
        logger.info(`[Bot ${this.botId}] Ratio not met for ${targetTokenName}: Difference=${difference.toFixed(3)}% (Current=${currentOutputAmount}, Target=${targetOutputAmount})`);

        const botData: BotData = {
          botId: this.botId,
          status: this.stopped ? "Stopped" : "Running",
          inputMint: currentTokenName,
          outputMint: targetTokenName,
          currentPrice: currentOutputAmount, // Use currentOutputAmount directly
          targetTrade: targetOutputAmount,
          difference: difference,
          trades: this.tradeCounter
        };

        // Emit the bot data to update the dashboard
        this.emit('bot:difference', botData);
      }
    }
  }

  private async executeTrade(targetMint: Address, receivedAmount: number): Promise<void> {
    const targetTokenName = await getTokenName(targetMint);
    logger.info(`[Bot ${this.botId}] Executing trade to ${targetTokenName} (${targetMint}) with expected amount: ${receivedAmount}`);

    logger.info(`[Bot ${this.botId}] Fetching quote for trade`);
    const inputDecimals = await getTokenDecimalsByAddressRaw(this.currentMint);
    const amountInLamports = this.initialBalance * Math.pow(10, inputDecimals);

    const quote = await this.tradeService.getQuote2({
      inputMint: this.currentMint, // Use mint, not token account
      outputMint: targetMint,
      amount: amountInLamports,
      swapMode: "ExactIn",
    });

    if (!quote) {
      const errorMsg = `[Bot ${this.botId}] Failed to fetch quote for trade to ${targetTokenName}`;
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }

    logger.info(`[Bot ${this.botId}] Quote for trade: ${JSON.stringify(quote)}`);
    await this.tradeService.evaluateQuoteAndSwap(quote, this.initialBalance);
    logger.info(`[Bot ${this.botId}] Trade submitted for ${targetTokenName}`);
  }

  public postTransactionProcessing = async (quote: QuoteResponse, txid: string): Promise<void> => {
    const { inputMint, inAmount, outputMint, outAmount } = quote;
    const inputTokenName = await getTokenName(inputMint);
    const outputTokenName = await getTokenName(outputMint);
    logger.info(`[Bot ${this.botId}] Processing completed transaction: ${inputTokenName} -> ${outputTokenName}, TxID: ${txid}`);

    const outputDecimals = await getTokenDecimalsByAddressRaw(outputMint as Address);
    const inputDecimals = await getTokenDecimalsByAddressRaw(inputMint as Address);
    const receivedAmount = parseInt(outAmount) / Math.pow(10, outputDecimals);
    logger.info(`[Bot ${this.botId}] Expected to receive ${receivedAmount} ${outputTokenName}`);

    // Update the mint and token account after the trade
    this.currentMint = outputMint as Address;
    const pubWallet = await getAddressFromPublicKey(this.wallet.publicKey);
    if (!pubWallet) {
      const errorMsg = `[Bot ${this.botId}] Error fetching public key after trade`;
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }

    logger.info(`[Bot ${this.botId}] Fetching new token account for ${outputTokenName} (${this.currentMint})`);
    this.currentTokenAccount = await this.tradeService.getFilteredTokenAccounts(pubWallet, this.currentMint) as Address;
    if (!this.currentTokenAccount) {
      const errorMsg = `[Bot ${this.botId}] Failed to fetch token account for ${outputTokenName} (${this.currentMint})`;
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    logger.info(`[Bot ${this.botId}] Updated current token account to ${this.currentTokenAccount}`);

    // Verify the actual balance after the trade
    logger.info(`[Bot ${this.botId}] Verifying balance for new token account ${this.currentTokenAccount}`);
    const actualBalance = receivedAmount;
    if (actualBalance === undefined || actualBalance <= 0) {
      const errorMsg = `[Bot ${this.botId}] Invalid balance after trade: ${actualBalance} ${outputTokenName}`;
      logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    this.initialBalance = actualBalance;
    logger.info(`[Bot ${this.botId}] Updated current mint to ${outputTokenName} (${this.currentMint}) with verified balance ${this.initialBalance}`);

    // Update target amounts with the gain factor
    const gainFactor = 1 + (this.targetGainPercentage / 100);
    logger.info(`[Bot ${this.botId}] Updating target amounts with gain factor ${gainFactor} (${this.targetGainPercentage}%)`);
    this.targetAmounts = Object.fromEntries(
      Object.entries(this.targetAmounts).map(([mint, amount]) => {
        if (mint === outputMint) {
          const gain = Number(inAmount) * gainFactor;
          const newAmount = gain / Math.pow(10, inputDecimals);
          const newMint = inputMint as Address;
          return [newMint, newAmount];
        }
        return [mint, amount * gainFactor];
      })
    )

    const logAmount = await getTokenDecimalsByAddress(inputMint as Address, parseFloat(inAmount));
    const logOutAmount = await getTokenDecimalsByAddress(outputMint as Address, parseFloat(outAmount));
    logger.info(`[Bot ${this.botId}] Logging swap: ${logAmount} ${inputTokenName} -> ${logOutAmount} ${outputTokenName}`);
    await this.notificationService.logSwap({
      botId: this.botId,
      tokenIn: address(inputMint),
      tokenInAmount: logAmount ?? 0,
      tokenInUSD: 0,
      tokenOut: address(outputMint),
      tokenOutAmount: logOutAmount ?? 0,
      tokenOutUSD: 0,
      totalValueUSD: 0,
      txid,
      date: new Date(),
    });

    this.tradeCounter += 1;
    const tradeMsg = `[Bot ${this.botId}] Trade completed: Swapped ${inputTokenName} for ${outputTokenName} (TxID: ${txid})`;
    logger.info(tradeMsg);
  };

  public terminateSession(): void {
    logger.info(`[Bot ${this.botId}] Terminating bot...`);
    this.notificationService.log(`[Bot ${this.botId}] ❌ Terminating bot...`, (this.botId));
    this.stopped = true;

    if (this.priceWatchIntervalId) {
      clearInterval(this.priceWatchIntervalId);
      this.priceWatchIntervalId = undefined;
    }

    logger.info(`[Bot ${this.botId}] Bot terminated successfully`);
    this.notificationService.log(`[Bot ${this.botId}] Bot terminated successfully`, (this.botId));
  }

  private serializeForSocket(data: any): any {
    if (data === null || data === undefined) {
      return data;
    }

    if (typeof data === 'bigint') {
      return data.toString();
    }

    if (Array.isArray(data)) {
      return data.map(this.serializeForSocket.bind(this));
    }

    if (typeof data === 'object') {
      const result: any = {};
      for (const [key, value] of Object.entries(data)) {
        result[key] = this.serializeForSocket(value);
      }
      return result;
    }

    return data;
  }

  private emit(event: string, data: any) {
    this.socket.emit(event, this.serializeForSocket(data));
  }
}

// Add type for bot status
type BotStatus = "Running" | "Stopped";

export default MultiBot;

================
File: core/types.ts
================
import { RoutePlanStep} from "@jup-ag/api";
import { Address, Rpc, createSolanaRpcSubscriptions, SolanaRpcApiMainnet } from "@solana/kit";
import { DefaultBotManager } from "./botManager.js";
import { Socket } from "socket.io-client";
import { MultiConfig, TargetAmount } from "@prisma/client";
import { Config } from "jest";
import { TradeBot } from "./bot.js";
import MultiBot from "./multibot.js";

// Utility type for BigInt values that can be safely converted to/from numbers
export type SafeBigInt = bigint;

// Utility type for percentage values (0-100) stored as BigInt
export type PercentageBigInt = SafeBigInt;

// Utility functions for handling BigInt values
export const BigIntUtils = {
  // Convert a number to BigInt, handling decimal places
  fromNumber: (value: number, decimals: number = 0): SafeBigInt => {
    const multiplier = Math.pow(10, decimals);
    return BigInt(Math.floor(value * multiplier));
  },

  // Convert a BigInt back to a number, handling decimal places
  toNumber: (value: SafeBigInt, decimals: number = 0): number => {
    const divisor = Math.pow(10, decimals);
    return Number(value) / divisor;
  },

  // Convert a percentage (0-100) to BigInt
  fromPercentage: (percentage: number): PercentageBigInt => {
    return BigInt(Math.floor(percentage * 100)); // Store as basis points (1% = 100)
  },

  // Convert a BigInt percentage back to a number
  toPercentage: (value: PercentageBigInt): number => {
    return Number(value) / 100; // Convert from basis points
  },

  // Safe division of BigInt by number
  divide: (value: SafeBigInt, divisor: number): SafeBigInt => {
    return value / BigInt(Math.floor(divisor));
  },

  // Safe multiplication of BigInt by number
  multiply: (value: SafeBigInt, multiplier: number): SafeBigInt => {
    return value * BigInt(Math.floor(multiplier));
  }
};

export interface NewConfig {
  botId: string;
  inputToken: string;
  outputToken: string;
  inputAmount: number;
  firstTradePrice: number;
  targetGainPercentage: number;
  stopLossPercentage?: SafeBigInt;
}

export interface BotData {
  botId: string;
  status: string;
  balance?: number;
  inputMint: string;
  outputMint: string;
  targetTrade: number;
  difference?: number;
  tokenInPrice?: number;
  tokenOutPrice?: number;
  currentPrice: number;
  targetGainPercentage?: number;
  inBalance?: number;
  outBalance?: number;
  trades?: number;
  ratio?: number;
}

export interface TokenAccountInfo {
  pubkey: string;
  mint: string;
  balance: number;
}

export interface LogSwapArgs {
  botId: string;
  tokenIn: string;
  tokenInAmount: number;
  tokenOut: string;
  tokenOutAmount: number;
  tokenInUSD: number;
  tokenOutUSD: number;
  totalValueUSD: number;
  txid: string;
  date: Date;
}

export interface EmailArgs {
  subject: string;
  text: string;
}

export interface TradeBotConfig {
  botId: string;
  wallet: CryptoKeyPair;
  rpc: Rpc<SolanaRpcApiMainnet>;
  subscriptions?: ReturnType<typeof createSolanaRpcSubscriptions>;
  firstTradePrice: number;
  stopLossPercentage?: PercentageBigInt;
  targetGainPercentage: number;
  checkInterval?: number;
  initialInputToken: string;
  initialInputAmount: number;
  initialOutputToken: string;
}

export interface MultiBotConfig {
  botId: string;
  wallet: CryptoKeyPair;
  rpc: Rpc<SolanaRpcApiMainnet>;
  subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
  initialInputToken?: string;
  initialInputAmount?: number;
  initialBalance?: number;
  targetAmounts?: Record<string, number>;
  targetGainPercentage?: number;
  stopLossPercentage?: number;
  checkInterval?: number;
}

export interface targetAmounts {
  outputMint: Address;
  amount: number;
}


// Extend the price target to QuoteGetRequest
export interface NextTrade extends QuoteGetRequest { }

declare const SwapMode: {
  readonly ExactIn: "ExactIn";
  readonly ExactOut: "ExactOut";
};
type SwapMode = (typeof SwapMode)[keyof typeof SwapMode];
export type PriorityLevel = "low" | "medium" | "high" | "very high";

interface QuoteGetRequest {
  inputMint: string;
  outputMint: string;
  amount: number;
  slippageBps?: number;
  autoSlippage?: boolean;
  maxAutoSlippageBps?: number;
  swapMode?: string;
  dexes?: Array<string>;
  excludeDexes?: Array<string>;
  restrictIntermediateTokens?: boolean;
  onlyDirectRoutes?: boolean;
  asLegacyTransaction?: boolean;
  platformFeeBps?: number;
  maxAccounts?: number;
  prioritizationFeeLamports?: {
    priorityLevelWithMaxLamports: {
      maxLamports: number;
      priorityLevel: PriorityLevel;
    };
  };
}

interface LogEntry {
  level: 'info' | 'error' | 'warn';
  timestamp: string;
  message: string;
  stack?: string;
  context?: Record<string, any>;
}


interface QuoteResponse {
  inputMint: string;
  inAmount: string;
  outputMint: string;
  outAmount: string;
  otherAmountThreshold: string;
  swapMode: SwapMode;
  slippageBps: number;
  feeAccount?: string;
  autoSlippage?: boolean;
  maxAutoSlippageBps?: number;
  platformFee?: {
    amount: string;
    feeBps: number
  }
  priceImpactPct: string;
  routePlan: Array<RoutePlanStep>;
  contextSlot?: number;
  timeTaken?: number;
}

interface QuicknodeConfig {
  endpoint: string;
  jupiterApi?: string;
  wssEndpoint?: string;
  computeMargin?: number;
}

interface QuicknodeRpcConfig {
  wssEndpoint: string;
}

interface CreateAddonsApiParams {
  endpoint: string;
  jupiterApi?: string;
}


export type {
  QuoteGetRequest,
  QuoteResponse,
  QuicknodeConfig,
  QuicknodeRpcConfig,
  CreateAddonsApiParams,
  LogEntry,
};
export interface Tags {
  verified?: string;
  unverified?: string;
  lst?: string;
  strict?: string;
  community?: string;
  pump?: string;
  clone?: string;
};

export type TokenInfo = {
  address: string;
  name: string;
  symbol: string;
  decimals: number;
  logoURI: string;
}

export interface BotResponse {
  botId: string;
  status: string;
}

export interface MultiBotResponse {
  botId: string;
  status: string;
  targetAmounts: targetAmounts[];
}

export type BotStatus = "Running" | "Stopped" | "active" | "inactive";

export interface Bot {
  botId: string;
  status: BotStatus;
  amount: number;
  initialInputToken: string;
  initialOutputToken?: string;
}

export interface BotWithType extends Bot {
  type: 'regular' | 'multi';
  firstTradePrice?: bigint;
  targetGainPercentage?: bigint;
  stopLossPercentage?: bigint;
  checkInterval?: number;
  targetAmounts?: Array<{
    tokenAddress: string;
    amount: number;
  }>;
}

export interface ConfigListState {
  regularBots: Array<{
    botId: string;
    initialInputToken: string;
    initialOutputToken: string;
    initialInputAmount: number;
    firstTradePrice: number;
    targetGainPercentage: number;
    stopLossPercentage?: number;
    status: BotStatus;
  }>;
  multiBots: Array<{
    botId: string;
    initialInputToken: string;
    initialInputAmount: number;
    targetGainPercentage: number;
    stopLossPercentage?: number;
    checkInterval?: number;
    status: BotStatus;
    targetAmounts: Array<{
      id: number;
      configId: string;
      tokenAddress: string;
      amount: number;
    }>;
  }>;
}

export interface BotInitializer {
  initializeBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<TradeBot>;
  initializeMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<MultiBot>;
}

export interface BotManager {
  activeBots: Map<string, TradeBot>;
  activeMultiBots: Map<string, MultiBot>;
  startBot(config: Partial<TradeBotConfig>, socket: Socket): Promise<void>;
  startMultiBot(config: Partial<MultiBotConfig>, socket: Socket): Promise<void>;
  stopBot(botId: string): Promise<void>;
  getBotStatus(botId: string): Promise<any>;
  getAllBots(): Promise<{
    regularBots: Array<Config & { status: string }>;
    multiBots: Array<MultiConfig & { status: string; targetAmounts: TargetAmount[] }>;
  }>;
  deleteConfig(botId: string, type: 'regular' | 'multi'): Promise<void>;
  updateBotConfig(botId: string, config: Partial<TradeBotConfig>): Promise<void>;
  updateMultiBotConfig(botId: string, config: Partial<MultiBotConfig>): Promise<void>;
}

export type SortField = 'type' | 'amount' | 'status';
export type SortDirection = 'asc' | 'desc';
export type FilterType = 'all' | 'active' | 'inactive';

export interface ConfigListProps {
  onBack: () => void;
  botManager: DefaultBotManager;
  socket: Socket;
}

export interface RegularBotFormProps {
  onComplete: () => void;
  botManager: DefaultBotManager;
  socket: Socket;
  editingConfig?: BotWithType | null;
}

export interface MultiBotFormProps {
  onComplete: () => void;
  botManager: DefaultBotManager;
  socket: Socket;
  editingConfig?: BotWithType | null;
}

================
File: scripts/run-cli.js
================
#!/usr/bin/env node

import { spawn } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Get the path to tsx - use the .cmd extension for Windows
const tsxPath = join(process.cwd(), 'node_modules', '.bin', 'tsx.cmd');

// Get the correct path to cli.ts
const cliPath = join(process.cwd(), 'src', 'cli.ts');

// Spawn the CLI process with proper terminal control
const cli = spawn(tsxPath, [cliPath], {
  stdio: 'inherit',
  env: {
    ...process.env,
    FORCE_COLOR: '1'
  },
  shell: true // Add shell option for Windows compatibility
});

cli.on('error', (err) => {
  console.error('Failed to start CLI:', err);
  process.exit(1);
});

cli.on('exit', (code) => {
  process.exit(code);
});

================
File: scripts/seedTokens.ts
================
import { fetchTokenList } from '../services/tokenDataService.js';
import logger from '../utils/logger.js';
import prisma from '../utils/prismaClient.js';

async function seedTokens() {
  try {
    logger.info('Starting token database seeding...');
    
    // Check if we have any tokens in the database
    const existingTokens = await prisma.token.findMany({
      take: 1
    });

    if (existingTokens.length === 0) {
      logger.info('No tokens found in database, fetching from Jupiter API...');
      await fetchTokenList();
    } else {
      logger.info('Tokens already exist in database, skipping fetch...');
    }

    logger.info('Token database seeding completed successfully');
  } catch (error) {
    logger.error(`Failed to seed token database: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

seedTokens();

================
File: server.ts
================
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { ENV } from './config/index.js';
import cors from 'cors';
import logger from './utils/logger.js';
import { ConfigService } from './services/configService.js';
import { getSingleTokenData } from './services/tokenDataService.js';
import { fetchTokenList } from './services/tokenDataService.js';
import prisma from './utils/prismaClient.js';

const app = express();
app.use(cors());
app.use(express.json());

const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

const configService = new ConfigService();

// Helper function to serialize data for socket transmission
const serializeForSocket = (data: any): any => {
  if (data === null || data === undefined) {
    return data;
  }

  if (typeof data === 'bigint') {
    return data.toString();
  }

  if (Array.isArray(data)) {
    return data.map(serializeForSocket);
  }

  if (typeof data === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(data)) {
      result[key] = serializeForSocket(value);
    }
    return result;
  }

  return data;
};

// API Endpoints
app.get('/api/configs', async (req, res) => {
  try {
    const configs = await configService.getAllConfigs();
    res.json(serializeForSocket(configs));
  } catch (error) {
    logger.error('Error fetching configs:', error);
    res.status(500).json({ error: 'Failed to fetch configurations' });
  }
});

app.get('/api/token/:mint', async (req, res) => {
  try {
    const { mint } = req.params;
    const tokenData = await getSingleTokenData(mint);
    if (!tokenData) {
      res.status(404).json({ error: 'Token not found' });
      return;
    }
    res.json(serializeForSocket(tokenData));
  } catch (error) {
    logger.error('Error fetching token data:', error);
    res.status(500).json({ error: 'Failed to fetch token data' });
  }
});

// Socket.IO connection handling
io.on('connection', (socket) => {
  logger.info('Client connected:', socket.id);

  socket.on('disconnect', () => {
    logger.info('Client disconnected:', socket.id);
  });

  socket.on('error', (error) => {
    logger.error('Socket error:', error);
  });

  // Handle config requests
  socket.on('config:get', async () => {
    try {
      const configs = await configService.getAllConfigs();
      socket.emit('config:update', serializeForSocket(configs));
    } catch (error) {
      logger.error('Error fetching configs for socket:', error);
      socket.emit('error', { message: 'Failed to fetch configurations' });
    }
  });

  // Handle bot events
  socket.on('bot:start', (data) => {
    logger.info('Bot start requested:', serializeForSocket(data));
    socket.emit('bot:start', serializeForSocket(data));
  });

  socket.on('bot:stop', (data) => {
    logger.info('Bot stop requested:', serializeForSocket(data));
    socket.emit('bot:stop', serializeForSocket(data));
  });

  socket.on('bot:difference', (data) => {
    // Broadcast the difference update to all connected clients
    io.emit('bot:difference', serializeForSocket(data));
  });

  socket.on('log', (data) => {
    // Only log to server, don't broadcast to clients
    logger.info('Bot log:', serializeForSocket(data));
  });
});

// Start the server
const PORT = ENV.PORT || 4000;
const server = httpServer.listen(PORT, async () => {
  logger.info(`Server running on port ${PORT}`);
  try {
    await fetchTokenList(false); // Force update on server startup
    logger.info('Token list initialized');
  } catch (error) {
    logger.error('Failed to initialize token list:', error);
  }
});

// Handle cleanup and graceful shutdown
export const cleanup = async () => {
  logger.info('Starting server shutdown...');

  // Set a timeout to force shutdown if cleanup takes too long
  const forceShutdown = setTimeout(() => {
    logger.error('Forced shutdown after timeout');
    process.exit(1);
  }, 10000); // 10 seconds timeout

  try {
    // Stop accepting new connections
    logger.info('Stopping new connections...');
    server.close();

    // Close all socket connections
    logger.info('Closing socket connections...');
    if (io) {
      // Disconnect all clients
      io.sockets.sockets.forEach((socket) => {
        socket.disconnect(true);
      });
      io.close();
    }

    // Give some time for existing connections to close
    logger.info('Waiting for existing connections to close...');
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Close the HTTP server
    if (server) {
      logger.info('Closing HTTP server...');
      await new Promise<void>((resolve, reject) => {
        server.close((err) => {
          if (err) {
            logger.error('Error closing HTTP server:', err);
            reject(err);
          } else {
            logger.info('HTTP server closed successfully');
            resolve();
          }
        });
      });
    }

    // Disconnect from database
    logger.info('Disconnecting from database...');
    await prisma.$disconnect();
    logger.info('Database disconnected successfully');

    // Clear the force shutdown timeout
    clearTimeout(forceShutdown);

    logger.info('Server shutdown complete');
    process.exit(0);
  } catch (error) {
    logger.error('Error during cleanup:', error);
    process.exit(1);
  }
};

// Handle signals
process.on('SIGINT', () => {
  logger.info('Received SIGINT signal (Ctrl+C)');
  // Prevent multiple cleanup calls
  process.removeAllListeners('SIGINT');
  cleanup();
});

process.on('SIGTERM', () => {
  logger.info('Received SIGTERM signal');
  // Prevent multiple cleanup calls
  process.removeAllListeners('SIGTERM');
  cleanup();
});

// Handle uncaught errors
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error);
  cleanup();
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
  cleanup();
});

================
File: services/configService.ts
================
import { PrismaClient, Config, MultiConfig, TargetAmount } from '@prisma/client';
import logger from '../utils/logger.js';

export class ConfigService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  private convertStopLossPercentage(value: bigint | number | null | undefined): number | null {
    if (value === null || value === undefined) return null;
    return typeof value === 'bigint' ? Number(value) : value;
  }

  async addConfig(data: {
    botId: string;
    initialInputToken: string;
    initialOutputToken: string;
    initialInputAmount: number;
    firstTradePrice: number;
    targetGainPercentage: number;
    stopLossPercentage?: bigint | number;
  }) {
    try {
      const dbData = {
        ...data,
        stopLossPercentage: this.convertStopLossPercentage(data.stopLossPercentage),
      };
      // Check if config exists
      const existingConfig = await this.prisma.config.findUnique({
        where: { botId: data.botId }
      });

      if (existingConfig) {
        // Update existing config
        const updatedConfig = await this.prisma.config.update({
          where: { botId: data.botId },
          data: dbData
        });
        return updatedConfig;
      }

      // Create new config if it doesn't exist
      const newConfig = await this.prisma.config.create({
        data: dbData
      });
      return newConfig;
    } catch (error) {
      logger.error(`Error adding new configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to add configuration');
    }
  }

  async addMultiConfig(data: {
    botId: string;
    initialInputToken: string;
    initialInputAmount: number;
    targetGainPercentage: number;
    stopLossPercentage?: bigint | number;
    checkInterval?: number;
    targetAmounts: Record<string, number>;
  }) {
    try {
      const { targetAmounts, ...configData } = data;
      
      // Create the multi config first
      const newConfig = await this.prisma.multiConfig.create({
        data: {
          ...configData,
          stopLossPercentage: this.convertStopLossPercentage(configData.stopLossPercentage),
          checkInterval: configData.checkInterval ?? null,
        }
      });

      // Then create target amounts with proper IDs
      const targetAmountEntries = Object.entries(targetAmounts).map(([tokenAddress, amount]) => ({
        tokenAddress,
        amount,
        configId: newConfig.botId
      }));

      if (targetAmountEntries.length > 0) {
        await this.prisma.targetAmount.createMany({
          data: targetAmountEntries
        });
      }

      return newConfig;
    } catch (error) {
      logger.error("Error adding new multi-bot configuration:", error);
      throw new Error("Failed to add multi-bot configuration");
    }
  }

  async getAllConfigs(): Promise<{
    regularBots: Array<Config & { status: string }>;
    multiBots: Array<MultiConfig & { status: string; targetAmounts: TargetAmount[] }>;
  }> {
    try {
      const regularBots = await this.prisma.config.findMany();
      const multiBots = await this.prisma.multiConfig.findMany({
        include: {
          targetAmounts: true
        }
      });

      return {
        regularBots: regularBots.map((bot: Config) => ({
          ...bot,
          status: "inactive" // Default status
        })),
        multiBots: multiBots.map((bot: MultiConfig & { targetAmounts: TargetAmount[] }) => ({
          ...bot,
          status: "inactive" // Default status
        }))
      };
    } catch (error) {
      logger.error(`Error getting all configurations: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error('Failed to get configurations');
    }
  }

  async deleteConfig(botId: string) {
    try {
      const deletedConfig = await this.prisma.config.delete({
        where: { botId },
      });
      return deletedConfig;
    } catch (error) {
      logger.error(`Error deleting configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error("Failed to delete configuration");
    }
  }

  async deleteMultiConfig(botId: string) {
    try {
      const deletedConfig = await this.prisma.multiConfig.delete({
        where: { botId },
      });
      return deletedConfig;
    } catch (error) {
      logger.error(`Error deleting multi-bot configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error("Failed to delete multi-bot configuration");
    }
  }

  async updateBotConfig(botId: string, newConfig: Partial<Config>) {
    try {
      const updatedBot = await this.prisma.config.update({
        where: { botId },
        data: {
          ...newConfig,
          stopLossPercentage: this.convertStopLossPercentage(newConfig.stopLossPercentage as bigint | number | null | undefined)
        },
      });
      return updatedBot;
    } catch (error) {
      logger.error(`Failed to update bot configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error("Failed to update configuration");
    }
  }

  async updateMultiBotConfig(botId: string, newConfig: {
    initialInputToken?: string;
    initialInputAmount?: number;
    targetGainPercentage?: number;
    stopLossPercentage?: bigint | number;
    checkInterval?: number;
    targetAmounts?: Record<string, number>;
  }) {
    try {
      const { targetAmounts, ...configData } = newConfig;

      // Update the multi config
      const updatedConfig = await this.prisma.multiConfig.update({
        where: { botId },
        data: {
          ...configData,
          stopLossPercentage: this.convertStopLossPercentage(configData.stopLossPercentage),
          checkInterval: configData.checkInterval ?? null,
        },
        include: {
          targetAmounts: true,
        },
      });

      // If target amounts are provided, update them
      if (targetAmounts) {
        // Remove old target amounts
        await this.prisma.targetAmount.deleteMany({
          where: { configId: botId }
        });

        // Add new target amounts
        const targetAmountEntries = Object.entries(targetAmounts).map(([tokenAddress, amount]) => ({
          tokenAddress,
          amount,
          configId: botId
        }));

        if (targetAmountEntries.length > 0) {
          await this.prisma.targetAmount.createMany({
            data: targetAmountEntries
          });
        }
      }

      return updatedConfig;
    } catch (error) {
      logger.error(`Failed to update multi-bot configuration: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error("Failed to update multi-bot configuration");
    }
  }

  async getMultiConfig(botId: string): Promise<MultiConfig | null> {
    try {
      return await this.prisma.multiConfig.findUnique({
        where: { botId },
        include: {
          targetAmounts: true
        }
      });
    } catch (error) {
      logger.error(`Error getting multi-config: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error("Failed to get multi-config");
    }
  }

  async updateBotStatus(botId: string, status: 'active' | 'inactive'): Promise<void> {
    try {
      // Update regular bot status
      await this.prisma.$executeRaw`
        UPDATE Config SET status = ${status} WHERE botId = ${botId}
      `.catch(() => {
        // If regular bot not found, try updating multi bot
        return this.prisma.$executeRaw`
          UPDATE MultiConfig SET status = ${status} WHERE botId = ${botId}
        `;
      });
    } catch (error) {
      logger.error(`Error updating bot status: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error("Failed to update bot status");
    }
  }

  async disconnect() {
    await this.prisma.$disconnect();
  }
}

================
File: services/getTradeLogs.ts
================
import prisma from "../utils/prismaClient.js";

export async function getTradeLogs() {
  try {
    const transactions = await prisma.transaction.findMany({
      orderBy: {
        date: "desc",
      },  
    });
    if (!transactions) {
      throw new Error("No transactions found");
    }
    return transactions;
  } catch (error) {
    console.error("Error fetching transactions:", error);
  } finally {
    await prisma.$disconnect();
  }
}

================
File: services/notificationService.ts
================
// src/services/notificationService.ts
import nodemailer from 'nodemailer';
import { BotData, LogSwapArgs } from '../core/types.js';
import dotenv from 'dotenv';
import { formatPrice, getTokenName } from '../utils/helper.js';
import prisma from '../utils/prismaClient.js';
import logger from '../utils/logger.js';
import fetch from 'node-fetch';
import { TradeBotError, ErrorCodes } from '../utils/error.js';
import { Socket } from 'socket.io-client';

dotenv.config({ path: '.env' });

export class NotificationService {
  constructor() { }

  public log(message: string, botId: string) {
    logger.info(`[Bot ${botId}] ${message}`);
  }

  async difference(socket: Socket, botData: BotData): Promise<void> {
    try {
      const { botId, inputMint, tokenInPrice, outputMint, tokenOutPrice, currentPrice, targetTrade } = botData;

      const ratio = tokenInPrice && tokenOutPrice ? (tokenInPrice / tokenOutPrice).toFixed(2) : '0';
      const differenceValue = ((targetTrade - currentPrice) / targetTrade) * 100;

      const message = {
        botId: botId.toString(),
        status: 'Running',
        inputMint,
        priceIn: formatPrice(tokenInPrice ?? 0),
        outputMint,
        priceOut: formatPrice(tokenOutPrice ?? 0),
        currentTrade: currentPrice ?? 0,
        targetTrade: targetTrade ?? 0,
        difference: differenceValue,
        ratio: Number(ratio),
        trades: 0
      };

      logger.info(`[Bot ${botId.toString()}] Difference Update: ${JSON.stringify(message)}`);
      
      // Emit the update to the socket
      if (socket) {
        socket.emit('bot:difference', message);
      }
    } catch (e) {
      logger.error('Error updating the UI:', e);
    }
  }

  async logSwap(args: LogSwapArgs): Promise<void> {
    const { botId, tokenIn, tokenInAmount, tokenOut, tokenOutAmount, txid } = args;
    const priceUSDInRecord = await this.getPrice(tokenIn);
    const priceUSDOutRecord = await this.getPrice(tokenOut);
    const priceUSDIn = priceUSDInRecord[tokenIn];
    const priceUSDOut = priceUSDOutRecord[tokenOut];
    const updatedMint = await getTokenName(tokenIn);
    const updatedMintOut = await getTokenName(tokenOut);

    try {
      await prisma.transaction.create({
        data: {
          botId,
          tokenIn: updatedMint || tokenIn,
          tokenInAmount,
          tokenOut: updatedMintOut || tokenOut,
          tokenOutAmount,
          tokenInUSD: Number(priceUSDIn),
          tokenOutUSD: Number(priceUSDOut),
          totalValueUSD: Number(priceUSDIn) * Number(tokenInAmount),
          txid,
        },
      });
      logger.info(`[Bot ${botId}] Logged swap to DB: ${tokenInAmount} ${tokenIn} -> ${tokenOutAmount} ${tokenOut}, TX: ${txid}`);
    } catch (error) {
      const err = new TradeBotError(
        `Error logging swap to DB: ${error instanceof Error ? error.message : String(error)}`,
        ErrorCodes.DB_ERROR,
        { botId, txid }
      );
      logger.error(err.message, err);
      throw err;
    } finally {
      await prisma.$disconnect();
    }
  }

  public async getPrice(mints: string): Promise<Record<string, number>> {
    if (mints.length === 0) {
      throw new TradeBotError('No mint addresses provided', ErrorCodes.INVALID_CONFIG);
    }

    const query = mints;
    const url = `https://lite-api.jup.ag/price/v2?ids=${query}`;

    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
      if (!response) {
        throw new TradeBotError('Invalid response from price API', ErrorCodes.API_ERROR, { url });
      }

      const prices: Record<string, number> = {};
      const json = await response.json() as Record<string, { price: number }>;
      if (json[mints]) {
        prices[mints] = json[mints].price;
      } else {
        logger.warn(`Price for mint '${mints}' not found.`);
      }

      logger.info(`[TradeService] Fetched prices: ${JSON.stringify(prices)}`);
      return prices;
    } catch (error) {
      const err = new TradeBotError(
        `Failed to fetch prices: ${error instanceof Error ? error.message : String(error)}`,
        ErrorCodes.API_ERROR,
        { mints }
      );
      logger.error(err.message, err);
      throw err;
    }
  }
}

================
File: services/rpcFactory.ts
================
import {
  createRpc,
  createSolanaRpcApi,
  createDefaultRpcTransport,
  createSolanaRpcSubscriptions,
  mainnet,
  ClusterUrl,
  SolanaRpcApiMainnet,
  Rpc,
} from "@solana/kit";
import logger from "../utils/logger.js";

export interface RpcClients {
  rpc: Rpc<SolanaRpcApiMainnet>;
  subscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;
}

const replacer = (key: string, value: any) => (typeof value === "bigint" ? value.toString() : value);

export async function createRpcClients(config: { solanaEndpoint: string; wssEndpoint: ClusterUrl }): Promise<RpcClients> {
  logger.info(`[RpcFactory] Creating RPC clients with solanaEndpoint: ${config.solanaEndpoint}, wssEndpoint: ${config.wssEndpoint}`);

  if (!config.solanaEndpoint || !config.solanaEndpoint.startsWith("http")) {
    logger.error(`[RpcFactory] Invalid solanaEndpoint: ${config.solanaEndpoint}`);
    throw new Error("Invalid solanaEndpoint: must be an HTTP/HTTPS URL");
  }
  if (!config.wssEndpoint || !config.wssEndpoint.startsWith("ws")) {
    logger.error(`[RpcFactory] Invalid wssEndpoint: ${config.wssEndpoint}`);
    throw new Error("Invalid wssEndpoint: must be a WebSocket URL");
  }

  try {
    logger.info("[RpcFactory] Creating RPC API...");
    const rpcApi = createSolanaRpcApi<SolanaRpcApiMainnet>({ defaultCommitment: "confirmed" });
    if (!rpcApi) {
      logger.error("[RpcFactory] Failed to create RPC API");
      throw new Error("Failed to create RPC API");
    }
    logger.info("[RpcFactory] RPC API created successfully");

    logger.info("[RpcFactory] Creating JSON-RPC transport...");
    const jsonRpcTransport = createDefaultRpcTransport({ url: config.solanaEndpoint });
    if (!jsonRpcTransport) {
      logger.error("[RpcFactory] Failed to create JSON-RPC transport");
      throw new Error("Failed to create JSON-RPC transport");
    }
    logger.info("[RpcFactory] JSON-RPC transport created successfully");

    logger.info("[RpcFactory] Creating RPC client...");
    const rpc = createRpc({ api: rpcApi, transport: jsonRpcTransport });
    if (!rpc || typeof rpc.getTokenAccountsByOwner !== "function") {
      logger.error("[RpcFactory] Failed to create valid RPC client");
      throw new Error("Failed to create valid RPC client");
    }
    logger.info("[RpcFactory] RPC client created successfully");

    logger.info("[RpcFactory] Creating subscriptions client...");
    const subscriptions = createSolanaRpcSubscriptions(mainnet(config.wssEndpoint));
    if (!subscriptions || typeof subscriptions.signatureNotifications !== "function") {
      logger.error("[RpcFactory] Failed to create valid subscriptions client");
      throw new Error("Failed to create valid subscriptions client");
    }
    logger.info("[RpcFactory] Subscriptions client created successfully");

    // Test RPC client connectivity
    logger.info("[RpcFactory] Testing RPC client connectivity...");
    try {
      const blockhash = await rpc.getLatestBlockhash().send();
      logger.info(`[RpcFactory] RPC test successful: ${JSON.stringify(blockhash, replacer)}`);
    } catch (err) {
      logger.warn(`[RpcFactory] RPC connectivity test failed: ${err instanceof Error ? err.message : String(err)}`);
    }

    return { rpc, subscriptions };
  } catch (err) {
    logger.error(`[RpcFactory] Error creating RPC clients: ${err instanceof Error ? err.stack : String(err)}`);
    throw err;
  }
}

================
File: services/tokenDataService.ts
================
import { TokenInfo } from "../core/types.js";
import prisma from "../utils/prismaClient.js";
import fetch from "node-fetch";
import logger from "../utils/logger.js";

const UPDATE_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

export async function fetchTokenList(forceUpdate: boolean = false) {
    try {
        // Check if we need to update the token list
        const lastUpdate = await prisma.token.findFirst({
            orderBy: { updatedAt: 'desc' },
            select: { updatedAt: true }
        });

        const now = new Date();
        const shouldUpdate = forceUpdate || !lastUpdate || 
            (now.getTime() - lastUpdate.updatedAt.getTime() > UPDATE_INTERVAL);

        if (!shouldUpdate) {
            logger.info('Token list is up to date, skipping update');
            return;
        }

        logger.info('Fetching latest token data from Jupiter API...');
        const lstTaggedResponse = await (
            await fetch('https://lite-api.jup.ag/tokens/v1/tagged/verified')
        ).json();

        // If lstTaggedResponse is an array of tokens, update each one
        if (Array.isArray(lstTaggedResponse)) {
            logger.info(`Found ${lstTaggedResponse.length} tokens to update`);
            for (const token of lstTaggedResponse) {
                await updateTokenData(token as TokenInfo);
            }
        } else {
            // If it's a single token object
            await updateTokenData(lstTaggedResponse as TokenInfo);
        }

        logger.info('Token list updated successfully');
    } catch (error) {
        logger.error(`Failed to fetch token list: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
    }
}

export async function updateTokenData(tokenInfo: TokenInfo) {
    try {
        // First try to find the existing token
        const existingToken = await prisma.token.findUnique({
            where: { address: tokenInfo.address }
        });

        if (existingToken) {
            // Update existing token
            const tokenData = await prisma.token.update({
                where: { id: existingToken.id },
                data: {
                    name: tokenInfo.name,
                    symbol: tokenInfo.symbol,
                    decimals: tokenInfo.decimals,
                    logoURI: tokenInfo.logoURI,
                    updatedAt: new Date()
                }
            });
            return tokenData;
        } else {
            // Create new token
            const tokenData = await prisma.token.create({
                data: {
                    address: tokenInfo.address,
                    name: tokenInfo.name,
                    symbol: tokenInfo.symbol,
                    decimals: tokenInfo.decimals,
                    logoURI: tokenInfo.logoURI,
                    updatedAt: new Date()
                }
            });
            return tokenData;
        }
    } catch (error) {
        logger.error(`Error updating token data: ${error instanceof Error ? error.message : String(error)}`);
        throw error;
    }
}

export async function getTokenDataList() {
  try {
    const tokenDataList = await prisma.token.findMany();
    return tokenDataList;
  } catch (error) {
    console.error("Error fetching token data list:", error);
    throw error;
  }
}

export async function getSingleTokenData(address: string) {
  try {
    const tokenData = await prisma.token.findUnique({
      where: { address },
    });
    return tokenData;
  } catch (error) {
    console.error("Error fetching token data:", error);
    throw error;
  }
}

================
File: services/tradeService.ts
================
import { QuoteGetRequest, QuoteResponse } from "../core/types.js";
import { TradeBotError, ErrorCodes, logError } from "../utils/error.js";
import {
  getAddressFromPublicKey,
  getTransactionDecoder,
  signTransaction,
  assertTransactionIsFullySigned,
  getSignatureFromTransaction,
  SolanaRpcSubscriptionsApi,
  RpcSubscriptions,
  sendAndConfirmTransactionFactory,
  Rpc,
  Address,
  SolanaRpcApiMainnet,
  Signature,
  address,
} from "@solana/kit";
import dotenv from "dotenv";
import fetch from "node-fetch";
import { PublicKey } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from "@solana/spl-token";
import logger from "../utils/logger.js";
import NodeCache from 'node-cache';
const cache = new NodeCache({ stdTTL: 300 }); // 5-minute TTL
dotenv.config();

const replacer = (key: string, value: any) => (typeof value === "bigint" ? value.toString() : value);

export class TradeService {
  private readonly baseUrl: string = "https://lite-api.jup.ag/swap/v1";

  constructor(
    private botId: string,
    private readonly wallet: CryptoKeyPair,
    private readonly rpc: Rpc<SolanaRpcApiMainnet>,
    private readonly subscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>,
    public postTransactionProcessing: (route: QuoteResponse, signature: string) => Promise<void>,
    public setwaitingForConfirmation: (flag: boolean) => void
  ) {
    if (!rpc) {
      throw new TradeBotError('RPC client is undefined', ErrorCodes.INVALID_CONFIG, { botId: botId.toString() });
    }
    if (!subscriptions) {
      throw new TradeBotError('Subscriptions client is undefined', ErrorCodes.INVALID_CONFIG, { botId: botId.toString() });
    }

    if (!wallet.publicKey) {
      throw new TradeBotError('Wallet public key is undefined', ErrorCodes.WALLET_ERROR, { botId: botId.toString() });
    }
  }

  async getFilteredTokenAccounts(wallet: Address, mint: Address): Promise<string> {
    const cacheKey = `${wallet}:${mint}`;
    const cached = cache.get<string>(cacheKey);
    if (cached) {
      logger.info(`[TradeService] Returning cached token account: ${cached}`);
      return cached;
    }
    logger.warn(`[TradeService] Fetching filtered token accounts for wallet: ${wallet}, mint: ${mint}`);
    try {
      const response = await this.rpc.getTokenAccountsByOwner(address(wallet), { mint: mint }, { encoding: "jsonParsed" }).send();
      const accountData = response.value[0]?.account?.data?.parsed?.info;
      const uiAmountString = accountData?.tokenAmount?.uiAmountString;
      logger.warn(`[TradeService] Available balance: ${uiAmountString}`);
      if (!response.value || response.value.length === 0) {
        throw new TradeBotError(`No token account found for mint ${mint}`, ErrorCodes.TOKEN_ACCOUNT_ERROR, { mint });
      }

      const tokenAccount = response.value[0].pubkey;
      if (!tokenAccount || typeof tokenAccount !== 'string') {
        throw new TradeBotError(`Invalid token account public key`, ErrorCodes.TOKEN_ACCOUNT_ERROR, { mint, pubkey: tokenAccount });
      }

      logger.warn(`[TradeService] Selected token account: ${tokenAccount}`);
      cache.set(cacheKey, tokenAccount);
      return tokenAccount;
    } catch (err) {
      const error = logError(err, 'TradeService');
      throw error;
    }
  }

  async getTokenAccountBalance(mint: string): Promise<string> {
    if (!this.wallet || !this.wallet.publicKey) {
      throw new Error("Wallet is not initialized or public key is missing");
    }
    try {
      const publicKeyString = await getAddressFromPublicKey(this.wallet.publicKey);
      const wallet = publicKeyString;

      const tokenAccount = await this.rpc
        .getTokenAccountsByOwner(wallet, { mint: mint as Address }, { encoding: "jsonParsed" })
        .send();
      if (!tokenAccount.value || tokenAccount.value.length === 0) {
        throw new Error(`No token account found for mint ${mint}`);
      }

      const balance = await this.rpc.getTokenAccountBalance(tokenAccount.value[0].pubkey).send();
      return balance.value.uiAmountString || "0";
    } catch (err) {
      logger.error(`[TradeService] Error fetching token balance: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  async signatureSub(signature: Signature): Promise<void> {
    try {
      logger.warn(`[TradeService] Subscribing to signature: ${signature}`);
      this.subscriptions.signatureNotifications(signature, { enableReceivedNotification: true });
    } catch (err) {
      logger.error(`[TradeService] Error subscribing to signature: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  async getSwap(quoteResponse: QuoteResponse, userPublicKey: Address, feeAccount?: Address): Promise<any> {
    logger.warn(`[TradeService] Initiating swap with quote: ${JSON.stringify(quoteResponse, replacer)}`);
    try {
      const swapResponse = await (
        await fetch(`${this.baseUrl}/swap`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            quoteResponse,
            userPublicKey,
            feeAccount,
            wrapAndUnwrapSol: true,
            dynamicComputeUnitLimit: true,
            dynamicSlippage: true,
            prioritizationFeeLamports: {
              priorityLevelWithMaxLamports: {
                maxLamports: 1_000_000,
                priorityLevel: "veryHigh",
              },
            },
          }),
        })
      ).json();
      logger.warn(`[TradeService] Swap response: ${JSON.stringify(swapResponse, replacer)}`);
      return swapResponse;
    } catch (err) {
      logger.error(`[TradeService] Error executing swap: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  public async ata(quoteRequest: QuoteResponse): Promise<string> {
    try {
      const pubWallet = "8sZ5yWf1TPk86ehw7ekPMcrXr76YXgMnLwWe8ZLRjDqz"
      logger.warn(`🔍 [TradeService] Checking ATA for mint: ${quoteRequest.outputMint}`);

      const ata = await getAssociatedTokenAddress(
        new PublicKey(quoteRequest.outputMint),
        new PublicKey(pubWallet),
        false,
        TOKEN_PROGRAM_ID,
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
      logger.warn(`✅ [TradeService] ATA: ${ata.toBase58()}`);
      return ata.toBase58();
    } catch (err) {
      logger.error(`[TradeService] Error fetching ATA: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  public async getQuote2(quoteRequest: QuoteGetRequest): Promise<QuoteResponse | undefined> {
    try {
      if (!quoteRequest.inputMint || !quoteRequest.outputMint || !quoteRequest.amount) {
        throw new Error("Missing required fields: inputMint, outputMint, or amount");
      }

      const url = new URL(`${this.baseUrl}/quote`);
      url.searchParams.append("inputMint", quoteRequest.inputMint);
      url.searchParams.append("outputMint", quoteRequest.outputMint);
      url.searchParams.append("amount", quoteRequest.amount.toString());
      url.searchParams.append("autoSlippage", (quoteRequest.autoSlippage ?? true).toString());
      url.searchParams.append("maxAutoSlippageBps", (quoteRequest.maxAutoSlippageBps ?? 50).toString());
      url.searchParams.append("platformFeeBps", (quoteRequest.platformFeeBps ?? 10).toString());

      const response = await fetch(url.toString(), {
        headers: { Accept: "application/json" },
        method: "GET",
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new TradeBotError(
          `HTTP error fetching quote: ${response.status} ${response.statusText} - ${errorText}`,
          ErrorCodes.QUOTE_FETCH_ERROR,
          { 
            status: response.status,
            statusText: response.statusText,
            url: url.toString(),
            errorText
          }
        );
      }

      const quote = await response.json() as QuoteResponse;
      if (!quote || !quote.outAmount) {
        throw new TradeBotError('Invalid quote response: Missing outAmount', ErrorCodes.QUOTE_FETCH_ERROR, { response: quote });
      }

      return quote;
    } catch (err) {
      const error = err instanceof TradeBotError ? err : new TradeBotError(
        `Failed to fetch quote: ${err instanceof Error ? err.message : String(err)}`,
        ErrorCodes.QUOTE_FETCH_ERROR,
        { quoteRequest }
      );
      logger.error(`[TradeService] ${error.message}`, error);
      throw error;
    }
  }

  public async evaluateQuoteAndSwap(quote: QuoteResponse, thresholdPrice: number, forceSwap: boolean = false): Promise<boolean> {
    if (!quote || !quote.outAmount) {
      throw new TradeBotError('Invalid quote response: Missing outAmount', ErrorCodes.QUOTE_FETCH_ERROR, { response: quote });
    }

    const currentPrice = parseInt(quote.outAmount);

    if (forceSwap || currentPrice >= thresholdPrice) {
      try {
        this.setwaitingForConfirmation(true);
        await this.executeSwap(quote);
        return true;
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : 'Failed to execute swap';
        logger.error(`[TradeService] ${errorMsg}`);
        return false;
      }
    }
    return false;
  }

  private async executeSwap(route: QuoteResponse): Promise<void> {
    const abortController = new AbortController();
    try {
      logger.warn(`📡 [TradeService] Starting swap execution...`);

      const pubKey = await getAddressFromPublicKey(this.wallet.publicKey);
      if (!pubKey) {
        throw new TradeBotError('Error fetching public key', ErrorCodes.WALLET_ERROR);
      }

      const feeAccount = await this.ata(route);

      const tx = await this.getSwap(route, pubKey, feeAccount as Address);
      const swapTransactionBuf = Buffer.from(tx.swapTransaction, "base64");
      if (!Buffer.isBuffer(swapTransactionBuf)) throw new Error("Invalid transaction buffer");

      const transactionDecoder = getTransactionDecoder();
      const swapTransaction = transactionDecoder.decode(swapTransactionBuf);
      const signedTransaction = await signTransaction([this.wallet], swapTransaction);
      assertTransactionIsFullySigned(signedTransaction);

      const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
        rpc: this.rpc,
        rpcSubscriptions: this.subscriptions,
      });
      const latestBlockhash = await this.rpc.getLatestBlockhash().send();
      const signedTransactionWithLifetime = {
        ...signedTransaction,
        lifetimeConstraint: {
          blockhash: latestBlockhash.value.blockhash,
          lastValidBlockHeight: latestBlockhash.value.lastValidBlockHeight,
        },
      };

      const signature = getSignatureFromTransaction(signedTransactionWithLifetime);
      logger.warn(`📜 [TradeService] Transaction signature: ${signature}`);

      await sendAndConfirmTransaction(signedTransactionWithLifetime, {
        commitment: "confirmed",
        abortSignal: abortController.signal,
        maxRetries: BigInt(3),
      });

      logger.warn(`✅ [TradeService] Transaction confirmed: ${signature}`);
      await this.postTransactionProcessing(route, signature);
      logger.warn(`✅ [TradeService] Post-transaction processing completed`);

      this.setwaitingForConfirmation(false);
    } catch (err) {
      const error = err instanceof TradeBotError ? err : new TradeBotError(
        err instanceof Error && err.name === "AbortError"
          ? `Transaction timed out: ${err.message}`
          : `Swap execution failed: ${err instanceof Error ? err.message : String(err)}`,
        ErrorCodes.SWAP_EXECUTION_ERROR,
        { route }
      );
      logger.error(`❌ [TradeService] ${error.message}`, error);
      this.setwaitingForConfirmation(false);
      throw error;
    }
  }
}

================
File: utils/error.ts
================
// src/utils/errors.ts

import logger from "./logger.js";

export class TradeBotError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message);
    this.name = 'TradeBotError';
    // Ensure the stack trace is captured correctly
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, TradeBotError);
    }
  }

  // Utility to convert the error to a serializable object for logging or Socket.IO
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      details: this.details,
      stack: this.stack,
    };
  }
}

// Common error codes for consistency
export const ErrorCodes = {
  QUOTE_FETCH_ERROR: 'QUOTE_FETCH_ERROR',
  SWAP_EXECUTION_ERROR: 'SWAP_EXECUTION_ERROR',
  DB_ERROR: 'DB_ERROR',
  WALLET_ERROR: 'WALLET_ERROR',
  TOKEN_ACCOUNT_ERROR: 'TOKEN_ACCOUNT_ERROR',
  INVALID_CONFIG: 'INVALID_CONFIG',
  API_ERROR: 'API_ERROR',
  BOT_INIT_ERROR: 'BOT_INIT_ERROR',
  BOT_STOP_ERROR: 'BOT_STOP_ERROR',
  NOT_FOUND: 'NOT_FOUND',
} as const;

// Centralized error logging function
export function logError(error: unknown, context?: string): TradeBotError {
  let tradeBotError: TradeBotError;

  if (error instanceof TradeBotError) {
    tradeBotError = error;
  } else if (error instanceof Error) {
    tradeBotError = new TradeBotError(
      `Unexpected error: ${error.message}`,
      'UNKNOWN_ERROR',
      { context, originalError: error.message }
    );
  } else {
    tradeBotError = new TradeBotError(
      `Unexpected error: ${String(error)}`,
      'UNKNOWN_ERROR',
      { context, originalError: error }
    );
  }

  logger.error(`[${context || 'Unknown'}] ${tradeBotError.message}`, tradeBotError);
  return tradeBotError;
}

================
File: utils/helper.ts
================
// tokenService.ts
import NodeCache from "node-cache";
import { ENV } from "../config/index.js";
import logger from "./logger.js";
import prisma from "./prismaClient.js";
import fetch from "cross-fetch";

/**
 * Fetches the decimals for a token by its name.
 *
 * @param tokenName - The name of the token.
 * @returns An object containing the decimals of the token.
 */
export async function getTokenDecimalsByName(tokenName: string): Promise<{ decimals: number }> {
  try {
    const tokens = await prisma.token.findFirst({
      where: {
        OR: [
          { symbol: { equals: tokenName } },
          { name: { equals: tokenName } }
        ]
      },
      select: { decimals: true },
    });

    if (!tokens) {
      throw new Error(`Token with name "${tokenName}" not found.`);
    }

    return { decimals: tokens.decimals };
  } catch (error) {
    throw error;
  }
}

/**
 * Calculates the token value with decimals applied, using the token's blockchain address.
 *
 * @param address - The blockchain address of the token.
 * @param value - The raw token value without decimals.
 * @returns The token value with decimals applied.
 * @throws Will throw an error if the token is not found or a database error occurs.
 */
export async function getTokenDecimalsByAddress(address: string, value: number): Promise<number> {
  try {
    const token = await prisma.token.findUnique({
      where: { address },
    });

    if (!token) {
      throw new Error(`Token with address "${address}" not found.`);
    }

    const tokenValue = value / Math.pow(10, token.decimals);
    return parseFloat(tokenValue.toFixed(2));
  } catch (error) {
    throw error;
  }
}

export async function getTokenDecimalsByAddressRaw(address: string): Promise<number> {
  try {
    const token = await prisma.token.findUnique({
      where: { address },
    });

    if (!token) {
      throw new Error(`Token with address "${address}" not found.`);
    }

    return token.decimals;
  } catch (error) {
    throw error;
  }
}

export async function addTokenDecimalsByAddress(address: string, value: number): Promise<number> {
  try {
    const token = await prisma.token.findUnique({
      where: { address },
    });

    if (!token) {
      throw new Error(`Token with address "${address}" not found.`);
    }

    const tokenValue = value * Math.pow(10, token.decimals);
    return tokenValue;
  } catch (error) {
    throw error;
  }
}

interface dexScreenerRewquest {
  "schemaVersion": string,
  "pairs": [
    {
      "chainId": string,
      "dexId": string,
      "url": string,
      "pairAddress": string,
      "labels": [
        string
      ],
      "baseToken": {
        "address": string,
        "name": string,
        "symbol": string
      },
      "quoteToken": {
        "address": string,
        "name": string,
        "symbol": string
      },
      "priceNative": string,
      "priceUsd": string,
      "liquidity": {
        "usd": number,
        "base": number,
        "quote": number
      },
      "fdv": number,
      "marketCap": number,
      "pairCreatedAt": number,
      "info": {
        "imageUrl": string,
        "websites": [
          {
            "url": string
          }
        ],
        "socials": [
          {
            "platform": string,
            "handle": string
          }
        ]
      },
      "boosts": {
        "active": number
      }
    }
  ]
}
/**
 * Fetches the name of a token by its blockchain address.
 *
 * @param address - The blockchain address of the token.
 * @returns The name of the token.
 * @throws Will throw an error if the token is not found or a database error occurs.
 */
export async function getTokenName(address: string): Promise<string> {
  try {
    const tokens = await prisma.token.findMany({
      where: { address },
    });

    if (!tokens.length) {
      logger.warn(`[TokenService] Token with address ${address} not in strict list. Checking if it's a token account`);
      try {
        const accountInfo = await fetch(`${ENV.solanaEndpoint}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "getAccountInfo",
            params: [address, { encoding: "jsonParsed" }],
          }),
        }).then((res) => res.json());
        if (accountInfo.result && accountInfo.result.value && accountInfo.result.value.data.parsed.info.mint) {
          const mint = accountInfo.result.value.data.parsed.info.mint;
          const dexScreener = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`, {
            method: "GET",
            headers: {},
          });
          const data: dexScreenerRewquest = await dexScreener.json();
          if (data && data.pairs && data.pairs.length > 0) {
            const name = data.pairs[0].baseToken.name;
            if (name) {
              logger.info(`[TokenService] Found token name ${name} for mint ${mint} via DexScreener`);
              return name;
            }
          }
        }
        logger.error(`[TokenService] No mint data or DexScreener response for account ${address}`);
        return address;
      } catch (dexError) {
        logger.error(`[TokenService] Error fetching account info or DexScreener for ${address}: ${dexError instanceof Error ? dexError.message : String(dexError)}`);
        return address;
      }
    } else {
      logger.info(`[TokenService] Found token name ${tokens[0].name} for address ${address} in database`);
      return tokens[0].name;
    }
  } catch (error) {
    logger.error(`[TokenService] Error getting token name for address ${address}: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

/**
 * Formats a numeric price to 4 decimal places.
 *
 * @param price - The numeric price to format.
 * @returns The formatted price or undefined if the price is invalid.
 */
export function formatPrice(price: number): number | undefined {
  try {
    if (price < 0) {
      throw new Error("Price cannot be negative");
    }
    return parseFloat(price.toFixed(4));
  } catch (error) {
    return undefined;
  }
}

/**
 * Formats a numeric value as a percentage with 2 decimal places.
 *
 * @param value - The numeric value to format.
 * @returns The formatted percentage value.
 */
export function formatPercentage(value: number): number {
  return parseFloat(value.toFixed(2));
}
const cache = new NodeCache({ stdTTL: 300 }); // 5-minute TTL
export async function getTokenList(): Promise<{ name: string; address: string; symbol: string }[]> {
  const cached = cache.get('tokenList');
  if (Array.isArray(cached)) {
    return cached as { name: string; address: string; symbol: string }[];
  }
  try {
    const tokens = await prisma.token.findMany({
      select: { name: true, address: true, symbol: true },
    });
    if (tokens.length === 0) {
      logger.warn('No tokens found in the database. Please seed the token table.');
    }
    const tokenList = tokens.map(token => ({
      name: token.name,
      address: token.address,
      symbol: token.symbol,
    }));
    cache.set('tokenList', tokenList);
    return tokenList;
  } catch (error) {
    logger.error(`Failed to fetch token list: ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}


export async function getTokenAddressByName(name: string): Promise<string> {
  try {
    if (!name || typeof name !== 'string') {
      logger.error(`Invalid input to getTokenAddressByName: ${JSON.stringify(name)}`);
      throw new Error('Token name must be a non-empty string');
    }
    const lowerName = name.toLowerCase();
    const token = await prisma.token.findFirst({
      where: {
        OR: [
          { name: { contains: lowerName } },
          { symbol: { contains: lowerName } },
        ],
      },
      select: { address: true },
    });
    if (!token) {
      logger.error(`Token not found for input: ${name}`);
      throw new Error(`Token ${name} not found`);
    }
    return token.address;
  } catch (error) {
    logger.error(`getTokenAddressByName error: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

export function shortenUUID(uuid: string): string {
  // Take first 8 characters and last 4 characters
  return `${uuid.slice(0, 8)}`;
}

================
File: utils/logger.ts
================
import winston from 'winston';
import colors from 'colors';
import { TradeBotError } from './error.js';
import path from 'path';
import fs from 'fs';

// Ensure logs directory exists
const logsDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

winston.addColors({
  info: 'green',
  warn: 'yellow',
  error: 'red',
  component: 'cyan',
  fetching: 'blue',
  balance: 'magenta',
  trade: 'bold green',
  separator: 'gray',
});

// File format without colors
const fileFormat = winston.format.printf(({ level, message, timestamp, ...meta }) => {
  const componentTagMatch = typeof message === 'string' ? message.match(/^\[.*?\]/) : null;
  const componentTag = componentTagMatch ? componentTagMatch[0] : '';
  const messageBody = componentTagMatch
    ? (typeof message === 'string' ? message.slice(componentTag.length).trim() : String(message))
    : (typeof message === 'string' ? message : String(message));

  let errorDetails = '';
  if (meta.error instanceof TradeBotError) {
    const err = meta.error as TradeBotError;
    errorDetails = `\n  Code: ${err.code}\n  Details: ${JSON.stringify(err.details, null, 2)}`;
  } else if (meta.error && typeof meta.error === 'object') {
    errorDetails = `\n  Details: ${JSON.stringify(meta.error, null, 2)}`;
  }

  return `${timestamp} [${level.toUpperCase()}] ${componentTag} ${messageBody}${errorDetails}`;
});

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' }),
    winston.format.errors({ stack: true })
  ),
  transports: [
    // Silent transport to suppress all console output
    new winston.transports.Console({
      silent: true
    }),
    // Error log file - only for actual errors
    new winston.transports.File({
      filename: path.join(logsDir, 'error.log'),
      level: 'error',
      format: fileFormat,
      maxsize: 5242880, // 5MB
      maxFiles: 5,
      tailable: true
    }),
    // Combined log file - for all levels
    new winston.transports.File({
      filename: path.join(logsDir, 'combined.log'),
      format: fileFormat,
      maxsize: 5242880, // 5MB
      maxFiles: 5,
      tailable: true
    }),
    // Daily rotating file - for all levels
    new winston.transports.File({
      filename: path.join(logsDir, 'daily-%DATE%.log'),
      format: fileFormat,
      maxsize: 5242880, // 5MB
      maxFiles: 14, // Keep logs for 14 days
      tailable: true
    })
  ]
});

export default logger;

================
File: utils/prismaClient.ts
================
import { PrismaClient } from "@prisma/client";
import logger from "./logger.js";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create a single instance
const prisma = new PrismaClient({
  log: ['error', 'warn'], // Reduce logging in production
  datasources: {
    db: {
      url: `file:${path.join(__dirname, '../../prisma/dev.db')}`
    }
  }
});

// Test the connection
prisma.$connect()
  .then(() => {
    logger.info('Successfully connected to the database');
  })
  .catch((error) => {
    logger.error('Failed to connect to the database:', error);
  });

// Handle cleanup
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

export default prisma;

================
File: utils/tokenCache.ts
================
import NodeCache from 'node-cache';
import { getTokenList } from './helper.js';

// Cache tokens for 1 hour (3600 seconds)
const tokenCache = new NodeCache({ stdTTL: 3600 });

export interface Token {
  address: string;
  name: string;
  symbol: string;
}

export async function getCachedTokens(): Promise<Token[]> {
  // Try to get tokens from cache first
  const cachedTokens = tokenCache.get<Token[]>('tokens');
  if (cachedTokens) {
    return cachedTokens;
  }

  // If not in cache, fetch from API
  const tokens = await getTokenList();
  
  // Store in cache
  tokenCache.set('tokens', tokens);
  
  return tokens;
}

// Force refresh the cache
export async function refreshTokenCache(): Promise<Token[]> {
  const tokens = await getTokenList();
  tokenCache.set('tokens', tokens);
  return tokens;
}
